
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>QReadWriteLock &#8212; Qt for Python (Technology Preview)</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '5.11.0~a1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="QRandomGenerator" href="QRandomGenerator.html" />
    <link rel="prev" title="QReadLocker" href="QReadLocker.html" />
  <link rel="stylesheet" type="text/css" href="/style/pyside.css" />
  <link rel="icon" type="image/png" href="/style/pyside-32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/style/pyside-16px.png" sizes="16x16" />
  <script type="text/javascript"> wpThemeFolder = 'http://qt.io/wp-content/themes/oneqt'; </script>
  <script type="text/javascript" src="/scripts/main.js"></script>
  <script type="text/javascript" src="/scripts/extras.js"></script>
  <script type="text/javascript">
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-54043535-2', 'qt.io');
    ga('set', 'forceSSL', true);
    ga('send', 'pageview');
  </script>

  </head>
  <body>
<div id="container">
    <div class="header">
        <div class="header_container">
            <header id="navbar">
            </header>
        </div>
    </div>
    <div class="main">
        <div class="main-rounded">
            <div class="navigationbar">
                <ul class="sub-navigation">
                    <li><a href="http://wiki.qt.io/">Wiki</a></li>
                    <li><a href="https://doc.qt.io/">Documentation</a></li>
                    <li><a href="http://forum.qt.io/">Forum</a></li>
                    <li><a href="https://bugreports.qt.io/">Bug Reports</a></li>
                    <li><a href="https://codereview.qt-project.org/">Code Review</a></li>
                </ul>
                <div id="main_title_bar"><h1>Qt Documentation</h1></div>
                <div class="related">
                    <ul>
                        <li><a href="../../index.html">Qt for Python (Technology Preview)</a></li>
                            <li><a href="../../contents.html" >Qt for Python Documentation</a></li>
                            <li><a href="../../modules.html" >Qt for Python modules</a></li>
                            <li><a href="index.html" accesskey="U">PySide2.QtCore</a></li> 
                    </ul>
                </div>
            </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">QReadWriteLock</a><ul>
<li><a class="reference internal" href="#synopsis">Synopsis</a><ul>
<li><a class="reference internal" href="#functions">Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="QReadLocker.html"
                        title="previous chapter">QReadLocker</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="QRandomGenerator.html"
                        title="next chapter">QRandomGenerator</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="module-PySide2.QtCore"></span><div class="section" id="qreadwritelock">
<span id="id1"></span><h1>QReadWriteLock<a class="headerlink" href="#qreadwritelock" title="Permalink to this headline">¶</a></h1>
<img src="../../_images/inheritance-67307691047d87d1b12f3c7e58251bfb7129459e.png" alt="Inheritance diagram of PySide2.QtCore.QReadWriteLock" usemap="#inheritance7be8b6fda9" class="inheritance"/>
<map id="inheritance7be8b6fda9" name="inheritance7be8b6fda9">
<area shape="rect" id="node1" href="#PySide2.QtCore.QReadWriteLock" title="QtCore.QReadWriteLock" alt="" coords="5,5,177,31"/>
</map>
<div class="section" id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead"><code class="xref py py-meth docutils literal"><span class="pre">lockForRead</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite"><code class="xref py py-meth docutils literal"><span class="pre">lockForWrite</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead"><code class="xref py py-meth docutils literal"><span class="pre">tryLockForRead</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead"><code class="xref py py-meth docutils literal"><span class="pre">tryLockForRead</span></code></a> (timeout)</li>
<li>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite"><code class="xref py py-meth docutils literal"><span class="pre">tryLockForWrite</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite"><code class="xref py py-meth docutils literal"><span class="pre">tryLockForWrite</span></code></a> (timeout)</li>
<li>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal"><span class="pre">unlock</span></code></a> ()</li>
</ul>
</div>
</div>
</div>
<div class="section" id="detailed-description">
<h2>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The <a class="reference internal" href="#PySide2.QtCore.QReadWriteLock" title="PySide2.QtCore.QReadWriteLock"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock</span></code></a> class provides read-write locking.</p>
<p>A read-write lock is a synchronization tool for protecting resources that can be accessed for reading and writing. This type of lock is useful if you want to allow multiple threads to have simultaneous read-only access, but as soon as one thread wants to write to the resource, all other threads must be blocked until the writing is complete.</p>
<p>In many cases, <a class="reference internal" href="#PySide2.QtCore.QReadWriteLock" title="PySide2.QtCore.QReadWriteLock"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock</span></code></a> is a direct competitor to <a class="reference internal" href="QMutex.html#PySide2.QtCore.QMutex" title="PySide2.QtCore.QMutex"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QMutex</span></code></a> . <a class="reference internal" href="#PySide2.QtCore.QReadWriteLock" title="PySide2.QtCore.QReadWriteLock"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock</span></code></a> is a good choice if there are many concurrent reads and writing occurs infrequently.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">lock</span> <span class="o">=</span> <span class="n">QReadWriteLock</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">ReaderThread</span><span class="p">:</span>
    <span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">():</span>
        <span class="c1"># ...</span>
        <span class="n">lock</span><span class="o">.</span><span class="n">lockForRead</span><span class="p">()</span>
        <span class="n">read_file</span><span class="p">()</span>
        <span class="n">lock</span><span class="o">.</span><span class="n">unlock</span><span class="p">()</span>
        <span class="c1"># ...</span>

<span class="k">class</span> <span class="nc">WriterThread</span><span class="p">:</span>
    <span class="c1">#...</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">():</span>
        <span class="c1"># ...</span>
        <span class="n">lock</span><span class="o">.</span><span class="n">lockForWrite</span><span class="p">()</span>
        <span class="n">write_file</span><span class="p">()</span>
        <span class="n">lock</span><span class="o">.</span><span class="n">unlock</span><span class="p">()</span>
        <span class="c1"># ...</span>
</pre></div>
</div>
<p>To ensure that writers aren’t blocked forever by readers, readers attempting to obtain a lock will not succeed if there is a blocked writer waiting for access, even if the lock is currently only accessed by other readers. Also, if the lock is accessed by a writer and another writer comes in, that writer will have priority over any readers that might also be waiting.</p>
<p>Like <a class="reference internal" href="QMutex.html#PySide2.QtCore.QMutex" title="PySide2.QtCore.QMutex"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QMutex</span></code></a> , a <a class="reference internal" href="#PySide2.QtCore.QReadWriteLock" title="PySide2.QtCore.QReadWriteLock"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock</span></code></a> can be recursively locked by the same thread when constructed with <code class="xref py py-attr docutils literal"><span class="pre">QReadWriteLock.Recursive</span></code> as <code class="xref py py-attr docutils literal"><span class="pre">QReadWriteLock.RecursionMode</span></code> . In such cases, <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.unlock()</span></code></a> must be called the same number of times <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.lockForWrite()</span></code></a> or <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.lockForRead()</span></code></a> was called. Note that the lock type cannot be changed when trying to lock recursively, i.e. it is not possible to lock for reading in a thread that already has locked for writing (and vice versa).</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="QReadLocker.html#PySide2.QtCore.QReadLocker" title="PySide2.QtCore.QReadLocker"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QReadLocker</span></code></a>  <a class="reference internal" href="QWriteLocker.html#PySide2.QtCore.QWriteLocker" title="PySide2.QtCore.QWriteLocker"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QWriteLocker</span></code></a>  <a class="reference internal" href="QMutex.html#PySide2.QtCore.QMutex" title="PySide2.QtCore.QMutex"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QMutex</span></code></a>  <a class="reference internal" href="QSemaphore.html#PySide2.QtCore.QSemaphore" title="PySide2.QtCore.QSemaphore"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QSemaphore</span></code></a></p>
</div>
</div></blockquote>
<dl class="class">
<dt id="PySide2.QtCore.QReadWriteLock">
<em class="property">class </em><code class="descclassname">PySide2.QtCore.</code><code class="descname">QReadWriteLock</code><span class="sig-paren">(</span><span class="optional">[</span><em>recursionMode=NonRecursive</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.QReadWriteLock" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>recursionMode</strong> – <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.RecursionMode" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.RecursionMode"><code class="xref py py-attr docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.RecursionMode</span></code></a></td>
</tr>
</tbody>
</table>
<p>Constructs a <a class="reference internal" href="#PySide2.QtCore.QReadWriteLock" title="PySide2.QtCore.QReadWriteLock"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock</span></code></a> object in the given <code class="docutils literal"><span class="pre">recursionMode</span></code> .</p>
<p>The default recursion mode is <code class="xref py py-attr docutils literal"><span class="pre">NonRecursive</span></code> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.lockForRead()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.lockForWrite()</span></code></a>  <code class="xref py py-attr docutils literal"><span class="pre">QReadWriteLock.RecursionMode</span></code></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.RecursionMode">
<code class="descclassname">PySide2.QtCore.QReadWriteLock.</code><code class="descname">RecursionMode</code><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.RecursionMode" title="Permalink to this definition">¶</a></dt>
<dd><table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QReadWriteLock.Recursive</td>
<td>In this mode, a thread can lock the same <a class="reference internal" href="#PySide2.QtCore.QReadWriteLock" title="PySide2.QtCore.QReadWriteLock"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock</span></code></a> multiple times. The <a class="reference internal" href="#PySide2.QtCore.QReadWriteLock" title="PySide2.QtCore.QReadWriteLock"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock</span></code></a> won’t be unlocked until a corresponding number of <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.unlock()</span></code></a> calls have been made.</td>
</tr>
<tr class="row-odd"><td>QReadWriteLock.NonRecursive</td>
<td>In this mode, a thread may only lock a <a class="reference internal" href="#PySide2.QtCore.QReadWriteLock" title="PySide2.QtCore.QReadWriteLock"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock</span></code></a> once.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.QReadWriteLock()</span></code></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.StateForWaitCondition">
<code class="descclassname">PySide2.QtCore.QReadWriteLock.</code><code class="descname">StateForWaitCondition</code><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.StateForWaitCondition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead">
<code class="descclassname">PySide2.QtCore.QReadWriteLock.</code><code class="descname">lockForRead</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead" title="Permalink to this definition">¶</a></dt>
<dd><p>Locks the lock for reading. This function will block the current thread if another thread has locked for writing.</p>
<p>It is not possible to lock for read if the thread already has locked for write.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.unlock()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.lockForWrite()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.tryLockForRead()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite">
<code class="descclassname">PySide2.QtCore.QReadWriteLock.</code><code class="descname">lockForWrite</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Locks the lock for writing. This function will block the current thread if another thread (including the current) has locked for reading or writing (unless the lock has been created using the <code class="xref py py-attr docutils literal"><span class="pre">QReadWriteLock.Recursive</span></code> mode).</p>
<p>It is not possible to lock for write if the thread already has locked for read.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.unlock()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.lockForRead()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.tryLockForWrite()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead">
<code class="descclassname">PySide2.QtCore.QReadWriteLock.</code><code class="descname">tryLockForRead</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.bool</span></code></td>
</tr>
</tbody>
</table>
<p>Attempts to lock for reading. If the lock was obtained, this function returns <code class="docutils literal"><span class="pre">true</span></code> , otherwise it returns <code class="docutils literal"><span class="pre">false</span></code> instead of waiting for the lock to become available, i.e. it does not block.</p>
<p>The lock attempt will fail if another thread has locked for writing.</p>
<p>If the lock was obtained, the lock must be unlocked with <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.unlock()</span></code></a> before another thread can successfully lock it for writing.</p>
<p>It is not possible to lock for read if the thread already has locked for write.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.unlock()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.lockForRead()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descclassname">PySide2.QtCore.QReadWriteLock.</code><code class="descname">tryLockForRead</code><span class="sig-paren">(</span><em>timeout</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>timeout</strong> – <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.int</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.bool</span></code></td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Attempts to lock for reading. This function returns <code class="docutils literal"><span class="pre">true</span></code> if the lock was obtained; otherwise it returns <code class="docutils literal"><span class="pre">false</span></code> . If another thread has locked for writing, this function will wait for at most <code class="docutils literal"><span class="pre">timeout</span></code> milliseconds for the lock to become available.</p>
<p>Note: Passing a negative number as the <code class="docutils literal"><span class="pre">timeout</span></code> is equivalent to calling <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.lockForRead()</span></code></a> , i.e. this function will wait forever until lock can be locked for reading when <code class="docutils literal"><span class="pre">timeout</span></code> is negative.</p>
<p>If the lock was obtained, the lock must be unlocked with <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.unlock()</span></code></a> before another thread can successfully lock it for writing.</p>
<p>It is not possible to lock for read if the thread already has locked for write.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.unlock()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.lockForRead()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite">
<code class="descclassname">PySide2.QtCore.QReadWriteLock.</code><code class="descname">tryLockForWrite</code><span class="sig-paren">(</span><em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>timeout</strong> – <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.int</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.bool</span></code></td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Attempts to lock for writing. This function returns <code class="docutils literal"><span class="pre">true</span></code> if the lock was obtained; otherwise it returns <code class="docutils literal"><span class="pre">false</span></code> . If another thread has locked for reading or writing, this function will wait for at most <code class="docutils literal"><span class="pre">timeout</span></code> milliseconds for the lock to become available.</p>
<p>Note: Passing a negative number as the <code class="docutils literal"><span class="pre">timeout</span></code> is equivalent to calling <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.lockForWrite()</span></code></a> , i.e. this function will wait forever until lock can be locked for writing when <code class="docutils literal"><span class="pre">timeout</span></code> is negative.</p>
<p>If the lock was obtained, the lock must be unlocked with <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.unlock()</span></code></a> before another thread can successfully lock it.</p>
<p>It is not possible to lock for write if the thread already has locked for read.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.unlock()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.lockForWrite()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descclassname">PySide2.QtCore.QReadWriteLock.</code><code class="descname">tryLockForWrite</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.bool</span></code></td>
</tr>
</tbody>
</table>
<p>Attempts to lock for writing. If the lock was obtained, this function returns <code class="docutils literal"><span class="pre">true</span></code> ; otherwise, it returns <code class="docutils literal"><span class="pre">false</span></code> immediately.</p>
<p>The lock attempt will fail if another thread has locked for reading or writing.</p>
<p>If the lock was obtained, the lock must be unlocked with <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.unlock()</span></code></a> before another thread can successfully lock it.</p>
<p>It is not possible to lock for write if the thread already has locked for read.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.unlock()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.lockForWrite()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock">
<code class="descclassname">PySide2.QtCore.QReadWriteLock.</code><code class="descname">unlock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlocks the lock.</p>
<p>Attempting to unlock a lock that is not locked is an error, and will result in program termination.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.lockForRead()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.lockForWrite()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.tryLockForRead()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QReadWriteLock.tryLockForWrite()</span></code></a></p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <p>© 2018 The Qt Company Ltd. Documentation contributions included herein are the copyrights of their respective owners. The documentation provided herein is licensed under the terms of the <a href="http://www.gnu.org/license/fdl.html">GNU Free Documentation License version 1.3</a> as published by the Free Software Foundation. Qt and respective logos are trademarks of The Qt Company Ltd. in Finland and/or other countries worldwide. All other trademarks are property of their respective owners.</p>
    </div></div>
    <div id="footer" class="footer">
    </div>
</div>
  </body>
</html>