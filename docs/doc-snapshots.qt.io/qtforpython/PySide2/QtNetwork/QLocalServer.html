
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>QLocalServer &#8212; Qt for Python (Technology Preview)</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '5.11.0~a1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="QTcpServer" href="QTcpServer.html" />
    <link rel="prev" title="QHttpMultiPart" href="QHttpMultiPart.html" />
  <link rel="stylesheet" type="text/css" href="/style/pyside.css" />
  <link rel="icon" type="image/png" href="/style/pyside-32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/style/pyside-16px.png" sizes="16x16" />
  <script type="text/javascript"> wpThemeFolder = 'http://qt.io/wp-content/themes/oneqt'; </script>
  <script type="text/javascript" src="/scripts/main.js"></script>
  <script type="text/javascript" src="/scripts/extras.js"></script>
  <script type="text/javascript">
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-54043535-2', 'qt.io');
    ga('set', 'forceSSL', true);
    ga('send', 'pageview');
  </script>

  </head>
  <body>
<div id="container">
    <div class="header">
        <div class="header_container">
            <header id="navbar">
            </header>
        </div>
    </div>
    <div class="main">
        <div class="main-rounded">
            <div class="navigationbar">
                <ul class="sub-navigation">
                    <li><a href="http://wiki.qt.io/">Wiki</a></li>
                    <li><a href="https://doc.qt.io/">Documentation</a></li>
                    <li><a href="http://forum.qt.io/">Forum</a></li>
                    <li><a href="https://bugreports.qt.io/">Bug Reports</a></li>
                    <li><a href="https://codereview.qt-project.org/">Code Review</a></li>
                </ul>
                <div id="main_title_bar"><h1>Qt Documentation</h1></div>
                <div class="related">
                    <ul>
                        <li><a href="../../index.html">Qt for Python (Technology Preview)</a></li>
                            <li><a href="../../contents.html" >Qt for Python Documentation</a></li>
                            <li><a href="../../modules.html" >Qt for Python modules</a></li>
                            <li><a href="index.html" accesskey="U">PySide2.QtNetwork</a></li> 
                    </ul>
                </div>
            </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">QLocalServer</a><ul>
<li><a class="reference internal" href="#synopsis">Synopsis</a><ul>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#virtual-functions">Virtual functions</a></li>
<li><a class="reference internal" href="#signals">Signals</a></li>
<li><a class="reference internal" href="#static-functions">Static functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="QHttpMultiPart.html"
                        title="previous chapter">QHttpMultiPart</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="QTcpServer.html"
                        title="next chapter">QTcpServer</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="module-PySide2.QtNetwork"></span><div class="section" id="qlocalserver">
<span id="id1"></span><h1>QLocalServer<a class="headerlink" href="#qlocalserver" title="Permalink to this headline">¶</a></h1>
<img src="../../_images/inheritance-bd5b9e0b6c094a8a5b9399195af7be8f100083f0.png" alt="Inheritance diagram of PySide2.QtNetwork.QLocalServer" usemap="#inheritance243e04b5de" class="inheritance"/>
<map id="inheritance243e04b5de" name="inheritance243e04b5de">
<area shape="rect" id="node1" href="#PySide2.QtNetwork.QLocalServer" title="QtNetwork.QLocalServer" alt="" coords="176,5,355,31"/>
<area shape="rect" id="node2" href="../QtCore/QObject.html#PySide2.QtCore.QObject" title="QtCore.QObject" alt="" coords="5,5,128,31"/>
</map>
<div class="section" id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.close" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.close"><code class="xref py py-meth docutils literal"><span class="pre">close</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.errorString" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.errorString"><code class="xref py py-meth docutils literal"><span class="pre">errorString</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.fullServerName" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.fullServerName"><code class="xref py py-meth docutils literal"><span class="pre">fullServerName</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.isListening" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.isListening"><code class="xref py py-meth docutils literal"><span class="pre">isListening</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen"><code class="xref py py-meth docutils literal"><span class="pre">listen</span></code></a> (name)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen"><code class="xref py py-meth docutils literal"><span class="pre">listen</span></code></a> (socketDescriptor)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.maxPendingConnections" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.maxPendingConnections"><code class="xref py py-meth docutils literal"><span class="pre">maxPendingConnections</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverError" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverError"><code class="xref py py-meth docutils literal"><span class="pre">serverError</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverName" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverName"><code class="xref py py-meth docutils literal"><span class="pre">serverName</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.setMaxPendingConnections" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.setMaxPendingConnections"><code class="xref py py-meth docutils literal"><span class="pre">setMaxPendingConnections</span></code></a> (numConnections)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.setSocketOptions" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.setSocketOptions"><code class="xref py py-meth docutils literal"><span class="pre">setSocketOptions</span></code></a> (options)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.socketDescriptor" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.socketDescriptor"><code class="xref py py-meth docutils literal"><span class="pre">socketDescriptor</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.socketOptions" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.socketOptions"><code class="xref py py-meth docutils literal"><span class="pre">socketOptions</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.waitForNewConnection" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.waitForNewConnection"><code class="xref py py-meth docutils literal"><span class="pre">waitForNewConnection</span></code></a> (msec)</li>
</ul>
</div>
</div>
<div class="section" id="virtual-functions">
<h3>Virtual functions<a class="headerlink" href="#virtual-functions" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.hasPendingConnections" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.hasPendingConnections"><code class="xref py py-meth docutils literal"><span class="pre">hasPendingConnections</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.incomingConnection" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.incomingConnection"><code class="xref py py-meth docutils literal"><span class="pre">incomingConnection</span></code></a> (socketDescriptor)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.nextPendingConnection" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.nextPendingConnection"><code class="xref py py-meth docutils literal"><span class="pre">nextPendingConnection</span></code></a> ()</li>
</ul>
</div>
</div>
<div class="section" id="signals">
<h3>Signals<a class="headerlink" href="#signals" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.newConnection" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.newConnection"><code class="xref py py-meth docutils literal"><span class="pre">newConnection</span></code></a> ()</li>
</ul>
</div>
</div>
<div class="section" id="static-functions">
<h3>Static functions<a class="headerlink" href="#static-functions" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.removeServer" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.removeServer"><code class="xref py py-meth docutils literal"><span class="pre">removeServer</span></code></a> (name)</li>
</ul>
</div>
</div>
</div>
<div class="section" id="detailed-description">
<h2>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The <a class="reference internal" href="#PySide2.QtNetwork.QLocalServer" title="PySide2.QtNetwork.QLocalServer"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer</span></code></a> class provides a local socket based server.</p>
<p>This class makes it possible to accept incoming local socket connections.</p>
<p>Call <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.listen()</span></code></a> to have the server start listening for incoming connections on a specified key. The <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.newConnection" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.newConnection"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.newConnection()</span></code></a> signal is then emitted each time a client connects to the server.</p>
<p>Call <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.nextPendingConnection" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.nextPendingConnection"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.nextPendingConnection()</span></code></a> to accept the pending connection as a connected <a class="reference internal" href="QLocalSocket.html#PySide2.QtNetwork.QLocalSocket" title="PySide2.QtNetwork.QLocalSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QLocalSocket</span></code></a> . The function returns a pointer to a <a class="reference internal" href="QLocalSocket.html#PySide2.QtNetwork.QLocalSocket" title="PySide2.QtNetwork.QLocalSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QLocalSocket</span></code></a> that can be used for communicating with the client.</p>
<p>If an error occurs, <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverError" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverError"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.serverError()</span></code></a> returns the type of error, and <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.errorString" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.errorString"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.errorString()</span></code></a> can be called to get a human readable description of what happened.</p>
<p>When listening for connections, the name which the server is listening on is available through <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverName" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverName"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.serverName()</span></code></a> .</p>
<p>Calling <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.close" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.close"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.close()</span></code></a> makes <a class="reference internal" href="#PySide2.QtNetwork.QLocalServer" title="PySide2.QtNetwork.QLocalServer"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer</span></code></a> stop listening for incoming connections.</p>
<p>Although <a class="reference internal" href="#PySide2.QtNetwork.QLocalServer" title="PySide2.QtNetwork.QLocalServer"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer</span></code></a> is designed for use with an event loop, it’s possible to use it without one. In that case, you must use <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.waitForNewConnection" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.waitForNewConnection"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.waitForNewConnection()</span></code></a> , which blocks until either a connection is available or a timeout expires.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="QLocalSocket.html#PySide2.QtNetwork.QLocalSocket" title="PySide2.QtNetwork.QLocalSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QLocalSocket</span></code></a>  <a class="reference internal" href="QTcpServer.html#PySide2.QtNetwork.QTcpServer" title="PySide2.QtNetwork.QTcpServer"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QTcpServer</span></code></a></p>
</div>
</div></blockquote>
<dl class="class">
<dt id="PySide2.QtNetwork.QLocalServer">
<em class="property">class </em><code class="descclassname">PySide2.QtNetwork.</code><code class="descname">QLocalServer</code><span class="sig-paren">(</span><span class="optional">[</span><em>parent=nullptr</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.QLocalServer" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>parent</strong> – <a class="reference internal" href="../QtCore/QObject.html#PySide2.QtCore.QObject" title="PySide2.QtCore.QObject"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QObject</span></code></a></td>
</tr>
</tbody>
</table>
<p>Create a new local socket server with the given <code class="docutils literal"><span class="pre">parent</span></code> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.listen()</span></code></a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.SocketOption">
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">SocketOption</code><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.SocketOption" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum describes the possible options that can be used to create the socket. This changes the access permissions on platforms (Linux, Windows) that support access permissions on the socket. Both GroupAccess and OtherAccess may vary slightly in meanings depending on the platform.</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QLocalServer.NoOptions</td>
<td>No access restrictions have been set.</td>
</tr>
<tr class="row-odd"><td>QLocalServer.UserAccessOption</td>
<td>Access is restricted to the same user as the process that created the socket.</td>
</tr>
<tr class="row-even"><td>QLocalServer.GroupAccessOption</td>
<td>Access is restricted to the same group but not the user that created the socket on Linux. Access is restricted to the primary group of the process on Windows</td>
</tr>
<tr class="row-odd"><td>QLocalServer.OtherAccessOption</td>
<td>Access is available to everyone but the user and group that created the socket on Linux. Access is available to everyone on Windows.</td>
</tr>
<tr class="row-even"><td>QLocalServer.WorldAccessOption</td>
<td>No access restrictions.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.socketOptions" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.socketOptions"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.socketOptions()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.close">
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop listening for incoming connections. Existing connections are not affected, but any new connections will be refused.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.isListening" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.isListening"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.isListening()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.listen()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.errorString">
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">errorString</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.errorString" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">unicode</td>
</tr>
</tbody>
</table>
<p>Returns the human-readable message appropriate to the current error reported by <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverError" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverError"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.serverError()</span></code></a> . If no suitable string is available, an empty string is returned.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverError" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverError"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.serverError()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.fullServerName">
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">fullServerName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.fullServerName" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">unicode</td>
</tr>
</tbody>
</table>
<p>Returns the full path that the server is listening on.</p>
<p>Note: This is platform specific</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.listen()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverName" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverName"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.serverName()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.hasPendingConnections">
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">hasPendingConnections</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.hasPendingConnections" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.bool</span></code></td>
</tr>
</tbody>
</table>
<p>Returns <code class="docutils literal"><span class="pre">true</span></code> if the server has a pending connection; otherwise returns <code class="docutils literal"><span class="pre">false</span></code> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.nextPendingConnection" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.nextPendingConnection"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.nextPendingConnection()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.setMaxPendingConnections" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.setMaxPendingConnections"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.setMaxPendingConnections()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.incomingConnection">
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">incomingConnection</code><span class="sig-paren">(</span><em>socketDescriptor</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.incomingConnection" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>socketDescriptor</strong> – <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.quintptr</span></code></td>
</tr>
</tbody>
</table>
<p>This virtual function is called by <a class="reference internal" href="#PySide2.QtNetwork.QLocalServer" title="PySide2.QtNetwork.QLocalServer"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer</span></code></a> when a new connection is available. <code class="docutils literal"><span class="pre">socketDescriptor</span></code> is the native socket descriptor for the accepted connection.</p>
<p>The base implementation creates a <a class="reference internal" href="QLocalSocket.html#PySide2.QtNetwork.QLocalSocket" title="PySide2.QtNetwork.QLocalSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QLocalSocket</span></code></a> , sets the socket descriptor and then stores the <a class="reference internal" href="QLocalSocket.html#PySide2.QtNetwork.QLocalSocket" title="PySide2.QtNetwork.QLocalSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QLocalSocket</span></code></a> in an internal list of pending connections. Finally <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.newConnection" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.newConnection"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.newConnection()</span></code></a> is emitted.</p>
<p>Reimplement this function to alter the server’s behavior when a connection is available.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.newConnection" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.newConnection"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.newConnection()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.nextPendingConnection" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.nextPendingConnection"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.nextPendingConnection()</span></code></a>  <a class="reference internal" href="QLocalSocket.html#PySide2.QtNetwork.PySide2.QtNetwork.QLocalSocket.setSocketDescriptor" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalSocket.setSocketDescriptor"><code class="xref py py-meth docutils literal"><span class="pre">QLocalSocket.setSocketDescriptor()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.isListening">
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">isListening</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.isListening" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.bool</span></code></td>
</tr>
</tbody>
</table>
<p>Returns <code class="docutils literal"><span class="pre">true</span></code> if the server is listening for incoming connections otherwise false.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.listen()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.close" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.close"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.close()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen">
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">listen</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> – unicode</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.bool</span></code></td>
</tr>
</tbody>
</table>
<p>Tells the server to listen for incoming connections on <code class="docutils literal"><span class="pre">name</span></code> . If the server is currently listening then it will return false. Return true on success otherwise false.</p>
<p><code class="docutils literal"><span class="pre">name</span></code> can be a single name and <a class="reference internal" href="#PySide2.QtNetwork.QLocalServer" title="PySide2.QtNetwork.QLocalServer"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer</span></code></a> will determine the correct platform specific path. <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverName" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverName"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.serverName()</span></code></a> will return the name that is passed into listen.</p>
<p>Usually you would just pass in a name like “foo”, but on Unix this could also be a path such as “/tmp/foo” and on Windows this could be a pipe path such as “\.\pipe\foo”</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On Unix if the server crashes without closing listen will fail with AddressInUseError. To create a new server the file should be removed. On Windows two local servers can listen to the same pipe at the same time, but any connections will go to one of the server.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverName" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverName"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.serverName()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.isListening" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.isListening"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.isListening()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.close" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.close"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.close()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">listen</code><span class="sig-paren">(</span><em>socketDescriptor</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>socketDescriptor</strong> – <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.qintptr</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.bool</span></code></td>
</tr>
</tbody>
</table>
<p>Instructs the server to listen for incoming connections on <code class="docutils literal"><span class="pre">socketDescriptor</span></code> . The property returns <code class="docutils literal"><span class="pre">false</span></code> if the server is currently listening. It returns <code class="docutils literal"><span class="pre">true</span></code> on success; otherwise, it returns <code class="docutils literal"><span class="pre">false</span></code> . The socket must be ready to accept new connections with no extra platform-specific functions called. The socket is set into non-blocking mode.</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverName" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverName"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.serverName()</span></code></a> , <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.fullServerName" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.fullServerName"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.fullServerName()</span></code></a> may return a string with a name if this option is supported by the platform; otherwise, they return an empty <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QString</span></code> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.isListening" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.isListening"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.isListening()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.close" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.close"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.close()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.maxPendingConnections">
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">maxPendingConnections</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.maxPendingConnections" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.int</span></code></td>
</tr>
</tbody>
</table>
<p>Returns the maximum number of pending accepted connections. The default is 30.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.setMaxPendingConnections" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.setMaxPendingConnections"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.setMaxPendingConnections()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.hasPendingConnections" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.hasPendingConnections"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.hasPendingConnections()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.newConnection">
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">newConnection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.newConnection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.nextPendingConnection">
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">nextPendingConnection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.nextPendingConnection" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QLocalSocket.html#PySide2.QtNetwork.QLocalSocket" title="PySide2.QtNetwork.QLocalSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QLocalSocket</span></code></a></td>
</tr>
</tbody>
</table>
<p>Returns the next pending connection as a connected <a class="reference internal" href="QLocalSocket.html#PySide2.QtNetwork.QLocalSocket" title="PySide2.QtNetwork.QLocalSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QLocalSocket</span></code></a> object.</p>
<p>The socket is created as a child of the server, which means that it is automatically deleted when the <a class="reference internal" href="#PySide2.QtNetwork.QLocalServer" title="PySide2.QtNetwork.QLocalServer"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer</span></code></a> object is destroyed. It is still a good idea to delete the object explicitly when you are done with it, to avoid wasting memory.</p>
<p>0 is returned if this function is called when there are no pending connections.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.hasPendingConnections" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.hasPendingConnections"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.hasPendingConnections()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.newConnection" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.newConnection"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.newConnection()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.incomingConnection" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.incomingConnection"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.incomingConnection()</span></code></a></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.removeServer">
<em class="property">static </em><code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">removeServer</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.removeServer" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> – unicode</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.bool</span></code></td>
</tr>
</tbody>
</table>
<p>Removes any server instance that might cause a call to <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.listen()</span></code></a> to fail and returns <code class="docutils literal"><span class="pre">true</span></code> if successful; otherwise returns <code class="docutils literal"><span class="pre">false</span></code> . This function is meant to recover from a crash, when the previous server instance has not been cleaned up.</p>
<p>On Windows, this function does nothing; on Unix, it removes the socket file given by <code class="docutils literal"><span class="pre">name</span></code> .</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Be careful to avoid removing sockets of running instances.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverError">
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">serverError</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverError" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QAbstractSocket.html#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketError" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketError"><code class="xref py py-attr docutils literal"><span class="pre">PySide2.QtNetwork.QAbstractSocket.SocketError</span></code></a></td>
</tr>
</tbody>
</table>
<p>Returns the type of error that occurred last or NoError.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.errorString" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.errorString"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.errorString()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverName">
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">serverName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.serverName" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">unicode</td>
</tr>
</tbody>
</table>
<p>Returns the server name if the server is listening for connections; otherwise returns QString()</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.listen()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.fullServerName" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.fullServerName"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.fullServerName()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.setMaxPendingConnections">
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">setMaxPendingConnections</code><span class="sig-paren">(</span><em>numConnections</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.setMaxPendingConnections" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>numConnections</strong> – <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.int</span></code></td>
</tr>
</tbody>
</table>
<p>Sets the maximum number of pending accepted connections to <code class="docutils literal"><span class="pre">numConnections</span></code> . <a class="reference internal" href="#PySide2.QtNetwork.QLocalServer" title="PySide2.QtNetwork.QLocalServer"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer</span></code></a> will accept no more than <code class="docutils literal"><span class="pre">numConnections</span></code> incoming connections before <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.nextPendingConnection" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.nextPendingConnection"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.nextPendingConnection()</span></code></a> is called.</p>
<p>Note: Even though <a class="reference internal" href="#PySide2.QtNetwork.QLocalServer" title="PySide2.QtNetwork.QLocalServer"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer</span></code></a> will stop accepting new connections after it has reached its maximum number of pending connections, the operating system may still keep them in queue which will result in clients signaling that it is connected.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.maxPendingConnections" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.maxPendingConnections"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.maxPendingConnections()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.hasPendingConnections" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.hasPendingConnections"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.hasPendingConnections()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.setSocketOptions">
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">setSocketOptions</code><span class="sig-paren">(</span><em>options</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.setSocketOptions" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>options</strong> – <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.SocketOptions</span></code></td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.socketOptions" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.socketOptions"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.socketOptions()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.socketDescriptor">
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">socketDescriptor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.socketDescriptor" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.qintptr</span></code></td>
</tr>
</tbody>
</table>
<p>Returns the native socket descriptor the server uses to listen for incoming instructions, or -1 if the server is not listening.</p>
<p>The type of the descriptor depends on the platform:</p>
<ul class="simple">
<li>On Windows, the returned value is a Winsock 2 Socket Handle.</li>
<li>With WinRT and on INTEGRITY, the returned value is the <a class="reference internal" href="QTcpServer.html#PySide2.QtNetwork.QTcpServer" title="PySide2.QtNetwork.QTcpServer"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QTcpServer</span></code></a> socket descriptor and the type is defined by <a class="reference internal" href="QTcpServer.html#PySide2.QtNetwork.PySide2.QtNetwork.QTcpServer.socketDescriptor" title="PySide2.QtNetwork.PySide2.QtNetwork.QTcpServer.socketDescriptor"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QTcpServer.socketDescriptor()</span></code></a> .</li>
<li>On all other UNIX-like operating systems, the type is a file descriptor representing a listening socket.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.listen"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.listen()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.socketOptions">
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">socketOptions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.socketOptions" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.SocketOptions</span></code></td>
</tr>
</tbody>
</table>
<p>Returns the socket options set on the socket.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.setSocketOptions" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.setSocketOptions"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.setSocketOptions()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.waitForNewConnection">
<code class="descclassname">PySide2.QtNetwork.QLocalServer.</code><code class="descname">waitForNewConnection</code><span class="sig-paren">(</span><em>msec</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.waitForNewConnection" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>msec</strong> – <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.int</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">(retval, timeOut)</td>
</tr>
</tbody>
</table>
<p>Waits for at most <code class="docutils literal"><span class="pre">msec</span></code> milliseconds or until an incoming connection is available. Returns <code class="docutils literal"><span class="pre">true</span></code> if a connection is available; otherwise returns <code class="docutils literal"><span class="pre">false</span></code> . If the operation timed out and <code class="docutils literal"><span class="pre">timedOut</span></code> is not 0, *timedOut will be set to true.</p>
<p>This is a blocking function call. Its use is ill-advised in a single-threaded GUI application, since the whole application will stop responding until the function returns. is mostly useful when there is no event loop available.</p>
<p>The non-blocking alternative is to connect to the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.newConnection" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.newConnection"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.newConnection()</span></code></a> signal.</p>
<p>If msec is -1, this function will not time out.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.hasPendingConnections" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.hasPendingConnections"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.hasPendingConnections()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.nextPendingConnection" title="PySide2.QtNetwork.PySide2.QtNetwork.QLocalServer.nextPendingConnection"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QLocalServer.nextPendingConnection()</span></code></a></p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <p>© 2018 The Qt Company Ltd. Documentation contributions included herein are the copyrights of their respective owners. The documentation provided herein is licensed under the terms of the <a href="http://www.gnu.org/license/fdl.html">GNU Free Documentation License version 1.3</a> as published by the Free Software Foundation. Qt and respective logos are trademarks of The Qt Company Ltd. in Finland and/or other countries worldwide. All other trademarks are property of their respective owners.</p>
    </div></div>
    <div id="footer" class="footer">
    </div>
</div>
  </body>
</html>