
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>QSslSocket &#8212; Qt for Python (Technology Preview)</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '5.11.0~a1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="QSslKey" href="QSslKey.html" />
    <link rel="prev" title="QSslCertificate" href="QSslCertificate.html" />
  <link rel="stylesheet" type="text/css" href="/style/pyside.css" />
  <link rel="icon" type="image/png" href="/style/pyside-32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/style/pyside-16px.png" sizes="16x16" />
  <script type="text/javascript"> wpThemeFolder = 'http://qt.io/wp-content/themes/oneqt'; </script>
  <script type="text/javascript" src="/scripts/main.js"></script>
  <script type="text/javascript" src="/scripts/extras.js"></script>
  <script type="text/javascript">
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-54043535-2', 'qt.io');
    ga('set', 'forceSSL', true);
    ga('send', 'pageview');
  </script>

  </head>
  <body>
<div id="container">
    <div class="header">
        <div class="header_container">
            <header id="navbar">
            </header>
        </div>
    </div>
    <div class="main">
        <div class="main-rounded">
            <div class="navigationbar">
                <ul class="sub-navigation">
                    <li><a href="http://wiki.qt.io/">Wiki</a></li>
                    <li><a href="https://doc.qt.io/">Documentation</a></li>
                    <li><a href="http://forum.qt.io/">Forum</a></li>
                    <li><a href="https://bugreports.qt.io/">Bug Reports</a></li>
                    <li><a href="https://codereview.qt-project.org/">Code Review</a></li>
                </ul>
                <div id="main_title_bar"><h1>Qt Documentation</h1></div>
                <div class="related">
                    <ul>
                        <li><a href="../../index.html">Qt for Python (Technology Preview)</a></li>
                            <li><a href="../../contents.html" >Qt for Python Documentation</a></li>
                            <li><a href="../../modules.html" >Qt for Python modules</a></li>
                            <li><a href="index.html" accesskey="U">PySide2.QtNetwork</a></li> 
                    </ul>
                </div>
            </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">QSslSocket</a><ul>
<li><a class="reference internal" href="#synopsis">Synopsis</a><ul>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#slots">Slots</a></li>
<li><a class="reference internal" href="#signals">Signals</a></li>
<li><a class="reference internal" href="#static-functions">Static functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="QSslCertificate.html"
                        title="previous chapter">QSslCertificate</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="QSslKey.html"
                        title="next chapter">QSslKey</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="module-PySide2.QtNetwork"></span><div class="section" id="qsslsocket">
<span id="id1"></span><h1>QSslSocket<a class="headerlink" href="#qsslsocket" title="Permalink to this headline">¶</a></h1>
<img src="../../_images/inheritance-6dbac19f31fa69ee2a74b2ffaa3b43b17bb94bca.png" alt="Inheritance diagram of PySide2.QtNetwork.QSslSocket" usemap="#inheritance691493c6f4" class="inheritance"/>
<map id="inheritance691493c6f4" name="inheritance691493c6f4">
<area shape="rect" id="node1" href="#PySide2.QtNetwork.QSslSocket" title="QtNetwork.QSslSocket" alt="" coords="636,4,764,24"/>
<area shape="rect" id="node2" href="QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="QtNetwork.QTcpSocket" alt="" coords="470,4,599,24"/>
<area shape="rect" id="node3" href="QAbstractSocket.html#PySide2.QtNetwork.QAbstractSocket" title="QtNetwork.QAbstractSocket" alt="" coords="278,4,433,24"/>
<area shape="rect" id="node4" href="../QtCore/QIODevice.html#PySide2.QtCore.QIODevice" title="QtCore.QIODevice" alt="" coords="136,4,241,24"/>
<area shape="rect" id="node5" href="../QtCore/QObject.html#PySide2.QtCore.QObject" title="QtCore.QObject" alt="" coords="4,4,99,24"/>
</map>
<div class="section" id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificate"><code class="xref py py-meth docutils literal"><span class="pre">addCaCertificate</span></code></a> (certificate)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">addCaCertificates</span></code></a> (certificates)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">addCaCertificates</span></code></a> (path[, format=QSsl.Pem[, syntax=QRegExp.FixedString]])</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.caCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.caCertificates"><code class="xref py py-meth docutils literal"><span class="pre">caCertificates</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ciphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ciphers"><code class="xref py py-meth docutils literal"><span class="pre">ciphers</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">connectToHostEncrypted</span></code></a> (hostName, port, sslPeerName[, mode=QIODevice.ReadWrite[, protocol=AnyIPProtocol]])</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">connectToHostEncrypted</span></code></a> (hostName, port[, mode=QIODevice.ReadWrite[, protocol=AnyIPProtocol]])</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encryptedBytesAvailable" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encryptedBytesAvailable"><code class="xref py py-meth docutils literal"><span class="pre">encryptedBytesAvailable</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encryptedBytesToWrite" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encryptedBytesToWrite"><code class="xref py py-meth docutils literal"><span class="pre">encryptedBytesToWrite</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ignoreSslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ignoreSslErrors"><code class="xref py py-meth docutils literal"><span class="pre">ignoreSslErrors</span></code></a> (errors)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.isEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.isEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">isEncrypted</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.localCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.localCertificate"><code class="xref py py-meth docutils literal"><span class="pre">localCertificate</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.localCertificateChain" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.localCertificateChain"><code class="xref py py-meth docutils literal"><span class="pre">localCertificateChain</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.mode" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.mode"><code class="xref py py-meth docutils literal"><span class="pre">mode</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificate"><code class="xref py py-meth docutils literal"><span class="pre">peerCertificate</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificateChain" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificateChain"><code class="xref py py-meth docutils literal"><span class="pre">peerCertificateChain</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyDepth" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyDepth"><code class="xref py py-meth docutils literal"><span class="pre">peerVerifyDepth</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyMode" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyMode"><code class="xref py py-meth docutils literal"><span class="pre">peerVerifyMode</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyName" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyName"><code class="xref py py-meth docutils literal"><span class="pre">peerVerifyName</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.privateKey" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.privateKey"><code class="xref py py-meth docutils literal"><span class="pre">privateKey</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.protocol" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.protocol"><code class="xref py py-meth docutils literal"><span class="pre">protocol</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sessionCipher" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sessionCipher"><code class="xref py py-meth docutils literal"><span class="pre">sessionCipher</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sessionProtocol" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sessionProtocol"><code class="xref py py-meth docutils literal"><span class="pre">sessionProtocol</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">setCaCertificates</span></code></a> (certificates)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers"><code class="xref py py-meth docutils literal"><span class="pre">setCiphers</span></code></a> (ciphers)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers"><code class="xref py py-meth docutils literal"><span class="pre">setCiphers</span></code></a> (ciphers)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificate"><code class="xref py py-meth docutils literal"><span class="pre">setLocalCertificate</span></code></a> (certificate)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificate"><code class="xref py py-meth docutils literal"><span class="pre">setLocalCertificate</span></code></a> (fileName[, format=QSsl.Pem])</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificateChain" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificateChain"><code class="xref py py-meth docutils literal"><span class="pre">setLocalCertificateChain</span></code></a> (localChain)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyDepth" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyDepth"><code class="xref py py-meth docutils literal"><span class="pre">setPeerVerifyDepth</span></code></a> (depth)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyMode" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyMode"><code class="xref py py-meth docutils literal"><span class="pre">setPeerVerifyMode</span></code></a> (mode)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyName" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyName"><code class="xref py py-meth docutils literal"><span class="pre">setPeerVerifyName</span></code></a> (hostName)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPrivateKey" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPrivateKey"><code class="xref py py-meth docutils literal"><span class="pre">setPrivateKey</span></code></a> (fileName[, algorithm=QSsl.Rsa[, format=QSsl.Pem[, passPhrase=QByteArray()]]])</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPrivateKey" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPrivateKey"><code class="xref py py-meth docutils literal"><span class="pre">setPrivateKey</span></code></a> (key)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setProtocol" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setProtocol"><code class="xref py py-meth docutils literal"><span class="pre">setProtocol</span></code></a> (protocol)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setSslConfiguration" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setSslConfiguration"><code class="xref py py-meth docutils literal"><span class="pre">setSslConfiguration</span></code></a> (config)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslConfiguration" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslConfiguration"><code class="xref py py-meth docutils literal"><span class="pre">sslConfiguration</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors"><code class="xref py py-meth docutils literal"><span class="pre">sslErrors</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.waitForEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.waitForEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">waitForEncrypted</span></code></a> ([msecs=30000])</li>
</ul>
</div>
</div>
<div class="section" id="slots">
<h3>Slots<a class="headerlink" href="#slots" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ignoreSslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ignoreSslErrors"><code class="xref py py-meth docutils literal"><span class="pre">ignoreSslErrors</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startClientEncryption" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startClientEncryption"><code class="xref py py-meth docutils literal"><span class="pre">startClientEncryption</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startServerEncryption" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startServerEncryption"><code class="xref py py-meth docutils literal"><span class="pre">startServerEncryption</span></code></a> ()</li>
</ul>
</div>
</div>
<div class="section" id="signals">
<h3>Signals<a class="headerlink" href="#signals" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted"><code class="xref py py-meth docutils literal"><span class="pre">encrypted</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encryptedBytesWritten" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encryptedBytesWritten"><code class="xref py py-meth docutils literal"><span class="pre">encryptedBytesWritten</span></code></a> (totalBytes)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.modeChanged" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.modeChanged"><code class="xref py py-meth docutils literal"><span class="pre">modeChanged</span></code></a> (newMode)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyError" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyError"><code class="xref py py-meth docutils literal"><span class="pre">peerVerifyError</span></code></a> (error)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.preSharedKeyAuthenticationRequired" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.preSharedKeyAuthenticationRequired"><code class="xref py py-meth docutils literal"><span class="pre">preSharedKeyAuthenticationRequired</span></code></a> (authenticator)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors"><code class="xref py py-meth docutils literal"><span class="pre">sslErrors</span></code></a> (errors)</li>
</ul>
</div>
</div>
<div class="section" id="static-functions">
<h3>Static functions<a class="headerlink" href="#static-functions" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificate"><code class="xref py py-meth docutils literal"><span class="pre">addDefaultCaCertificate</span></code></a> (certificate)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">addDefaultCaCertificates</span></code></a> (certificates)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">addDefaultCaCertificates</span></code></a> (path[, format=QSsl.Pem[, syntax=QRegExp.FixedString]])</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">defaultCaCertificates</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCiphers"><code class="xref py py-meth docutils literal"><span class="pre">defaultCiphers</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">setDefaultCaCertificates</span></code></a> (certificates)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCiphers"><code class="xref py py-meth docutils literal"><span class="pre">setDefaultCiphers</span></code></a> (ciphers)</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryBuildVersionNumber" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryBuildVersionNumber"><code class="xref py py-meth docutils literal"><span class="pre">sslLibraryBuildVersionNumber</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryBuildVersionString" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryBuildVersionString"><code class="xref py py-meth docutils literal"><span class="pre">sslLibraryBuildVersionString</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryVersionNumber" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryVersionNumber"><code class="xref py py-meth docutils literal"><span class="pre">sslLibraryVersionNumber</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryVersionString" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryVersionString"><code class="xref py py-meth docutils literal"><span class="pre">sslLibraryVersionString</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers"><code class="xref py py-meth docutils literal"><span class="pre">supportedCiphers</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportsSsl" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportsSsl"><code class="xref py py-meth docutils literal"><span class="pre">supportsSsl</span></code></a> ()</li>
<li>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.systemCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.systemCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">systemCaCertificates</span></code></a> ()</li>
</ul>
</div>
</div>
</div>
<div class="section" id="detailed-description">
<h2>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> class provides an SSL encrypted socket for both clients and servers.</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> establishes a secure, encrypted TCP connection you can use for transmitting encrypted data. It can operate in both client and server mode, and it supports modern SSL protocols, including SSL 3 and TLS 1.2. By default, <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> uses only SSL protocols which are considered to be secure ( <code class="xref py py-attr docutils literal"><span class="pre">QSsl.SecureProtocols</span></code> ), but you can change the SSL protocol by calling <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setProtocol" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setProtocol"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setProtocol()</span></code></a> as long as you do it before the handshake has started.</p>
<p>SSL encryption operates on top of the existing TCP stream after the socket enters the <code class="xref py py-attr docutils literal"><span class="pre">ConnectedState</span></code> . There are two simple ways to establish a secure connection using <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> : With an immediate SSL handshake, or with a delayed SSL handshake occurring after the connection has been established in unencrypted mode.</p>
<p>The most common way to use <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> is to construct an object and start a secure connection by calling <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.connectToHostEncrypted()</span></code></a> . This method starts an immediate SSL handshake once the connection has been established.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">socket</span> <span class="o">=</span> <span class="n">QSslSocket</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="n">QObject</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&quot;encrypted()&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="s2">&quot;ready()&quot;</span><span class="p">))</span>

<span class="n">socket</span><span class="o">.</span><span class="n">connectToHostEncrypted</span><span class="p">(</span><span class="s2">&quot;imap.example.com&quot;</span><span class="p">,</span> <span class="mi">993</span><span class="p">)</span>
</pre></div>
</div>
<p>As with a plain <a class="reference internal" href="QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QTcpSocket</span></code></a> , <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> enters the <code class="xref py py-attr docutils literal"><span class="pre">HostLookupState</span></code> , <code class="xref py py-attr docutils literal"><span class="pre">ConnectingState</span></code> , and finally the <code class="xref py py-attr docutils literal"><span class="pre">ConnectedState</span></code> , if the connection is successful. The handshake then starts automatically, and if it succeeds, the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.encrypted()</span></code></a> signal is emitted to indicate the socket has entered the encrypted state and is ready for use.</p>
<p>Note that data can be written to the socket immediately after the return from <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.connectToHostEncrypted()</span></code></a> (i.e., before the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.encrypted()</span></code></a> signal is emitted). The data is queued in <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> until after the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.encrypted()</span></code></a> signal is emitted.</p>
<p>An example of using the delayed SSL handshake to secure an existing connection is the case where an SSL server secures an incoming connection. Suppose you create an SSL server class as a subclass of <a class="reference internal" href="QTcpServer.html#PySide2.QtNetwork.QTcpServer" title="PySide2.QtNetwork.QTcpServer"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QTcpServer</span></code></a> . You would override <a class="reference internal" href="QTcpServer.html#PySide2.QtNetwork.PySide2.QtNetwork.QTcpServer.incomingConnection" title="PySide2.QtNetwork.PySide2.QtNetwork.QTcpServer.incomingConnection"><code class="xref py py-meth docutils literal"><span class="pre">QTcpServer.incomingConnection()</span></code></a> with something like the example below, which first constructs an instance of <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> and then calls <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setSocketDescriptor()</span></code> to set the new socket’s descriptor to the existing one passed in. It then initiates the SSL handshake by calling <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startServerEncryption" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startServerEncryption"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.startServerEncryption()</span></code></a> .</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">incomingConnection</span><span class="p">(</span><span class="n">socketDescriptor</span><span class="p">):</span>
    <span class="n">serverSocket</span> <span class="o">=</span> <span class="n">QSslSocket</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">serverSocket</span><span class="o">.</span><span class="n">setSocketDescriptor</span><span class="p">(</span><span class="n">socketDescriptor</span><span class="p">):</span>
        <span class="n">QObject</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">serverSocket</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&quot;encrypted()&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="s2">&quot;ready()&quot;</span><span class="p">))</span>
        <span class="n">serverSocket</span><span class="o">.</span><span class="n">startServerEncryption</span><span class="p">()</span>
</pre></div>
</div>
<p>If an error occurs, <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> emits the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.sslErrors()</span></code></a> signal. In this case, if no action is taken to ignore the error(s), the connection is dropped. To continue, despite the occurrence of an error, you can call <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ignoreSslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ignoreSslErrors"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.ignoreSslErrors()</span></code></a> , either from within this slot after the error occurs, or any time after construction of the <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> and before the connection is attempted. This will allow <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> to ignore the errors it encounters when establishing the identity of the peer. Ignoring errors during an SSL handshake should be used with caution, since a fundamental characteristic of secure connections is that they should be established with a successful handshake.</p>
<p>Once encrypted, you use <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> as a regular <a class="reference internal" href="QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QTcpSocket</span></code></a> . When <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QIODevice.readyRead()</span></code> is emitted, you can call <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QIODevice.read()</span></code> , <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.canReadLine()</span></code> and <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QIODevice.readLine()</span></code> , or <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QIODevice.getChar()</span></code> to read decrypted data from <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> ‘s internal buffer, and you can call <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QIODevice.write()</span></code> or <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QIODevice.putChar()</span></code> to write data back to the peer. <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> will automatically encrypt the written data for you, and emit <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encryptedBytesWritten" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encryptedBytesWritten"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.encryptedBytesWritten()</span></code></a> once the data has been written to the peer.</p>
<p>As a convenience, <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> supports <a class="reference internal" href="QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QTcpSocket</span></code></a> ‘s blocking functions <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.waitForConnected()</span></code> , <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.waitForReadyRead()</span></code> , <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.waitForBytesWritten()</span></code> , and <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.waitForDisconnected()</span></code> . It also provides <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.waitForEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.waitForEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.waitForEncrypted()</span></code></a> , which will block the calling thread until an encrypted connection has been established.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">socket</span> <span class="o">=</span> <span class="n">QSslSocket</span><span class="p">()</span>
<span class="n">socket</span><span class="o">.</span><span class="n">connectToHostEncrypted</span><span class="p">(</span><span class="s2">&quot;http.example.com&quot;</span><span class="p">,</span> <span class="mi">443</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">socket</span><span class="o">.</span><span class="n">waitForEncrypted</span><span class="p">():</span>
    <span class="nb">print</span> <span class="n">socket</span><span class="o">.</span><span class="n">errorString</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">false</span>

<span class="n">socket</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;GET / HTTP/1.0</span><span class="se">\r\n\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">while</span> <span class="n">socket</span><span class="o">.</span><span class="n">waitForReadyRead</span><span class="p">():</span>
    <span class="nb">print</span> <span class="n">socket</span><span class="o">.</span><span class="n">readAll</span><span class="p">()</span><span class="o">.</span><span class="n">data</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> provides an extensive, easy-to-use API for handling cryptographic ciphers, private keys, and local, peer, and Certification Authority (CA) certificates. It also provides an API for handling errors that occur during the handshake phase.</p>
<p>The following features can also be customized:</p>
<ul class="simple">
<li>The socket’s cryptographic cipher suite can be customized before the handshake phase with <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setCiphers()</span></code></a> and <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setDefaultCiphers()</span></code></a> .</li>
<li>The socket’s local certificate and private key can be customized before the handshake phase with <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setLocalCertificate()</span></code></a> and <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPrivateKey" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPrivateKey"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setPrivateKey()</span></code></a> .</li>
<li>The CA certificate database can be extended and customized with <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.addCaCertificate()</span></code></a> , <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.addCaCertificates()</span></code></a> , <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.addDefaultCaCertificate()</span></code></a> , <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.addDefaultCaCertificates()</span></code></a> , and <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.defaultConfiguration" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.defaultConfiguration"><code class="xref py py-meth docutils literal"><span class="pre">QSslConfiguration.defaultConfiguration()</span></code></a> . <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setCaCertificates()</span></code></a> .</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If available, root certificates on Unix (excluding <span class="xref std std-ref">macOS</span> ) will be loaded on demand from the standard certificate directories. If you do not want to load root certificates on demand, you need to call either <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.defaultConfiguration" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.defaultConfiguration"><code class="xref py py-meth docutils literal"><span class="pre">QSslConfiguration.defaultConfiguration()</span></code></a> . <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setCaCertificates()</span></code></a> before the first SSL handshake is made in your application (for example, via passing <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.systemCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.systemCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">QSslSocket.systemCaCertificates()</span></code></a> to it), or call <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.defaultConfiguration" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.defaultConfiguration"><code class="xref py py-meth docutils literal"><span class="pre">QSslConfiguration.defaultConfiguration()</span></code></a> ::setCaCertificates() on your <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> instance prior to the SSL handshake.</p>
</div>
<p>For more information about ciphers and certificates, refer to <a class="reference internal" href="QSslCipher.html#PySide2.QtNetwork.QSslCipher" title="PySide2.QtNetwork.QSslCipher"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslCipher</span></code></a> and <a class="reference internal" href="QSslCertificate.html#PySide2.QtNetwork.QSslCertificate" title="PySide2.QtNetwork.QSslCertificate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslCertificate</span></code></a> .</p>
<p>This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (<a class="reference external" href="http://www.openssl.org/">http://www.openssl.org/</a>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Be aware of the difference between the <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QIODevice.bytesWritten()</span></code> signal and the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encryptedBytesWritten" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encryptedBytesWritten"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.encryptedBytesWritten()</span></code></a> signal. For a <a class="reference internal" href="QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QTcpSocket</span></code></a> , <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QIODevice.bytesWritten()</span></code> will get emitted as soon as data has been written to the TCP socket. For a <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> , <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QIODevice.bytesWritten()</span></code> will get emitted when the data is being encrypted and <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encryptedBytesWritten" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encryptedBytesWritten"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.encryptedBytesWritten()</span></code></a> will get emitted as soon as data has been written to the TCP socket.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="QSslCertificate.html#PySide2.QtNetwork.QSslCertificate" title="PySide2.QtNetwork.QSslCertificate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslCertificate</span></code></a>  <a class="reference internal" href="QSslCipher.html#PySide2.QtNetwork.QSslCipher" title="PySide2.QtNetwork.QSslCipher"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslCipher</span></code></a>  <a class="reference internal" href="QSslError.html#PySide2.QtNetwork.QSslError" title="PySide2.QtNetwork.QSslError"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslError</span></code></a></p>
</div>
</div></blockquote>
<dl class="class">
<dt id="PySide2.QtNetwork.QSslSocket">
<em class="property">class </em><code class="descclassname">PySide2.QtNetwork.</code><code class="descname">QSslSocket</code><span class="sig-paren">(</span><span class="optional">[</span><em>parent=nullptr</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.QSslSocket" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>parent</strong> – <a class="reference internal" href="../QtCore/QObject.html#PySide2.QtCore.QObject" title="PySide2.QtCore.QObject"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QObject</span></code></a></td>
</tr>
</tbody>
</table>
<p>Constructs a <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> object. <code class="docutils literal"><span class="pre">parent</span></code> is passed to <a class="reference internal" href="../QtCore/QObject.html#PySide2.QtCore.QObject" title="PySide2.QtCore.QObject"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QObject</span></code></a> ‘s constructor. The new socket’s <a class="reference internal" href="QSslCipher.html#PySide2.QtNetwork.QSslCipher" title="PySide2.QtNetwork.QSslCipher"><code class="xref py py-class docutils literal"><span class="pre">cipher</span></code></a> suite is set to the one returned by the static method <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.defaultCiphers()</span></code></a> .</p>
</dd></dl>

<dl class="attribute">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.SslMode">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">SslMode</code><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.SslMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes the connection modes available for <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> .</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QSslSocket.UnencryptedMode</td>
<td>The socket is unencrypted. Its behavior is identical to <a class="reference internal" href="QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QTcpSocket</span></code></a> .</td>
</tr>
<tr class="row-odd"><td>QSslSocket.SslClientMode</td>
<td>The socket is a client-side SSL socket. It is either alreayd encrypted, or it is in the SSL handshake phase (see <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.isEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.isEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">QSslSocket.isEncrypted()</span></code></a> ).</td>
</tr>
<tr class="row-even"><td>QSslSocket.SslServerMode</td>
<td>The socket is a server-side SSL socket. It is either already encrypted, or it is in the SSL handshake phase (see <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.isEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.isEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">QSslSocket.isEncrypted()</span></code></a> ).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.PeerVerifyMode">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">PeerVerifyMode</code><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.PeerVerifyMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes the peer verification modes for <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> . The default mode is , which selects an appropriate mode depending on the socket’s QSocket::SslMode.</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QSslSocket.VerifyNone</td>
<td><a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> will not request a certificate from the peer. You can set this mode if you are not interested in the identity of the other side of the connection. The connection will still be encrypted, and your socket will still send its local certificate to the peer if it’s requested.</td>
</tr>
<tr class="row-odd"><td>QSslSocket.QueryPeer</td>
<td><a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> will request a certificate from the peer, but does not require this certificate to be valid. This is useful when you want to display peer certificate details to the user without affecting the actual SSL handshake. This mode is the default for servers.</td>
</tr>
<tr class="row-even"><td>QSslSocket.VerifyPeer</td>
<td><a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> will request a certificate from the peer during the SSL handshake phase, and requires that this certificate is valid. On failure, <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> will emit the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors"><code class="xref py py-meth docutils literal"><span class="pre">QSslSocket.sslErrors()</span></code></a> signal. This mode is the default for clients.</td>
</tr>
<tr class="row-odd"><td>QSslSocket.AutoVerifyPeer</td>
<td><a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> will automatically use for server sockets and for client sockets.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyMode" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyMode"><code class="xref py py-meth docutils literal"><span class="pre">QSslSocket.peerVerifyMode()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificate">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">addCaCertificate</code><span class="sig-paren">(</span><em>certificate</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>certificate</strong> – <a class="reference internal" href="QSslCertificate.html#PySide2.QtNetwork.QSslCertificate" title="PySide2.QtNetwork.QSslCertificate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslCertificate</span></code></a></td>
</tr>
</tbody>
</table>
<p>Adds the <code class="docutils literal"><span class="pre">certificate</span></code> to this socket’s CA certificate database. The CA certificate database is used by the socket during the handshake phase to validate the peer’s certificate.</p>
<p>To add multiple certificates, use <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.addCaCertificates()</span></code></a> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.caCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.caCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.caCertificates()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setCaCertificates()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">addCaCertificates</code><span class="sig-paren">(</span><em>path</em><span class="optional">[</span>, <em>format=QSsl.Pem</em><span class="optional">[</span>, <em>syntax=QRegExp.FixedString</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> – unicode</li>
<li><strong>format</strong> – <a class="reference internal" href="QSsl.html#PySide2.QtNetwork.PySide2.QtNetwork.QSsl.EncodingFormat" title="PySide2.QtNetwork.PySide2.QtNetwork.QSsl.EncodingFormat"><code class="xref py py-attr docutils literal"><span class="pre">PySide2.QtNetwork.QSsl.EncodingFormat</span></code></a></li>
<li><strong>syntax</strong> – <code class="xref py py-attr docutils literal"><span class="pre">PySide2.QtCore.QRegExp.PatternSyntax</span></code></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.bool</span></code></p>
</td>
</tr>
</tbody>
</table>
<p>Searches all files in the <code class="docutils literal"><span class="pre">path</span></code> for certificates encoded in the specified <code class="docutils literal"><span class="pre">format</span></code> and adds them to this socket’s CA certificate database. <code class="docutils literal"><span class="pre">path</span></code> must be a file or a pattern matching one or more files, as specified by <code class="docutils literal"><span class="pre">syntax</span></code> . Returns <code class="docutils literal"><span class="pre">true</span></code> if one or more certificates are added to the socket’s CA certificate database; otherwise returns <code class="docutils literal"><span class="pre">false</span></code> .</p>
<p>The CA certificate database is used by the socket during the handshake phase to validate the peer’s certificate.</p>
<p>For more precise control, use <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.addCaCertificate()</span></code></a> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.addCaCertificate()</span></code></a>  <a class="reference internal" href="QSslCertificate.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslCertificate.fromPath" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslCertificate.fromPath"><code class="xref py py-meth docutils literal"><span class="pre">QSslCertificate.fromPath()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">addCaCertificates</code><span class="sig-paren">(</span><em>certificates</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>certificates</strong> – </td>
</tr>
</tbody>
</table>
<p>Adds the <code class="docutils literal"><span class="pre">certificates</span></code> to this socket’s CA certificate database. The CA certificate database is used by the socket during the handshake phase to validate the peer’s certificate.</p>
<p>For more precise control, use <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.addCaCertificate()</span></code></a> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.caCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.caCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.caCertificates()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.addDefaultCaCertificate()</span></code></a></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificate">
<em class="property">static </em><code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">addDefaultCaCertificate</code><span class="sig-paren">(</span><em>certificate</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>certificate</strong> – <a class="reference internal" href="QSslCertificate.html#PySide2.QtNetwork.QSslCertificate" title="PySide2.QtNetwork.QSslCertificate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslCertificate</span></code></a></td>
</tr>
</tbody>
</table>
<p>Adds <code class="docutils literal"><span class="pre">certificate</span></code> to the default CA certificate database. Each SSL socket’s CA certificate database is initialized to the default CA certificate database.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.defaultCaCertificates()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.addCaCertificates()</span></code></a></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificates">
<em class="property">static </em><code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">addDefaultCaCertificates</code><span class="sig-paren">(</span><em>path</em><span class="optional">[</span>, <em>format=QSsl.Pem</em><span class="optional">[</span>, <em>syntax=QRegExp.FixedString</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificates" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> – unicode</li>
<li><strong>format</strong> – <a class="reference internal" href="QSsl.html#PySide2.QtNetwork.PySide2.QtNetwork.QSsl.EncodingFormat" title="PySide2.QtNetwork.PySide2.QtNetwork.QSsl.EncodingFormat"><code class="xref py py-attr docutils literal"><span class="pre">PySide2.QtNetwork.QSsl.EncodingFormat</span></code></a></li>
<li><strong>syntax</strong> – <code class="xref py py-attr docutils literal"><span class="pre">PySide2.QtCore.QRegExp.PatternSyntax</span></code></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.bool</span></code></p>
</td>
</tr>
</tbody>
</table>
<p>Searches all files in the <code class="docutils literal"><span class="pre">path</span></code> for certificates with the specified <code class="docutils literal"><span class="pre">encoding</span></code> and adds them to the default CA certificate database. <code class="docutils literal"><span class="pre">path</span></code> can be an explicit file, or it can contain wildcards in the format specified by <code class="docutils literal"><span class="pre">syntax</span></code> . Returns <code class="docutils literal"><span class="pre">true</span></code> if any CA certificates are added to the default database.</p>
<p>Each SSL socket’s CA certificate database is initialized to the default CA certificate database.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.defaultCaCertificates()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.addCaCertificates()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.addDefaultCaCertificate()</span></code></a></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt>
<em class="property">static </em><code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">addDefaultCaCertificates</code><span class="sig-paren">(</span><em>certificates</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>certificates</strong> – </td>
</tr>
</tbody>
</table>
<p>Adds <code class="docutils literal"><span class="pre">certificates</span></code> to the default CA certificate database. Each SSL socket’s CA certificate database is initialized to the default CA certificate database.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.defaultCaCertificates()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.addCaCertificates()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.caCertificates">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">caCertificates</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.caCertificates" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Use <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.caCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.caCertificates"><code class="xref py py-meth docutils literal"><span class="pre">QSslConfiguration.caCertificates()</span></code></a> instead.</p>
<p>Returns this socket’s CA certificate database. The CA certificate database is used by the socket during the handshake phase to validate the peer’s certificate. It can be moodified prior to the handshake with <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.addCaCertificate()</span></code></a> , <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.addCaCertificates()</span></code></a> , and <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setCaCertificates()</span></code></a> .</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On Unix, this method may return an empty list if the root certificates are loaded on demand.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.addCaCertificate()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.addCaCertificates()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setCaCertificates()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ciphers">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">ciphers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ciphers" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Use <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.ciphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.ciphers"><code class="xref py py-meth docutils literal"><span class="pre">QSslConfiguration.ciphers()</span></code></a> instead.</p>
<p>Returns this socket’s current cryptographic cipher suite. This list is used during the socket’s handshake phase for choosing a session cipher. The returned list of ciphers is ordered by descending preference. (i.e., the first cipher in the list is the most preferred cipher). The session cipher will be the first one in the list that is also supported by the peer.</p>
<p>By default, the handshake phase can choose any of the ciphers supported by this system’s SSL libraries, which may vary from system to system. The list of ciphers supported by this system’s SSL libraries is returned by <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.supportedCiphers()</span></code></a> . You can restrict the list of ciphers used for choosing the session cipher for this socket by calling <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setCiphers()</span></code></a> with a subset of the supported ciphers. You can revert to using the entire set by calling <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setCiphers()</span></code></a> with the list returned by <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.supportedCiphers()</span></code></a> .</p>
<p>You can restrict the list of ciphers used for choosing the session cipher for <em>all</em> sockets by calling <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setDefaultCiphers()</span></code></a> with a subset of the supported ciphers. You can revert to using the entire set by calling <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setCiphers()</span></code></a> with the list returned by <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.supportedCiphers()</span></code></a> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setCiphers()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.defaultCiphers()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setDefaultCiphers()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.supportedCiphers()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">connectToHostEncrypted</code><span class="sig-paren">(</span><em>hostName</em>, <em>port</em>, <em>sslPeerName</em><span class="optional">[</span>, <em>mode=QIODevice.ReadWrite</em><span class="optional">[</span>, <em>protocol=AnyIPProtocol</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hostName</strong> – unicode</li>
<li><strong>port</strong> – <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.quint16</span></code></li>
<li><strong>sslPeerName</strong> – unicode</li>
<li><strong>mode</strong> – <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QIODevice.OpenMode</span></code></li>
<li><strong>protocol</strong> – <a class="reference internal" href="QAbstractSocket.html#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.NetworkLayerProtocol" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.NetworkLayerProtocol"><code class="xref py py-attr docutils literal"><span class="pre">PySide2.QtNetwork.QAbstractSocket.NetworkLayerProtocol</span></code></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>In addition to the original behaviour of <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.connectToHostEncrypted()</span></code></a> , this overloaded method enables the usage of a different hostname (<code class="docutils literal"><span class="pre">sslPeerName</span></code> ) for the certificate validation instead of the one used for the TCP connection (<code class="docutils literal"><span class="pre">hostName</span></code> ).</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.connectToHostEncrypted()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">connectToHostEncrypted</code><span class="sig-paren">(</span><em>hostName</em>, <em>port</em><span class="optional">[</span>, <em>mode=QIODevice.ReadWrite</em><span class="optional">[</span>, <em>protocol=AnyIPProtocol</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hostName</strong> – unicode</li>
<li><strong>port</strong> – <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.quint16</span></code></li>
<li><strong>mode</strong> – <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QIODevice.OpenMode</span></code></li>
<li><strong>protocol</strong> – <a class="reference internal" href="QAbstractSocket.html#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.NetworkLayerProtocol" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.NetworkLayerProtocol"><code class="xref py py-attr docutils literal"><span class="pre">PySide2.QtNetwork.QAbstractSocket.NetworkLayerProtocol</span></code></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Starts an encrypted connection to the device <code class="docutils literal"><span class="pre">hostName</span></code> on <code class="docutils literal"><span class="pre">port</span></code> , using <code class="docutils literal"><span class="pre">mode</span></code> as the <code class="xref py py-class docutils literal"><span class="pre">OpenMode</span></code> . This is equivalent to calling <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.connectToHost()</span></code> to establish the connection, followed by a call to <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startClientEncryption" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startClientEncryption"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.startClientEncryption()</span></code></a> . The <code class="docutils literal"><span class="pre">protocol</span></code> parameter can be used to specify which network protocol to use (eg. IPv4 or IPv6).</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> first enters the <code class="xref py py-attr docutils literal"><span class="pre">HostLookupState</span></code> . Then, after entering either the event loop or one of the waitFor…() functions, it enters the <code class="xref py py-attr docutils literal"><span class="pre">ConnectingState</span></code> , emits <a class="reference internal" href="QAbstractSocket.html#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connected" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connected"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QAbstractSocket.connected()</span></code></a> , and then initiates the SSL client handshake. At each state change, <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> emits signal <a class="reference internal" href="QAbstractSocket.html#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.stateChanged" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.stateChanged"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QAbstractSocket.stateChanged()</span></code></a> .</p>
<p>After initiating the SSL client handshake, if the identity of the peer can’t be established, signal <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.sslErrors()</span></code></a> is emitted. If you want to ignore the errors and continue connecting, you must call <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ignoreSslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ignoreSslErrors"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.ignoreSslErrors()</span></code></a> , either from inside a slot function connected to the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.sslErrors()</span></code></a> signal, or prior to entering encrypted mode. If <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ignoreSslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ignoreSslErrors"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.ignoreSslErrors()</span></code></a> is not called, the connection is dropped, signal <a class="reference internal" href="QAbstractSocket.html#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnected" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnected"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QAbstractSocket.disconnected()</span></code></a> is emitted, and <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> returns to the <code class="xref py py-attr docutils literal"><span class="pre">UnconnectedState</span></code> .</p>
<p>If the SSL handshake is successful, <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> emits <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.encrypted()</span></code></a> .</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">socket</span> <span class="o">=</span> <span class="n">QSslSocket</span><span class="p">()</span>
<span class="n">QObject</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&quot;encrypted()&quot;</span><span class="p">),</span> <span class="n">receiver</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="s2">&quot;socketEncrypted()&quot;</span><span class="p">))</span>

<span class="n">socket</span><span class="o">.</span><span class="n">connectToHostEncrypted</span><span class="p">(</span><span class="s2">&quot;imap&quot;</span><span class="p">,</span> <span class="mi">993</span><span class="p">)</span>
<span class="n">socket</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;1 CAPABILITY</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The example above shows that text can be written to the socket immediately after requesting the encrypted connection, before the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.encrypted()</span></code></a> signal has been emitted. In such cases, the text is queued in the object and written to the socket <em>after</em> the connection is established and the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.encrypted()</span></code></a> signal has been emitted.</p>
</div>
<p>The default for <code class="docutils literal"><span class="pre">mode</span></code> is <code class="xref py py-attr docutils literal"><span class="pre">ReadWrite</span></code> .</p>
<p>If you want to create a <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> on the server side of a connection, you should instead call <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startServerEncryption" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startServerEncryption"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.startServerEncryption()</span></code></a> upon receiving the incoming connection through <a class="reference internal" href="QTcpServer.html#PySide2.QtNetwork.QTcpServer" title="PySide2.QtNetwork.QTcpServer"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QTcpServer</span></code></a> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.connectToHost()</span></code>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startClientEncryption" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startClientEncryption"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.startClientEncryption()</span></code></a>  <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.waitForConnected()</span></code>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.waitForEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.waitForEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.waitForEncrypted()</span></code></a></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates">
<em class="property">static </em><code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">defaultCaCertificates</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Use <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.caCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.caCertificates"><code class="xref py py-meth docutils literal"><span class="pre">QSslConfiguration.caCertificates()</span></code></a> on the default <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.QSslConfiguration" title="PySide2.QtNetwork.QSslConfiguration"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslConfiguration</span></code></a> instead.</p>
<p>Returns the current default CA certificate database. This database is originally set to your system’s default CA certificate database. If no system default database is found, an empty database will be returned. You can override the default CA certificate database with your own CA certificate database using <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setDefaultCaCertificates()</span></code></a> .</p>
<p>Each SSL socket’s CA certificate database is initialized to the default CA certificate database.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On Unix, this method may return an empty list if the root certificates are loaded on demand.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setDefaultCaCertificates()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.caCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.caCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.caCertificates()</span></code></a></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCiphers">
<em class="property">static </em><code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">defaultCiphers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCiphers" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Use <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.ciphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.ciphers"><code class="xref py py-meth docutils literal"><span class="pre">QSslConfiguration.ciphers()</span></code></a> on the default <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.QSslConfiguration" title="PySide2.QtNetwork.QSslConfiguration"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslConfiguration</span></code></a> instead.</p>
<p>Returns the default cryptographic cipher suite for all sockets in this application. This list is used during the socket’s handshake phase when negotiating with the peer to choose a session cipher. The list is ordered by preference (i.e., the first cipher in the list is the most preferred cipher).</p>
<p>By default, the handshake phase can choose any of the ciphers supported by this system’s SSL libraries, which may vary from system to system. The list of ciphers supported by this system’s SSL libraries is returned by <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.supportedCiphers()</span></code></a> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setDefaultCiphers()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.supportedCiphers()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">encrypted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encryptedBytesAvailable">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">encryptedBytesAvailable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encryptedBytesAvailable" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.qint64</span></code></td>
</tr>
</tbody>
</table>
<p>Returns the number of encrypted bytes that are awaiting decryption. Normally, this function will return 0 because <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> decrypts its incoming data as soon as it can.</p>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encryptedBytesToWrite">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">encryptedBytesToWrite</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encryptedBytesToWrite" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.qint64</span></code></td>
</tr>
</tbody>
</table>
<p>Returns the number of encrypted bytes that are waiting to be written to the network.</p>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encryptedBytesWritten">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">encryptedBytesWritten</code><span class="sig-paren">(</span><em>totalBytes</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encryptedBytesWritten" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>totalBytes</strong> – <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.qint64</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ignoreSslErrors">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">ignoreSslErrors</code><span class="sig-paren">(</span><em>errors</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ignoreSslErrors" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>errors</strong> – </td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>This method tells <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> to ignore only the errors given in <code class="docutils literal"><span class="pre">errors</span></code> .</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Because most SSL errors are associated with a certificate, for most of them you must set the expected certificate this SSL error is related to. If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QList</span><span class="o">&lt;</span><span class="n">QSslCertificate</span><span class="o">&gt;</span> <span class="n">cert</span> <span class="o">=</span> <span class="n">QSslCertificate</span><span class="p">::</span><span class="n">fromPath</span><span class="p">(</span><span class="n">QLatin1String</span><span class="p">(</span><span class="s2">&quot;server-certificate.pem&quot;</span><span class="p">));</span>
<span class="n">QSslError</span> <span class="n">error</span><span class="p">(</span><span class="n">QSslError</span><span class="p">::</span><span class="n">SelfSignedCertificate</span><span class="p">,</span> <span class="n">cert</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">QList</span><span class="o">&lt;</span><span class="n">QSslError</span><span class="o">&gt;</span> <span class="n">expectedSslErrors</span><span class="p">;</span>
<span class="n">expectedSslErrors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

<span class="n">QSslSocket</span> <span class="n">socket</span><span class="p">;</span>
<span class="n">socket</span><span class="o">.</span><span class="n">ignoreSslErrors</span><span class="p">(</span><span class="n">expectedSslErrors</span><span class="p">);</span>
<span class="n">socket</span><span class="o">.</span><span class="n">connectToHostEncrypted</span><span class="p">(</span><span class="s2">&quot;server.tld&quot;</span><span class="p">,</span> <span class="mi">443</span><span class="p">);</span>
</pre></div>
</div>
<p>Multiple calls to this function will replace the list of errors that were passed in previous calls. You can clear the list of errors you want to ignore by calling this function with an empty list.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.sslErrors()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">ignoreSslErrors</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>This slot tells <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> to ignore errors during <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> ‘s handshake phase and continue connecting. If you want to continue with the connection even if errors occur during the handshake phase, then you must call this slot, either from a slot connected to <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.sslErrors()</span></code></a> , or before the handshake phase. If you don’t call this slot, either in response to errors or before the handshake, the connection will be dropped after the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.sslErrors()</span></code></a> signal has been emitted.</p>
<p>If there are no errors during the SSL handshake phase (i.e., the identity of the peer is established with no problems), <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> will not emit the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.sslErrors()</span></code></a> signal, and it is unnecessary to call this function.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Be sure to always let the user inspect the errors reported by the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.sslErrors()</span></code></a> signal, and only call this method upon confirmation from the user that proceeding is ok. If there are unexpected errors, the connection should be aborted. Calling this method without inspecting the actual errors will most likely pose a security risk for your application. Use it with great care!</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.sslErrors()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.isEncrypted">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">isEncrypted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.isEncrypted" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.bool</span></code></td>
</tr>
</tbody>
</table>
<p>Returns <code class="docutils literal"><span class="pre">true</span></code> if the socket is encrypted; otherwise, false is returned.</p>
<p>An encrypted socket encrypts all data that is written by calling <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QIODevice.write()</span></code> or <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QIODevice.putChar()</span></code> before the data is written to the network, and decrypts all incoming data as the data is received from the network, before you call <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QIODevice.read()</span></code> , <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QIODevice.readLine()</span></code> or <code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtCore.QIODevice.getChar()</span></code> .</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> emits <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.encrypted()</span></code></a> when it enters encrypted mode.</p>
<p>You can call <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sessionCipher" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sessionCipher"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.sessionCipher()</span></code></a> to find which cryptographic cipher is used to encrypt and decrypt your data.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.mode" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.mode"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.mode()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.localCertificate">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">localCertificate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.localCertificate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QSslCertificate.html#PySide2.QtNetwork.QSslCertificate" title="PySide2.QtNetwork.QSslCertificate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslCertificate</span></code></a></td>
</tr>
</tbody>
</table>
<p>Returns the socket’s local <a class="reference internal" href="QSslCertificate.html#PySide2.QtNetwork.QSslCertificate" title="PySide2.QtNetwork.QSslCertificate"><code class="xref py py-class docutils literal"><span class="pre">certificate</span></code></a> , or an empty certificate if no local certificate has been assigned.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setLocalCertificate()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.privateKey" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.privateKey"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.privateKey()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.localCertificateChain">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">localCertificateChain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.localCertificateChain" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Returns the socket’s local <a class="reference internal" href="QSslCertificate.html#PySide2.QtNetwork.QSslCertificate" title="PySide2.QtNetwork.QSslCertificate"><code class="xref py py-class docutils literal"><span class="pre">certificate</span></code></a> chain, or an empty list if no local certificates have been assigned.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificateChain" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificateChain"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setLocalCertificateChain()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.mode">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">mode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.mode" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.SslMode" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.SslMode"><code class="xref py py-attr docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.SslMode</span></code></a></td>
</tr>
</tbody>
</table>
<p>Returns the current mode for the socket; either <code class="xref py py-attr docutils literal"><span class="pre">UnencryptedMode</span></code> , where <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> behaves identially to <a class="reference internal" href="QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QTcpSocket</span></code></a> , or one of <code class="xref py py-attr docutils literal"><span class="pre">SslClientMode</span></code> or <code class="xref py py-attr docutils literal"><span class="pre">SslServerMode</span></code> , where the client is either negotiating or in encrypted mode.</p>
<p>When the mode changes, <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> emits <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.modeChanged" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.modeChanged"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.modeChanged()</span></code></a></p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-attr docutils literal"><span class="pre">QSslSocket.SslMode</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.modeChanged">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">modeChanged</code><span class="sig-paren">(</span><em>newMode</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.modeChanged" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>newMode</strong> – <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.SslMode" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.SslMode"><code class="xref py py-attr docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.SslMode</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificate">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">peerCertificate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QSslCertificate.html#PySide2.QtNetwork.QSslCertificate" title="PySide2.QtNetwork.QSslCertificate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslCertificate</span></code></a></td>
</tr>
</tbody>
</table>
<p>Returns the peer’s digital certificate (i.e., the immediate certificate of the host you are connected to), or a null certificate, if the peer has not assigned a certificate.</p>
<p>The peer certificate is checked automatically during the handshake phase, so this function is normally used to fetch the certificate for display or for connection diagnostic purposes. It contains information about the peer, including its host name, the certificate issuer, and the peer’s public key.</p>
<p>Because the peer certificate is set during the handshake phase, it is safe to access the peer certificate from a slot connected to the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.sslErrors()</span></code></a> signal or the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.encrypted()</span></code></a> signal.</p>
<p>If a null certificate is returned, it can mean the SSL handshake failed, or it can mean the host you are connected to doesn’t have a certificate, or it can mean there is no connection.</p>
<p>If you want to check the peer’s complete chain of certificates, use <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificateChain" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificateChain"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.peerCertificateChain()</span></code></a> to get them all at once.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificateChain" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificateChain"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.peerCertificateChain()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificateChain">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">peerCertificateChain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificateChain" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Returns the peer’s chain of digital certificates, or an empty list of certificates.</p>
<p>Peer certificates are checked automatically during the handshake phase. This function is normally used to fetch certificates for display, or for performing connection diagnostics. Certificates contain information about the peer and the certificate issuers, including host name, issuer names, and issuer public keys.</p>
<p>The peer certificates are set in <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> during the handshake phase, so it is safe to call this function from a slot connected to the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.sslErrors()</span></code></a> signal or the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.encrypted()</span></code></a> signal.</p>
<p>If an empty list is returned, it can mean the SSL handshake failed, or it can mean the host you are connected to doesn’t have a certificate, or it can mean there is no connection.</p>
<p>If you want to get only the peer’s immediate certificate, use <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.peerCertificate()</span></code></a> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.peerCertificate()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyDepth">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">peerVerifyDepth</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyDepth" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.int</span></code></td>
</tr>
</tbody>
</table>
<p>Returns the maximum number of certificates in the peer’s certificate chain to be checked during the SSL handshake phase, or 0 (the default) if no maximum depth has been set, indicating that the whole certificate chain should be checked.</p>
<p>The certificates are checked in issuing order, starting with the peer’s own certificate, then its issuer’s certificate, and so on.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyDepth" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyDepth"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setPeerVerifyDepth()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyMode" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyMode"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.peerVerifyMode()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyError">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">peerVerifyError</code><span class="sig-paren">(</span><em>error</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyError" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>error</strong> – <a class="reference internal" href="QSslError.html#PySide2.QtNetwork.QSslError" title="PySide2.QtNetwork.QSslError"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslError</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyMode">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">peerVerifyMode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyMode" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.PeerVerifyMode" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.PeerVerifyMode"><code class="xref py py-attr docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.PeerVerifyMode</span></code></a></td>
</tr>
</tbody>
</table>
<p>Returns the socket’s verify mode. This mode decides whether <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> should request a certificate from the peer (i.e., the client requests a certificate from the server, or a server requesting a certificate from the client), and whether it should require that this certificate is valid.</p>
<p>The default mode is <code class="xref py py-attr docutils literal"><span class="pre">AutoVerifyPeer</span></code> , which tells <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> to use <code class="xref py py-attr docutils literal"><span class="pre">VerifyPeer</span></code> for clients and <code class="xref py py-attr docutils literal"><span class="pre">QueryPeer</span></code> for servers.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyMode" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyMode"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setPeerVerifyMode()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyDepth" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyDepth"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.peerVerifyDepth()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.mode" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.mode"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.mode()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyName">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">peerVerifyName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyName" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">unicode</td>
</tr>
</tbody>
</table>
<p>Returns the different hostname for the certificate validation, as set by <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyName" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyName"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setPeerVerifyName()</span></code></a> or by <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.connectToHostEncrypted()</span></code></a> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyName" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyName"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setPeerVerifyName()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.connectToHostEncrypted()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.preSharedKeyAuthenticationRequired">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">preSharedKeyAuthenticationRequired</code><span class="sig-paren">(</span><em>authenticator</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.preSharedKeyAuthenticationRequired" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>authenticator</strong> – <a class="reference internal" href="QSslPreSharedKeyAuthenticator.html#PySide2.QtNetwork.QSslPreSharedKeyAuthenticator" title="PySide2.QtNetwork.QSslPreSharedKeyAuthenticator"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslPreSharedKeyAuthenticator</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.privateKey">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">privateKey</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.privateKey" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QSslKey.html#PySide2.QtNetwork.QSslKey" title="PySide2.QtNetwork.QSslKey"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslKey</span></code></a></td>
</tr>
</tbody>
</table>
<p>Returns this socket’s private key.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPrivateKey" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPrivateKey"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setPrivateKey()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.localCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.localCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.localCertificate()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.protocol">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">protocol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.protocol" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QSsl.html#PySide2.QtNetwork.PySide2.QtNetwork.QSsl.SslProtocol" title="PySide2.QtNetwork.PySide2.QtNetwork.QSsl.SslProtocol"><code class="xref py py-attr docutils literal"><span class="pre">PySide2.QtNetwork.QSsl.SslProtocol</span></code></a></td>
</tr>
</tbody>
</table>
<p>Returns the socket’s SSL protocol. By default, <code class="xref py py-attr docutils literal"><span class="pre">QSsl.SecureProtocols</span></code> is used.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setProtocol" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setProtocol"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setProtocol()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sessionCipher">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">sessionCipher</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sessionCipher" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QSslCipher.html#PySide2.QtNetwork.QSslCipher" title="PySide2.QtNetwork.QSslCipher"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslCipher</span></code></a></td>
</tr>
</tbody>
</table>
<p>Returns the socket’s cryptographic <a class="reference internal" href="QSslCipher.html#PySide2.QtNetwork.QSslCipher" title="PySide2.QtNetwork.QSslCipher"><code class="xref py py-class docutils literal"><span class="pre">cipher</span></code></a> , or a null cipher if the connection isn’t encrypted. The socket’s cipher for the session is set during the handshake phase. The cipher is used to encrypt and decrypt data transmitted through the socket.</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> also provides functions for setting the ordered list of ciphers from which the handshake phase will eventually select the session cipher. This ordered list must be in place before the handshake phase begins.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ciphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ciphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.ciphers()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setCiphers()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setDefaultCiphers()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.defaultCiphers()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.supportedCiphers()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sessionProtocol">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">sessionProtocol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sessionProtocol" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QSsl.html#PySide2.QtNetwork.PySide2.QtNetwork.QSsl.SslProtocol" title="PySide2.QtNetwork.PySide2.QtNetwork.QSsl.SslProtocol"><code class="xref py py-attr docutils literal"><span class="pre">PySide2.QtNetwork.QSsl.SslProtocol</span></code></a></td>
</tr>
</tbody>
</table>
<p>Returns the socket’s SSL/TLS protocol or UnknownProtocol if the connection isn’t encrypted. The socket’s protocol for the session is set during the handshake phase.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.protocol" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.protocol"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.protocol()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setProtocol" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setProtocol"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setProtocol()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCaCertificates">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">setCaCertificates</code><span class="sig-paren">(</span><em>certificates</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCaCertificates" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>certificates</strong> – </td>
</tr>
</tbody>
</table>
<p>Use <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.setCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.setCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">QSslConfiguration.setCaCertificates()</span></code></a> instead.</p>
<p>Sets this socket’s CA certificate database to be <code class="docutils literal"><span class="pre">certificates</span></code> . The certificate database must be set prior to the SSL handshake. The CA certificate database is used by the socket during the handshake phase to validate the peer’s certificate.</p>
<p>The CA certificate database can be reset to the current default CA certificate database by calling this function with the list of CA certificates returned by <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.defaultCaCertificates()</span></code></a> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.caCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.caCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.caCertificates()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.defaultCaCertificates()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">setCiphers</code><span class="sig-paren">(</span><em>ciphers</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ciphers</strong> – unicode</td>
</tr>
</tbody>
</table>
<p>Use <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.setCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.setCiphers"><code class="xref py py-meth docutils literal"><span class="pre">QSslConfiguration.setCiphers()</span></code></a> instead.</p>
<p>Sets the cryptographic cipher suite for this socket to <code class="docutils literal"><span class="pre">ciphers</span></code> , which is a colon-separated list of cipher suite names. The ciphers are listed in order of preference, starting with the most preferred cipher. For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">socket</span> <span class="o">=</span> <span class="n">QSslSocket</span><span class="p">()</span>
<span class="n">socket</span><span class="o">.</span><span class="n">setCiphers</span><span class="p">(</span><span class="s2">&quot;DHE-RSA-AES256-SHA:DHE-DSS-AES256-SHA:AES256-SHA&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Each cipher name in <code class="docutils literal"><span class="pre">ciphers</span></code> must be the name of a cipher in the list returned by <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.supportedCiphers()</span></code></a> . Restricting the cipher suite must be done before the handshake phase, where the session cipher is chosen.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ciphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ciphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.ciphers()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setDefaultCiphers()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.supportedCiphers()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">setCiphers</code><span class="sig-paren">(</span><em>ciphers</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ciphers</strong> – </td>
</tr>
</tbody>
</table>
<p>USe <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.setCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.setCiphers"><code class="xref py py-meth docutils literal"><span class="pre">QSslConfiguration.setCiphers()</span></code></a> instead.</p>
<p>Sets the cryptographic cipher suite for this socket to <code class="docutils literal"><span class="pre">ciphers</span></code> , which must contain a subset of the ciphers in the list returned by <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.supportedCiphers()</span></code></a> .</p>
<p>Restricting the cipher suite must be done before the handshake phase, where the session cipher is chosen.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ciphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ciphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.ciphers()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setDefaultCiphers()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.supportedCiphers()</span></code></a></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCaCertificates">
<em class="property">static </em><code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">setDefaultCaCertificates</code><span class="sig-paren">(</span><em>certificates</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCaCertificates" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>certificates</strong> – </td>
</tr>
</tbody>
</table>
<p>Use <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.setCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.setCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">QSslConfiguration.setCaCertificates()</span></code></a> on the default <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.QSslConfiguration" title="PySide2.QtNetwork.QSslConfiguration"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslConfiguration</span></code></a> instead.</p>
<p>Sets the default CA certificate database to <code class="docutils literal"><span class="pre">certificates</span></code> . The default CA certificate database is originally set to your system’s default CA certificate database. You can override the default CA certificate database with your own CA certificate database using this function.</p>
<p>Each SSL socket’s CA certificate database is initialized to the default CA certificate database.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.defaultCaCertificates()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.addDefaultCaCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.addDefaultCaCertificate()</span></code></a></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCiphers">
<em class="property">static </em><code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">setDefaultCiphers</code><span class="sig-paren">(</span><em>ciphers</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCiphers" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ciphers</strong> – </td>
</tr>
</tbody>
</table>
<p>Use <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.setCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.setCiphers"><code class="xref py py-meth docutils literal"><span class="pre">QSslConfiguration.setCiphers()</span></code></a> on the default <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.QSslConfiguration" title="PySide2.QtNetwork.QSslConfiguration"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslConfiguration</span></code></a> instead.</p>
<p>Sets the default cryptographic cipher suite for all sockets in this application to <code class="docutils literal"><span class="pre">ciphers</span></code> , which must contain a subset of the ciphers in the list returned by <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.supportedCiphers()</span></code></a> .</p>
<p>Restricting the default cipher suite only affects SSL sockets that perform their handshake phase after the default cipher suite has been changed.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setCiphers()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.defaultCiphers()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.supportedCiphers()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificate">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">setLocalCertificate</code><span class="sig-paren">(</span><em>certificate</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>certificate</strong> – <a class="reference internal" href="QSslCertificate.html#PySide2.QtNetwork.QSslCertificate" title="PySide2.QtNetwork.QSslCertificate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslCertificate</span></code></a></td>
</tr>
</tbody>
</table>
<p>Sets the socket’s local certificate to <code class="docutils literal"><span class="pre">certificate</span></code> . The local certificate is necessary if you need to confirm your identity to the peer. It is used together with the private key; if you set the local certificate, you must also set the private key.</p>
<p>The local certificate and private key are always necessary for server sockets, but are also rarely used by client sockets if the server requires the client to authenticate.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Secure Transport SSL backend on <span class="xref std std-ref">macOS</span> may update the default keychain (the default is probably your login keychain) by importing your local certificates and keys. This can also result in system dialogs showing up and asking for permission when your application is using these private keys. If such behavior is undesired, set the QT_SSL_USE_TEMPORARY_KEYCHAIN environment variable to a non-zero value; this will prompt <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> to use its own temporary keychain.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.localCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.localCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.localCertificate()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPrivateKey" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPrivateKey"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setPrivateKey()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">setLocalCertificate</code><span class="sig-paren">(</span><em>fileName</em><span class="optional">[</span>, <em>format=QSsl.Pem</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fileName</strong> – unicode</li>
<li><strong>format</strong> – <a class="reference internal" href="QSsl.html#PySide2.QtNetwork.PySide2.QtNetwork.QSsl.EncodingFormat" title="PySide2.QtNetwork.PySide2.QtNetwork.QSsl.EncodingFormat"><code class="xref py py-attr docutils literal"><span class="pre">PySide2.QtNetwork.QSsl.EncodingFormat</span></code></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Sets the socket’s local <a class="reference internal" href="QSslCertificate.html#PySide2.QtNetwork.QSslCertificate" title="PySide2.QtNetwork.QSslCertificate"><code class="xref py py-class docutils literal"><span class="pre">certificate</span></code></a> to the first one found in file <code class="docutils literal"><span class="pre">path</span></code> , which is parsed according to the specified <code class="docutils literal"><span class="pre">format</span></code> .</p>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificateChain">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">setLocalCertificateChain</code><span class="sig-paren">(</span><em>localChain</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificateChain" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>localChain</strong> – </td>
</tr>
</tbody>
</table>
<p>Sets the certificate chain to be presented to the peer during the SSL handshake to be <code class="docutils literal"><span class="pre">localChain</span></code> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.localCertificateChain" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.localCertificateChain"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.localCertificateChain()</span></code></a>  <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.setLocalCertificateChain" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.setLocalCertificateChain"><code class="xref py py-meth docutils literal"><span class="pre">QSslConfiguration.setLocalCertificateChain()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyDepth">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">setPeerVerifyDepth</code><span class="sig-paren">(</span><em>depth</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyDepth" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>depth</strong> – <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.int</span></code></td>
</tr>
</tbody>
</table>
<p>Sets the maximum number of certificates in the peer’s certificate chain to be checked during the SSL handshake phase, to <code class="docutils literal"><span class="pre">depth</span></code> . Setting a depth of 0 means that no maximum depth is set, indicating that the whole certificate chain should be checked.</p>
<p>The certificates are checked in issuing order, starting with the peer’s own certificate, then its issuer’s certificate, and so on.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyDepth" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyDepth"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.peerVerifyDepth()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyMode" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyMode"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setPeerVerifyMode()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyMode">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">setPeerVerifyMode</code><span class="sig-paren">(</span><em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyMode" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mode</strong> – <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.PeerVerifyMode" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.PeerVerifyMode"><code class="xref py py-attr docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.PeerVerifyMode</span></code></a></td>
</tr>
</tbody>
</table>
<p>Sets the socket’s verify mode to <code class="docutils literal"><span class="pre">mode</span></code> . This mode decides whether <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> should request a certificate from the peer (i.e., the client requests a certificate from the server, or a server requesting a certificate from the client), and whether it should require that this certificate is valid.</p>
<p>The default mode is <code class="xref py py-attr docutils literal"><span class="pre">AutoVerifyPeer</span></code> , which tells <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> to use <code class="xref py py-attr docutils literal"><span class="pre">VerifyPeer</span></code> for clients and <code class="xref py py-attr docutils literal"><span class="pre">QueryPeer</span></code> for servers.</p>
<p>Setting this mode after encryption has started has no effect on the current connection.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyMode" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyMode"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.peerVerifyMode()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyDepth" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyDepth"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setPeerVerifyDepth()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.mode" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.mode"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.mode()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyName">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">setPeerVerifyName</code><span class="sig-paren">(</span><em>hostName</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPeerVerifyName" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hostName</strong> – unicode</td>
</tr>
</tbody>
</table>
<p>Sets a different host name, given by <code class="docutils literal"><span class="pre">hostName</span></code> , for the certificate validation instead of the one used for the TCP connection.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyName" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerVerifyName"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.peerVerifyName()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.connectToHostEncrypted()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPrivateKey">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">setPrivateKey</code><span class="sig-paren">(</span><em>fileName</em><span class="optional">[</span>, <em>algorithm=QSsl.Rsa</em><span class="optional">[</span>, <em>format=QSsl.Pem</em><span class="optional">[</span>, <em>passPhrase=QByteArray()</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPrivateKey" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fileName</strong> – unicode</li>
<li><strong>algorithm</strong> – <a class="reference internal" href="QSsl.html#PySide2.QtNetwork.PySide2.QtNetwork.QSsl.KeyAlgorithm" title="PySide2.QtNetwork.PySide2.QtNetwork.QSsl.KeyAlgorithm"><code class="xref py py-attr docutils literal"><span class="pre">PySide2.QtNetwork.QSsl.KeyAlgorithm</span></code></a></li>
<li><strong>format</strong> – <a class="reference internal" href="QSsl.html#PySide2.QtNetwork.PySide2.QtNetwork.QSsl.EncodingFormat" title="PySide2.QtNetwork.PySide2.QtNetwork.QSsl.EncodingFormat"><code class="xref py py-attr docutils literal"><span class="pre">PySide2.QtNetwork.QSsl.EncodingFormat</span></code></a></li>
<li><strong>passPhrase</strong> – <a class="reference internal" href="../QtCore/QByteArray.html#PySide2.QtCore.QByteArray" title="PySide2.QtCore.QByteArray"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QByteArray</span></code></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Reads the string in file <code class="docutils literal"><span class="pre">fileName</span></code> and decodes it using a specified <code class="docutils literal"><span class="pre">algorithm</span></code> and encoding <code class="docutils literal"><span class="pre">format</span></code> to construct an <a class="reference internal" href="QSslKey.html#PySide2.QtNetwork.QSslKey" title="PySide2.QtNetwork.QSslKey"><code class="xref py py-class docutils literal"><span class="pre">SSL</span> <span class="pre">key</span></code></a> . If the encoded key is encrypted, <code class="docutils literal"><span class="pre">passPhrase</span></code> is used to decrypt it.</p>
<p>The socket’s private key is set to the constructed key. The private key and the local <a class="reference internal" href="QSslCertificate.html#PySide2.QtNetwork.QSslCertificate" title="PySide2.QtNetwork.QSslCertificate"><code class="xref py py-class docutils literal"><span class="pre">certificate</span></code></a> are used by clients and servers that must prove their identity to SSL peers.</p>
<p>Both the key and the local certificate are required if you are creating an SSL server socket. If you are creating an SSL client socket, the key and local certificate are required if your client must identify itself to an SSL server.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.privateKey" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.privateKey"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.privateKey()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setLocalCertificate()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">setPrivateKey</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> – <a class="reference internal" href="QSslKey.html#PySide2.QtNetwork.QSslKey" title="PySide2.QtNetwork.QSslKey"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslKey</span></code></a></td>
</tr>
</tbody>
</table>
<p>Sets the socket’s private <a class="reference internal" href="QSslKey.html#PySide2.QtNetwork.QSslKey" title="PySide2.QtNetwork.QSslKey"><code class="xref py py-class docutils literal"><span class="pre">key</span></code></a> to <code class="docutils literal"><span class="pre">key</span></code> . The private key and the local <a class="reference internal" href="QSslCertificate.html#PySide2.QtNetwork.QSslCertificate" title="PySide2.QtNetwork.QSslCertificate"><code class="xref py py-class docutils literal"><span class="pre">certificate</span></code></a> are used by clients and servers that must prove their identity to SSL peers.</p>
<p>Both the key and the local certificate are required if you are creating an SSL server socket. If you are creating an SSL client socket, the key and local certificate are required if your client must identify itself to an SSL server.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.privateKey" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.privateKey"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.privateKey()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setLocalCertificate()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setProtocol">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">setProtocol</code><span class="sig-paren">(</span><em>protocol</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setProtocol" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – <a class="reference internal" href="QSsl.html#PySide2.QtNetwork.PySide2.QtNetwork.QSsl.SslProtocol" title="PySide2.QtNetwork.PySide2.QtNetwork.QSsl.SslProtocol"><code class="xref py py-attr docutils literal"><span class="pre">PySide2.QtNetwork.QSsl.SslProtocol</span></code></a></td>
</tr>
</tbody>
</table>
<p>Sets the socket’s SSL protocol to <code class="docutils literal"><span class="pre">protocol</span></code> . This will affect the next initiated handshake; calling this function on an already-encrypted socket will not affect the socket’s protocol.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.protocol" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.protocol"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.protocol()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setSslConfiguration">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">setSslConfiguration</code><span class="sig-paren">(</span><em>config</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setSslConfiguration" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>config</strong> – <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.QSslConfiguration" title="PySide2.QtNetwork.QSslConfiguration"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslConfiguration</span></code></a></td>
</tr>
</tbody>
</table>
<p>Sets the socket’s SSL configuration to be the contents of <code class="docutils literal"><span class="pre">configuration</span></code> . This function sets the local certificate, the ciphers, the private key and the CA certificates to those stored in <code class="docutils literal"><span class="pre">configuration</span></code> .</p>
<p>It is not possible to set the SSL-state related fields.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslConfiguration" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslConfiguration"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.sslConfiguration()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setLocalCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setLocalCertificate()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPrivateKey" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setPrivateKey"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setPrivateKey()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setCaCertificates()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setCiphers()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslConfiguration">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">sslConfiguration</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslConfiguration" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.QSslConfiguration" title="PySide2.QtNetwork.QSslConfiguration"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslConfiguration</span></code></a></td>
</tr>
</tbody>
</table>
<p>Returns the socket’s SSL configuration state. The default SSL configuration of a socket is to use the default ciphers, default CA certificates, no local private key or certificate.</p>
<p>The SSL configuration also contains fields that can change with time without notice.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setSslConfiguration" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setSslConfiguration"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setSslConfiguration()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.localCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.localCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.localCertificate()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificate" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificate"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.peerCertificate()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificateChain" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.peerCertificateChain"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.peerCertificateChain()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sessionCipher" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sessionCipher"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.sessionCipher()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.privateKey" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.privateKey"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.privateKey()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ciphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ciphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.ciphers()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.caCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.caCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.caCertificates()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">sslErrors</code><span class="sig-paren">(</span><em>errors</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>errors</strong> – </td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">sslErrors</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Returns a list of the last SSL errors that occurred. This is the same list as <a class="reference internal" href="#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket</span></code></a> passes via the signal. If the connection has been encrypted with no errors, this function will return an empty list.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.connectToHostEncrypted()</span></code></a></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryBuildVersionNumber">
<em class="property">static </em><code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">sslLibraryBuildVersionNumber</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryBuildVersionNumber" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.long</span></code></td>
</tr>
</tbody>
</table>
<p>Returns the version number of the SSL library in use at compile time. If no SSL support is available then this will return an undefined value.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryVersionNumber" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryVersionNumber"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.sslLibraryVersionNumber()</span></code></a></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryBuildVersionString">
<em class="property">static </em><code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">sslLibraryBuildVersionString</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryBuildVersionString" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">unicode</td>
</tr>
</tbody>
</table>
<p>Returns the version string of the SSL library in use at compile time. If no SSL support is available then this will return an empty value.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryVersionString" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryVersionString"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.sslLibraryVersionString()</span></code></a></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryVersionNumber">
<em class="property">static </em><code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">sslLibraryVersionNumber</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryVersionNumber" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.long</span></code></td>
</tr>
</tbody>
</table>
<p>Returns the version number of the SSL library in use. Note that this is the version of the library in use at run-time not compile time. If no SSL support is available then this will return an undefined value.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryVersionString">
<em class="property">static </em><code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">sslLibraryVersionString</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslLibraryVersionString" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">unicode</td>
</tr>
</tbody>
</table>
<p>Returns the version string of the SSL library in use. Note that this is the version of the library in use at run-time not compile time. If no SSL support is available then this will return an empty value.</p>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startClientEncryption">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">startClientEncryption</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startClientEncryption" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts a delayed SSL handshake for a client connection. This function can be called when the socket is in the <code class="xref py py-attr docutils literal"><span class="pre">ConnectedState</span></code> but still in the <code class="xref py py-attr docutils literal"><span class="pre">UnencryptedMode</span></code> . If it is not yet connected, or if it is already encrypted, this function has no effect.</p>
<p>Clients that implement STARTTLS functionality often make use of delayed SSL handshakes. Most other clients can avoid calling this function directly by using <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.connectToHostEncrypted()</span></code></a> instead, which automatically performs the handshake.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.connectToHostEncrypted()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startServerEncryption" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startServerEncryption"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.startServerEncryption()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startServerEncryption">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">startServerEncryption</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startServerEncryption" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts a delayed SSL handshake for a server connection. This function can be called when the socket is in the <code class="xref py py-attr docutils literal"><span class="pre">ConnectedState</span></code> but still in <code class="xref py py-attr docutils literal"><span class="pre">UnencryptedMode</span></code> . If it is not connected or it is already encrypted, the function has no effect.</p>
<p>For server sockets, calling this function is the only way to initiate the SSL handshake. Most servers will call this function immediately upon receiving a connection, or as a result of having received a protocol-specific command to enter SSL mode (e.g, the server may respond to receiving the string “STARTTLS\r\n” by calling this function).</p>
<p>The most common way to implement an SSL server is to create a subclass of <a class="reference internal" href="QTcpServer.html#PySide2.QtNetwork.QTcpServer" title="PySide2.QtNetwork.QTcpServer"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtNetwork.QTcpServer</span></code></a> and reimplement <a class="reference internal" href="QTcpServer.html#PySide2.QtNetwork.PySide2.QtNetwork.QTcpServer.incomingConnection" title="PySide2.QtNetwork.PySide2.QtNetwork.QTcpServer.incomingConnection"><code class="xref py py-meth docutils literal"><span class="pre">QTcpServer.incomingConnection()</span></code></a> . The returned socket descriptor is then passed to <code class="xref py py-meth docutils literal"><span class="pre">QSslSocket.setSocketDescriptor()</span></code> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.connectToHostEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.connectToHostEncrypted()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startClientEncryption" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startClientEncryption"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.startClientEncryption()</span></code></a></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers">
<em class="property">static </em><code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">supportedCiphers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportedCiphers" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Use <a class="reference internal" href="QSslConfiguration.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.supportedCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslConfiguration.supportedCiphers"><code class="xref py py-meth docutils literal"><span class="pre">QSslConfiguration.supportedCiphers()</span></code></a> instead.</p>
<p>Returns the list of cryptographic ciphers supported by this system. This list is set by the system’s SSL libraries and may vary from system to system.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.defaultCiphers()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ciphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.ciphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.ciphers()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setCiphers"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setCiphers()</span></code></a></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportsSsl">
<em class="property">static </em><code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">supportsSsl</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.supportsSsl" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.bool</span></code></td>
</tr>
</tbody>
</table>
<p>Returns <code class="docutils literal"><span class="pre">true</span></code> if this platform supports SSL; otherwise, returns false. If the platform doesn’t support SSL, the socket will fail in the connection phase.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.systemCaCertificates">
<em class="property">static </em><code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">systemCaCertificates</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.systemCaCertificates" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Use QSslConfiguration::systemDefaultCaCertificates instead.</p>
<p>This function provides the CA certificate database provided by the operating system. The CA certificate database returned by this function is used to initialize the database returned by <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.defaultCaCertificates()</span></code></a> . You can replace that database with your own with <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setDefaultCaCertificates()</span></code></a> .</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">: On OS X, only certificates that are either trusted for all purposes or trusted for the purpose of SSL in the keychain will be returned.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.caCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.caCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.caCertificates()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.defaultCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.defaultCaCertificates()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCaCertificates" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.setDefaultCaCertificates"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.setDefaultCaCertificates()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.waitForEncrypted">
<code class="descclassname">PySide2.QtNetwork.QSslSocket.</code><code class="descname">waitForEncrypted</code><span class="sig-paren">(</span><span class="optional">[</span><em>msecs=30000</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.waitForEncrypted" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>msecs</strong> – <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.int</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.bool</span></code></td>
</tr>
</tbody>
</table>
<p>Waits until the socket has completed the SSL handshake and has emitted <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.encrypted()</span></code></a> , or <code class="docutils literal"><span class="pre">msecs</span></code> milliseconds, whichever comes first. If <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.encrypted()</span></code></a> has been emitted, this function returns true; otherwise (e.g., the socket is disconnected, or the SSL handshake fails), false is returned.</p>
<p>The following example waits up to one second for the socket to be encrypted:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">socket</span><span class="o">.</span><span class="n">connectToHostEncrypted</span><span class="p">(</span><span class="s2">&quot;imap&quot;</span><span class="p">,</span> <span class="mi">993</span><span class="p">)</span>
<span class="k">if</span> <span class="n">socket</span><span class="o">.</span><span class="n">waitForEncrypted</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
    <span class="nb">print</span> <span class="s2">&quot;Encrypted!&quot;</span>
</pre></div>
</div>
<p>If msecs is -1, this function will not time out.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startClientEncryption" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startClientEncryption"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.startClientEncryption()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startServerEncryption" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.startServerEncryption"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.startServerEncryption()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.encrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.encrypted()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.isEncrypted" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.isEncrypted"><code class="xref py py-meth docutils literal"><span class="pre">PySide2.QtNetwork.QSslSocket.isEncrypted()</span></code></a></p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <p>© 2018 The Qt Company Ltd. Documentation contributions included herein are the copyrights of their respective owners. The documentation provided herein is licensed under the terms of the <a href="http://www.gnu.org/license/fdl.html">GNU Free Documentation License version 1.3</a> as published by the Free Software Foundation. Qt and respective logos are trademarks of The Qt Company Ltd. in Finland and/or other countries worldwide. All other trademarks are property of their respective owners.</p>
    </div></div>
    <div id="footer" class="footer">
    </div>
</div>
  </body>
</html>