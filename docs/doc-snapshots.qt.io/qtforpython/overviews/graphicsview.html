
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Graphics View Framework &#8212; Qt for Python (Technology Preview)</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '5.11.0~a1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" title="Search" href="../search.html" />
  <link rel="stylesheet" type="text/css" href="/style/pyside.css" />
  <link rel="icon" type="image/png" href="/style/pyside-32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/style/pyside-16px.png" sizes="16x16" />
  <script type="text/javascript"> wpThemeFolder = 'http://qt.io/wp-content/themes/oneqt'; </script>
  <script type="text/javascript" src="/scripts/main.js"></script>
  <script type="text/javascript" src="/scripts/extras.js"></script>
  <script type="text/javascript">
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-54043535-2', 'qt.io');
    ga('set', 'forceSSL', true);
    ga('send', 'pageview');
  </script>

  </head>
  <body>
<div id="container">
    <div class="header">
        <div class="header_container">
            <header id="navbar">
            </header>
        </div>
    </div>
    <div class="main">
        <div class="main-rounded">
            <div class="navigationbar">
                <ul class="sub-navigation">
                    <li><a href="http://wiki.qt.io/">Wiki</a></li>
                    <li><a href="https://doc.qt.io/">Documentation</a></li>
                    <li><a href="http://forum.qt.io/">Forum</a></li>
                    <li><a href="https://bugreports.qt.io/">Bug Reports</a></li>
                    <li><a href="https://codereview.qt-project.org/">Code Review</a></li>
                </ul>
                <div id="main_title_bar"><h1>Qt Documentation</h1></div>
                <div class="related">
                    <ul>
                        <li><a href="../index.html">Qt for Python (Technology Preview)</a></li> 
                    </ul>
                </div>
            </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Graphics View Framework</a><ul>
<li><a class="reference internal" href="#the-graphics-view-architecture">The Graphics View Architecture</a></li>
<li><a class="reference internal" href="#the-scene">The Scene</a></li>
<li><a class="reference internal" href="#the-view">The View</a></li>
<li><a class="reference internal" href="#the-item">The Item</a></li>
<li><a class="reference internal" href="#classes-in-the-graphics-view-framework">Classes in the Graphics View Framework</a></li>
<li><a class="reference internal" href="#the-graphics-view-coordinate-system">The Graphics View Coordinate System</a></li>
<li><a class="reference internal" href="#item-coordinates">Item Coordinates</a></li>
<li><a class="reference internal" href="#scene-coordinates">Scene Coordinates</a></li>
<li><a class="reference internal" href="#view-coordinates">View Coordinates</a></li>
<li><a class="reference internal" href="#coordinate-mapping">Coordinate Mapping</a></li>
<li><a class="reference internal" href="#key-features">Key Features</a></li>
<li><a class="reference internal" href="#zooming-and-rotating">Zooming and rotating</a></li>
<li><a class="reference internal" href="#printing">Printing</a></li>
<li><a class="reference internal" href="#drag-and-drop">Drag and Drop</a></li>
<li><a class="reference internal" href="#cursors-and-tooltips">Cursors and Tooltips</a></li>
<li><a class="reference internal" href="#animation">Animation</a></li>
<li><a class="reference internal" href="#opengl-rendering">OpenGL Rendering</a></li>
<li><a class="reference internal" href="#item-groups">Item Groups</a></li>
<li><a class="reference internal" href="#widgets-and-layouts">Widgets and Layouts</a></li>
<li><a class="reference internal" href="#qgraphicswidget">QGraphicsWidget</a></li>
<li><a class="reference internal" href="#qgraphicslayout">QGraphicsLayout</a></li>
<li><a class="reference internal" href="#embedded-widget-support">Embedded Widget Support</a></li>
<li><a class="reference internal" href="#performance">Performance</a></li>
<li><a class="reference internal" href="#floating-point-instructions">Floating Point Instructions</a></li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="graphics-view-framework">
<span id="id1"></span><h1>Graphics View Framework<a class="headerlink" href="#graphics-view-framework" title="Permalink to this headline">¶</a></h1>
<p>An overview of the Graphics View framework for interactive 2D graphics</p>
<blockquote>
<div><p>An overview of the Graphics View framework for interactive 2D graphics.</p>
<p>Graphics View provides a surface for managing and interacting with a large number of custom-made 2D graphical items, and a view widget for visualizing the items, with support for zooming and rotation.</p>
<p>The framework includes an event propagation architecture that allows precise double-precision interaction capabilities for the items on the scene. Items can handle key events, mouse press, move, release and double click events, and they can also track mouse movement.</p>
<p>Graphics View uses a BSP (Binary Space Partitioning) tree to provide very fast item discovery, and as a result of this, it can visualize large scenes in real-time, even with millions of items.</p>
<p>Graphics View was introduced in Qt 4.2, replacing its predecessor, QCanvas.</p>
<p>Topics:</p>
</div></blockquote>
<div class="section" id="the-graphics-view-architecture">
<span id="id2"></span><h2>The Graphics View Architecture<a class="headerlink" href="#the-graphics-view-architecture" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>Graphics View provides an item-based approach to model-view programming, much like InterView’s convenience classes <a class="reference internal" href="../PySide2/QtWidgets/QTableView.html#PySide2.QtWidgets.QTableView" title="PySide2.QtWidgets.QTableView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTableView</span></code></a> , <a class="reference internal" href="../PySide2/QtWidgets/QTreeView.html#PySide2.QtWidgets.QTreeView" title="PySide2.QtWidgets.QTreeView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTreeView</span></code></a> and <a class="reference internal" href="../PySide2/QtWidgets/QListView.html#PySide2.QtWidgets.QListView" title="PySide2.QtWidgets.QListView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QListView</span></code></a> . Several views can observe a single scene, and the scene contains items of varying geometric shapes.</div></blockquote>
</div>
<div class="section" id="the-scene">
<span id="id3"></span><h2>The Scene<a class="headerlink" href="#the-scene" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p><a class="reference internal" href="../PySide2/QtWidgets/QGraphicsScene.html#PySide2.QtWidgets.QGraphicsScene" title="PySide2.QtWidgets.QGraphicsScene"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsScene</span></code></a> provides the Graphics View scene. The scene has the following responsibilities:</p>
<ul class="simple">
<li>Providing a fast interface for managing a large number of items</li>
<li>Propagating events to each item</li>
<li>Managing item state, such as selection and focus handling</li>
<li>Providing untransformed rendering functionality; mainly for printing</li>
</ul>
<p>The scene serves as a container for <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsItem.html#PySide2.QtWidgets.QGraphicsItem" title="PySide2.QtWidgets.QGraphicsItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsItem</span></code></a> objects. Items are added to the scene by calling <code class="xref py py-func docutils literal"><span class="pre">QGraphicsScene.addItem()</span></code> , and then retrieved by calling one of the many item discovery functions. <code class="xref py py-func docutils literal"><span class="pre">QGraphicsScene.items()</span></code> and its overloads return all items contained by or intersecting with a point, a rectangle, a polygon or a general vector path. <code class="xref py py-func docutils literal"><span class="pre">QGraphicsScene.itemAt()</span></code> returns the topmost item at a particular point. All item discovery functions return the items in descending stacking order (i.e., the first returned item is topmost, and the last item is bottom-most).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QGraphicsScene</span> <span class="n">scene</span><span class="p">;</span>
<span class="n">QGraphicsRectItem</span> <span class="o">*</span><span class="n">rect</span> <span class="o">=</span> <span class="n">scene</span><span class="o">.</span><span class="n">addRect</span><span class="p">(</span><span class="n">QRectF</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">));</span>

<span class="n">QGraphicsItem</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="n">scene</span><span class="o">.</span><span class="n">itemAt</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
<span class="o">//</span> <span class="n">item</span> <span class="o">==</span> <span class="n">rect</span>
</pre></div>
</div>
<p><a class="reference internal" href="../PySide2/QtWidgets/QGraphicsScene.html#PySide2.QtWidgets.QGraphicsScene" title="PySide2.QtWidgets.QGraphicsScene"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsScene</span></code></a> ‘s event propagation architecture schedules scene events for delivery to items, and also manages propagation between items. If the scene receives a mouse press event at a certain position, the scene passes the event on to whichever item is at that position.</p>
<p><a class="reference internal" href="../PySide2/QtWidgets/QGraphicsScene.html#PySide2.QtWidgets.QGraphicsScene" title="PySide2.QtWidgets.QGraphicsScene"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsScene</span></code></a> also manages certain item states, such as item selection and focus. You can select items on the scene by calling <code class="xref py py-func docutils literal"><span class="pre">QGraphicsScene.setSelectionArea()</span></code> , passing an arbitrary shape. This functionality is also used as a basis for rubberband selection in <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsView.html#PySide2.QtWidgets.QGraphicsView" title="PySide2.QtWidgets.QGraphicsView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsView</span></code></a> . To get the list of all currently selected items, call <code class="xref py py-func docutils literal"><span class="pre">QGraphicsScene.selectedItems()</span></code> . Another state handled by <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsScene.html#PySide2.QtWidgets.QGraphicsScene" title="PySide2.QtWidgets.QGraphicsScene"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsScene</span></code></a> is whether or not an item has keyboard input focus. You can set focus on an item by calling <code class="xref py py-func docutils literal"><span class="pre">QGraphicsScene.setFocusItem()</span></code> or <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.setFocus()</span></code> , or get the current focus item by calling <code class="xref py py-func docutils literal"><span class="pre">QGraphicsScene.focusItem()</span></code> .</p>
<p>Finally, <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsScene.html#PySide2.QtWidgets.QGraphicsScene" title="PySide2.QtWidgets.QGraphicsScene"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsScene</span></code></a> allows you to render parts of the scene into a paint device through the <code class="xref py py-func docutils literal"><span class="pre">QGraphicsScene.render()</span></code> function. You can read more about this in the Printing section later in this document.</p>
</div></blockquote>
</div>
<div class="section" id="the-view">
<span id="id4"></span><h2>The View<a class="headerlink" href="#the-view" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p><a class="reference internal" href="../PySide2/QtWidgets/QGraphicsView.html#PySide2.QtWidgets.QGraphicsView" title="PySide2.QtWidgets.QGraphicsView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsView</span></code></a> provides the view widget, which visualizes the contents of a scene. You can attach several views to the same scene, to provide several viewports into the same data set. The view widget is a scroll area, and provides scroll bars for navigating through large scenes. To enable OpenGL support, you can set a <a class="reference internal" href="../PySide2/QtOpenGL/QGLWidget.html#PySide2.QtOpenGL.QGLWidget" title="PySide2.QtOpenGL.QGLWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtOpenGL.QGLWidget</span></code></a> as the viewport by calling <code class="xref py py-func docutils literal"><span class="pre">QGraphicsView.setViewport()</span></code> .</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QGraphicsScene</span> <span class="n">scene</span><span class="p">;</span>
<span class="n">myPopulateScene</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scene</span><span class="p">);</span>

<span class="n">QGraphicsView</span> <span class="n">view</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scene</span><span class="p">);</span>
<span class="n">view</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
</pre></div>
</div>
<p>The view receives input events from the keyboard and mouse, and translates these to scene events (converting the coordinates used to scene coordinates where appropriate), before sending the events to the visualized scene.</p>
<p>Using its transformation matrix, <code class="xref py py-func docutils literal"><span class="pre">QGraphicsView.transform()</span></code> , the view can <em>transform</em> the scene’s coordinate system. This allows advanced navigation features such as zooming and rotation. For convenience, <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsView.html#PySide2.QtWidgets.QGraphicsView" title="PySide2.QtWidgets.QGraphicsView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsView</span></code></a> also provides functions for translating between view and scene coordinates: <code class="xref py py-func docutils literal"><span class="pre">QGraphicsView.mapToScene()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">QGraphicsView.mapFromScene()</span></code> .</p>
</div></blockquote>
</div>
<div class="section" id="the-item">
<span id="id5"></span><h2>The Item<a class="headerlink" href="#the-item" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p><a class="reference internal" href="../PySide2/QtWidgets/QGraphicsItem.html#PySide2.QtWidgets.QGraphicsItem" title="PySide2.QtWidgets.QGraphicsItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsItem</span></code></a> is the base class for graphical items in a scene. Graphics View provides several standard items for typical shapes, such as rectangles ( <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsRectItem.html#PySide2.QtWidgets.QGraphicsRectItem" title="PySide2.QtWidgets.QGraphicsRectItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsRectItem</span></code></a> ), ellipses ( <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsEllipseItem.html#PySide2.QtWidgets.QGraphicsEllipseItem" title="PySide2.QtWidgets.QGraphicsEllipseItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsEllipseItem</span></code></a> ) and text items ( <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsTextItem.html#PySide2.QtWidgets.QGraphicsTextItem" title="PySide2.QtWidgets.QGraphicsTextItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsTextItem</span></code></a> ), but the most powerful <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsItem.html#PySide2.QtWidgets.QGraphicsItem" title="PySide2.QtWidgets.QGraphicsItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsItem</span></code></a> features are available when you write a custom item. Among other things, <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsItem.html#PySide2.QtWidgets.QGraphicsItem" title="PySide2.QtWidgets.QGraphicsItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsItem</span></code></a> supports the following features:</p>
<ul class="simple">
<li>Mouse press, move, release and double click events, as well as mouse hover events, wheel events, and context menu events.</li>
<li>Keyboard input focus, and key events</li>
<li>Drag and drop</li>
<li>Grouping, both through parent-child relationships, and with <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsItemGroup.html#PySide2.QtWidgets.QGraphicsItemGroup" title="PySide2.QtWidgets.QGraphicsItemGroup"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsItemGroup</span></code></a></li>
<li>Collision detection</li>
</ul>
<p>Items live in a local coordinate system, and like <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsView.html#PySide2.QtWidgets.QGraphicsView" title="PySide2.QtWidgets.QGraphicsView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsView</span></code></a> , it also provides many functions for mapping coordinates between the item and the scene, and from item to item. Also, like <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsView.html#PySide2.QtWidgets.QGraphicsView" title="PySide2.QtWidgets.QGraphicsView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsView</span></code></a> , it can transform its coordinate system using a matrix: <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.transform()</span></code> . This is useful for rotating and scaling individual items.</p>
<p>Items can contain other items (children). Parent items’ transformations are inherited by all its children. Regardless of an item’s accumulated transformation, though, all its functions (e.g., <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.contains()</span></code> , <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.boundingRect()</span></code> , QGraphicsItem::collidesWith()) still operate in local coordinates.</p>
<p><a class="reference internal" href="../PySide2/QtWidgets/QGraphicsItem.html#PySide2.QtWidgets.QGraphicsItem" title="PySide2.QtWidgets.QGraphicsItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsItem</span></code></a> supports collision detection through the <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.shape()</span></code> function, and QGraphicsItem::collidesWith(), which are both virtual functions. By returning your item’s shape as a local coordinate <a class="reference internal" href="../PySide2/QtGui/QPainterPath.html#PySide2.QtGui.QPainterPath" title="PySide2.QtGui.QPainterPath"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtGui.QPainterPath</span></code></a> from <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.shape()</span></code> , <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsItem.html#PySide2.QtWidgets.QGraphicsItem" title="PySide2.QtWidgets.QGraphicsItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsItem</span></code></a> will handle all collision detection for you. If you want to provide your own collision detection, however, you can reimplement QGraphicsItem::collidesWith().</p>
</div></blockquote>
</div>
<div class="section" id="classes-in-the-graphics-view-framework">
<span id="id6"></span><h2>Classes in the Graphics View Framework<a class="headerlink" href="#classes-in-the-graphics-view-framework" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>These classes provide a framework for creating interactive applications.</div></blockquote>
</div>
<div class="section" id="the-graphics-view-coordinate-system">
<span id="id7"></span><h2>The Graphics View Coordinate System<a class="headerlink" href="#the-graphics-view-coordinate-system" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Graphics View is based on the Cartesian coordinate system; items’ position and geometry on the scene are represented by sets of two numbers: the x-coordinate, and the y-coordinate. When observing a scene using an untransformed view, one unit on the scene is represented by one pixel on the screen.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The inverted Y-axis coordinate system (where <code class="docutils literal"><span class="pre">y</span></code> grows upwards) is unsupported as Graphics Views uses Qt’s coordinate system.</p>
</div>
<p>There are three effective coordinate systems in play in Graphics View: Item coordinates, scene coordinates, and view coordinates. To simplify your implementation, Graphics View provides convenience functions that allow you to map between the three coordinate systems.</p>
<p>When rendering, Graphics View’s scene coordinates correspond to <a class="reference internal" href="../PySide2/QtGui/QPainter.html#PySide2.QtGui.QPainter" title="PySide2.QtGui.QPainter"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtGui.QPainter</span></code></a> ‘s <em>logical</em> coordinates, and view coordinates are the same as <em>device</em> coordinates. In the <a class="reference internal" href="qtquick-visualcanvas-topic.html#coordinate-system"><span class="std std-ref">Coordinate System</span></a> documentation, you can read about the relationship between logical coordinates and device coordinates.</p>
</div></blockquote>
</div>
<div class="section" id="item-coordinates">
<span id="id8"></span><h2>Item Coordinates<a class="headerlink" href="#item-coordinates" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Items live in their own local coordinate system. Their coordinates are usually centered around its center point (0, 0), and this is also the center for all transformations. Geometric primitives in the item coordinate system are often referred to as item points, item lines, or item rectangles.</p>
<p>When creating a custom item, item coordinates are all you need to worry about; <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsScene.html#PySide2.QtWidgets.QGraphicsScene" title="PySide2.QtWidgets.QGraphicsScene"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsScene</span></code></a> and <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsView.html#PySide2.QtWidgets.QGraphicsView" title="PySide2.QtWidgets.QGraphicsView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsView</span></code></a> will perform all transformations for you. This makes it very easy to implement custom items. For example, if you receive a mouse press or a drag enter event, the event position is given in item coordinates. The <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.contains()</span></code> virtual function, which returns <code class="docutils literal"><span class="pre">true</span></code> if a certain point is inside your item, and false otherwise, takes a point argument in item coordinates. Similarly, an item’s bounding rect and shape are in item coordinates.</p>
<p>At item’s <em>position</em> is the coordinate of the item’s center point in its parent’s coordinate system; sometimes referred to as <em>parent</em> coordinates. The scene is in this sense regarded as all parent-less items’ “parent”. Top level items’ position are in scene coordinates.</p>
<p>Child coordinates are relative to the parent’s coordinates. If the child is untransformed, the difference between a child coordinate and a parent coordinate is the same as the distance between the items in parent coordinates. For example: If an untransformed child item is positioned precisely in its parent’s center point, then the two items’ coordinate systems will be identical. If the child’s position is (10, 0), however, the child’s (0, 10) point will correspond to its parent’s (10, 10) point.</p>
<p>Because items’ position and transformation are relative to the parent, child items’ coordinates are unaffected by the parent’s transformation, although the parent’s transformation implicitly transforms the child. In the above example, even if the parent is rotated and scaled, the child’s (0, 10) point will still correspond to the parent’s (10, 10) point. Relative to the scene, however, the child will follow the parent’s transformation and position. If the parent is scaled (2x, 2x), the child’s position will be at scene coordinate (20, 0), and its (10, 0) point will correspond to the point (40, 0) on the scene.</p>
<p>With <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.pos()</span></code> being one of the few exceptions, <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsItem.html#PySide2.QtWidgets.QGraphicsItem" title="PySide2.QtWidgets.QGraphicsItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsItem</span></code></a> ‘s functions operate in item coordinates, regardless of the item, or any of its parents’ transformation. For example, an item’s bounding rect (i.e. <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.boundingRect()</span></code> ) is always given in item coordinates.</p>
</div></blockquote>
</div>
<div class="section" id="scene-coordinates">
<span id="id9"></span><h2>Scene Coordinates<a class="headerlink" href="#scene-coordinates" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The scene represents the base coordinate system for all its items. The scene coordinate system describes the position of each top-level item, and also forms the basis for all scene events delivered to the scene from the view. Each item on the scene has a scene position and bounding rectangle ( <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.scenePos()</span></code> , <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.sceneBoundingRect()</span></code> ), in addition to its local item pos and bounding rectangle. The scene position describes the item’s position in scene coordinates, and its scene bounding rect forms the basis for how <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsScene.html#PySide2.QtWidgets.QGraphicsScene" title="PySide2.QtWidgets.QGraphicsScene"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsScene</span></code></a> determines what areas of the scene have changed. Changes in the scene are communicated through the <code class="xref py py-func docutils literal"><span class="pre">QGraphicsScene.changed()</span></code> signal, and the argument is a list of scene rectangles.</div></blockquote>
</div>
<div class="section" id="view-coordinates">
<span id="id10"></span><h2>View Coordinates<a class="headerlink" href="#view-coordinates" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>View coordinates are the coordinates of the widget. Each unit in view coordinates corresponds to one pixel. What’s special about this coordinate system is that it is relative to the widget, or viewport, and unaffected by the observed scene. The top left corner of <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsView.html#PySide2.QtWidgets.QGraphicsView" title="PySide2.QtWidgets.QGraphicsView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsView</span></code></a> ‘s viewport is always (0, 0), and the bottom right corner is always (viewport width, viewport height). All mouse events and drag and drop events are originally received as view coordinates, and you need to map these coordinates to the scene in order to interact with items.</div></blockquote>
</div>
<div class="section" id="coordinate-mapping">
<span id="id11"></span><h2>Coordinate Mapping<a class="headerlink" href="#coordinate-mapping" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Often when dealing with items in a scene, it can be useful to map coordinates and arbitrary shapes from the scene to an item, from item to item, or from the view to the scene. For example, when you click your mouse in <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsView.html#PySide2.QtWidgets.QGraphicsView" title="PySide2.QtWidgets.QGraphicsView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsView</span></code></a> ‘s viewport, you can ask the scene what item is under the cursor by calling <code class="xref py py-func docutils literal"><span class="pre">QGraphicsView.mapToScene()</span></code> , followed by <code class="xref py py-func docutils literal"><span class="pre">QGraphicsScene.itemAt()</span></code> . If you want to know where in the viewport an item is located, you can call <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.mapToScene()</span></code> on the item, then <code class="xref py py-func docutils literal"><span class="pre">QGraphicsView.mapFromScene()</span></code> on the view. Finally, if you use want to find what items are inside a view ellipse, you can pass a <a class="reference internal" href="../PySide2/QtGui/QPainterPath.html#PySide2.QtGui.QPainterPath" title="PySide2.QtGui.QPainterPath"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtGui.QPainterPath</span></code></a> to mapToScene(), and then pass the mapped path to <code class="xref py py-func docutils literal"><span class="pre">QGraphicsScene.items()</span></code> .</p>
<p>You can map coordinates and shapes to and from an item’s scene by calling <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.mapToScene()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.mapFromScene()</span></code> . You can also map to an item’s parent item by calling <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.mapToParent()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.mapFromParent()</span></code> , or between items by calling <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.mapToItem()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.mapFromItem()</span></code> . All mapping functions can map both points, rectangles, polygons and paths.</p>
<p>The same mapping functions are available in the view, for mapping to and from the scene. <code class="xref py py-func docutils literal"><span class="pre">QGraphicsView.mapFromScene()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">QGraphicsView.mapToScene()</span></code> . To map from a view to an item, you first map to the scene, and then map from the scene to the item.</p>
</div></blockquote>
</div>
<div class="section" id="key-features">
<span id="id12"></span><h2>Key Features<a class="headerlink" href="#key-features" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div></div></blockquote>
</div>
<div class="section" id="zooming-and-rotating">
<span id="id13"></span><h2>Zooming and rotating<a class="headerlink" href="#zooming-and-rotating" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p><a class="reference internal" href="../PySide2/QtWidgets/QGraphicsView.html#PySide2.QtWidgets.QGraphicsView" title="PySide2.QtWidgets.QGraphicsView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsView</span></code></a> supports the same affine transformations as <a class="reference internal" href="../PySide2/QtGui/QPainter.html#PySide2.QtGui.QPainter" title="PySide2.QtGui.QPainter"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtGui.QPainter</span></code></a> does through <code class="xref py py-func docutils literal"><span class="pre">QGraphicsView.setMatrix()</span></code> . By applying a transformation to the view, you can easily add support for common navigation features such as zooming and rotating.</p>
<p>Here is an example of how to implement zoom and rotate slots in a subclass of <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsView.html#PySide2.QtWidgets.QGraphicsView" title="PySide2.QtWidgets.QGraphicsView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsView</span></code></a> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">View</span> <span class="p">:</span> <span class="n">public</span> <span class="n">QGraphicsView</span>
<span class="p">{</span>
<span class="n">Q_OBJECT</span>
    <span class="o">...</span>
<span class="n">public</span> <span class="n">slots</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">zoomIn</span><span class="p">()</span> <span class="p">{</span> <span class="n">scale</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">void</span> <span class="n">zoomOut</span><span class="p">()</span> <span class="p">{</span> <span class="n">scale</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">1.2</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">void</span> <span class="n">rotateLeft</span><span class="p">()</span> <span class="p">{</span> <span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">void</span> <span class="n">rotateRight</span><span class="p">()</span> <span class="p">{</span> <span class="n">rotate</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="p">}</span>
    <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The slots could be connected to <a class="reference internal" href="../PySide2/QtWidgets/QToolButton.html#PySide2.QtWidgets.QToolButton" title="PySide2.QtWidgets.QToolButton"><code class="xref py py-class docutils literal"><span class="pre">QToolButtons</span></code></a> with <code class="xref py py-func docutils literal"><span class="pre">QAbstractButton.autoRepeat()</span></code> enabled.</p>
<p><a class="reference internal" href="../PySide2/QtWidgets/QGraphicsView.html#PySide2.QtWidgets.QGraphicsView" title="PySide2.QtWidgets.QGraphicsView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsView</span></code></a> keeps the center of the view aligned when you transform the view.</p>
<p>See also the <a class="reference internal" href="qtwidgets-graphicsview-elasticnodes-example.html#elastic-nodes-example"><span class="std std-ref">Elastic Nodes</span></a> example for code that shows how to implement basic zooming features.</p>
</div></blockquote>
</div>
<div class="section" id="printing">
<span id="id14"></span><h2>Printing<a class="headerlink" href="#printing" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Graphics View provides single-line printing through its rendering functions, <code class="xref py py-func docutils literal"><span class="pre">QGraphicsScene.render()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">QGraphicsView.render()</span></code> . The functions provide the same API: You can have the scene or the view render all or parts of their contents into any paint device by passing a <a class="reference internal" href="../PySide2/QtGui/QPainter.html#PySide2.QtGui.QPainter" title="PySide2.QtGui.QPainter"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtGui.QPainter</span></code></a> to either of the rendering functions. This example shows how to print the whole scene into a full page, using <a class="reference internal" href="../PySide2/QtPrintSupport/QPrinter.html#PySide2.QtPrintSupport.QPrinter" title="PySide2.QtPrintSupport.QPrinter"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtPrintSupport.QPrinter</span></code></a> .</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QGraphicsScene</span> <span class="n">scene</span><span class="p">;</span>
<span class="n">scene</span><span class="o">.</span><span class="n">addRect</span><span class="p">(</span><span class="n">QRectF</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span> <span class="n">QPen</span><span class="p">(</span><span class="n">Qt</span><span class="p">::</span><span class="n">black</span><span class="p">),</span> <span class="n">QBrush</span><span class="p">(</span><span class="n">Qt</span><span class="p">::</span><span class="n">green</span><span class="p">));</span>

<span class="n">QPrinter</span> <span class="n">printer</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">QPrintDialog</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printer</span><span class="p">)</span><span class="o">.</span><span class="n">exec</span><span class="p">()</span> <span class="o">==</span> <span class="n">QDialog</span><span class="p">::</span><span class="n">Accepted</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">QPainter</span> <span class="n">painter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printer</span><span class="p">);</span>
    <span class="n">painter</span><span class="o">.</span><span class="n">setRenderHint</span><span class="p">(</span><span class="n">QPainter</span><span class="p">::</span><span class="n">Antialiasing</span><span class="p">);</span>
    <span class="n">scene</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="o">&amp;</span><span class="n">painter</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The difference between the scene and view rendering functions is that one operates in scene coordinates, and the other in view coordinates. <code class="xref py py-func docutils literal"><span class="pre">QGraphicsScene.render()</span></code> is often preferred for printing whole segments of a scene untransformed, such as for plotting geometrical data, or for printing a text document. <code class="xref py py-func docutils literal"><span class="pre">QGraphicsView.render()</span></code> , on the other hand, is suitable for taking screenshots; its default behavior is to render the exact contents of the viewport using the provided painter.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QGraphicsScene</span> <span class="n">scene</span><span class="p">;</span>
<span class="n">scene</span><span class="o">.</span><span class="n">addRect</span><span class="p">(</span><span class="n">QRectF</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span> <span class="n">QPen</span><span class="p">(</span><span class="n">Qt</span><span class="p">::</span><span class="n">black</span><span class="p">),</span> <span class="n">QBrush</span><span class="p">(</span><span class="n">Qt</span><span class="p">::</span><span class="n">green</span><span class="p">));</span>

<span class="n">QPixmap</span> <span class="n">pixmap</span><span class="p">;</span>
<span class="n">QPainter</span> <span class="n">painter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pixmap</span><span class="p">);</span>
<span class="n">painter</span><span class="o">.</span><span class="n">setRenderHint</span><span class="p">(</span><span class="n">QPainter</span><span class="p">::</span><span class="n">Antialiasing</span><span class="p">);</span>
<span class="n">scene</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="o">&amp;</span><span class="n">painter</span><span class="p">);</span>
<span class="n">painter</span><span class="o">.</span><span class="n">end</span><span class="p">();</span>

<span class="n">pixmap</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;scene.png&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>When the source and target areas’ sizes do not match, the source contents are stretched to fit into the target area. By passing a <code class="xref py py-attr docutils literal"><span class="pre">Qt.AspectRatioMode</span></code> to the rendering function you are using, you can choose to maintain or ignore the aspect ratio of the scene when the contents are stretched.</p>
</div></blockquote>
</div>
<div class="section" id="drag-and-drop">
<span id="id15"></span><h2>Drag and Drop<a class="headerlink" href="#drag-and-drop" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Because <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsView.html#PySide2.QtWidgets.QGraphicsView" title="PySide2.QtWidgets.QGraphicsView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsView</span></code></a> inherits <a class="reference internal" href="../PySide2/QtWidgets/QWidget.html#PySide2.QtWidgets.QWidget" title="PySide2.QtWidgets.QWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QWidget</span></code></a> indirectly, it already provides the same drag and drop functionality that <a class="reference internal" href="../PySide2/QtWidgets/QWidget.html#PySide2.QtWidgets.QWidget" title="PySide2.QtWidgets.QWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QWidget</span></code></a> provides. In addition, as a convenience, the Graphics View framework provides drag and drop support for the scene, and for each and every item. As the view receives a drag, it translates the drag and drop events into a <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsSceneDragDropEvent.html#PySide2.QtWidgets.QGraphicsSceneDragDropEvent" title="PySide2.QtWidgets.QGraphicsSceneDragDropEvent"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsSceneDragDropEvent</span></code></a> , which is then forwarded to the scene. The scene takes over scheduling of this event, and sends it to the first item under the mouse cursor that accepts drops.</p>
<p>To start a drag from an item, create a <a class="reference internal" href="../PySide2/QtGui/QDrag.html#PySide2.QtGui.QDrag" title="PySide2.QtGui.QDrag"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtGui.QDrag</span></code></a> object, passing a pointer to the widget that starts the drag. Items can be observed by many views at the same time, but only one view can start the drag. Drags are in most cases started as a result of pressing or moving the mouse, so in mousePressEvent() or mouseMoveEvent(), you can get the originating widget pointer from the event. For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">CustomItem</span><span class="p">::</span><span class="n">mousePressEvent</span><span class="p">(</span><span class="n">QGraphicsSceneMouseEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">QMimeData</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">new</span> <span class="n">QMimeData</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">setColor</span><span class="p">(</span><span class="n">Qt</span><span class="p">::</span><span class="n">green</span><span class="p">);</span>

    <span class="n">QDrag</span> <span class="o">*</span><span class="n">drag</span> <span class="o">=</span> <span class="n">new</span> <span class="n">QDrag</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">widget</span><span class="p">());</span>
    <span class="n">drag</span><span class="o">-&gt;</span><span class="n">setMimeData</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="n">drag</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To intercept drag and drop events for the scene, you reimplement <code class="xref py py-func docutils literal"><span class="pre">QGraphicsScene.dragEnterEvent()</span></code> and whichever event handlers your particular scene needs, in a <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsItem.html#PySide2.QtWidgets.QGraphicsItem" title="PySide2.QtWidgets.QGraphicsItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsItem</span></code></a> subclass. You can read more about drag and drop in Graphics View in the documentation for each of <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsScene.html#PySide2.QtWidgets.QGraphicsScene" title="PySide2.QtWidgets.QGraphicsScene"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsScene</span></code></a> ‘s event handlers.</p>
<p>Items can enable drag and drop support by calling <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.setAcceptDrops()</span></code> . To handle the incoming drag, reimplement <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.dragEnterEvent()</span></code> , <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.dragMoveEvent()</span></code> , <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.dragLeaveEvent()</span></code> , and <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.dropEvent()</span></code> .</p>
<p>See also the <a class="reference internal" href="qtwidgets-graphicsview-dragdroprobot-example.html#drag-and-drop-robot-example"><span class="std std-ref">Drag and Drop Robot</span></a> example for a demonstration of Graphics View’s support for drag and drop operations.</p>
</div></blockquote>
</div>
<div class="section" id="cursors-and-tooltips">
<span id="id16"></span><h2>Cursors and Tooltips<a class="headerlink" href="#cursors-and-tooltips" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Like <a class="reference internal" href="../PySide2/QtWidgets/QWidget.html#PySide2.QtWidgets.QWidget" title="PySide2.QtWidgets.QWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QWidget</span></code></a> , <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsItem.html#PySide2.QtWidgets.QGraphicsItem" title="PySide2.QtWidgets.QGraphicsItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsItem</span></code></a> also supports cursors ( <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.setCursor()</span></code> ), and tooltips ( <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.setToolTip()</span></code> ). The cursors and tooltips are activated by <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsView.html#PySide2.QtWidgets.QGraphicsView" title="PySide2.QtWidgets.QGraphicsView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsView</span></code></a> as the mouse cursor enters the item’s area (detected by calling <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.contains()</span></code> ).</p>
<p>You can also set a default cursor directly on the view by calling <code class="xref py py-func docutils literal"><span class="pre">QGraphicsView.setCursor()</span></code> .</p>
<p>See also the <a class="reference internal" href="qtwidgets-graphicsview-dragdroprobot-example.html#drag-and-drop-robot-example"><span class="std std-ref">Drag and Drop Robot</span></a> example for code that implements tooltips and cursor shape handling.</p>
</div></blockquote>
</div>
<div class="section" id="animation">
<span id="id17"></span><h2>Animation<a class="headerlink" href="#animation" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Graphics View supports animation at several levels. You can easily assemble animation by using the Animation Framework. For that you’ll need your items to inherit from <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsObject.html#PySide2.QtWidgets.QGraphicsObject" title="PySide2.QtWidgets.QGraphicsObject"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsObject</span></code></a> and associate <a class="reference internal" href="../PySide2/QtCore/QPropertyAnimation.html#PySide2.QtCore.QPropertyAnimation" title="PySide2.QtCore.QPropertyAnimation"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QPropertyAnimation</span></code></a> with them. <a class="reference internal" href="../PySide2/QtCore/QPropertyAnimation.html#PySide2.QtCore.QPropertyAnimation" title="PySide2.QtCore.QPropertyAnimation"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QPropertyAnimation</span></code></a> allows to animate any <a class="reference internal" href="../PySide2/QtCore/QObject.html#PySide2.QtCore.QObject" title="PySide2.QtCore.QObject"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QObject</span></code></a> property.</p>
<p>Another option is to create a custom item that inherits from <a class="reference internal" href="../PySide2/QtCore/QObject.html#PySide2.QtCore.QObject" title="PySide2.QtCore.QObject"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QObject</span></code></a> and <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsItem.html#PySide2.QtWidgets.QGraphicsItem" title="PySide2.QtWidgets.QGraphicsItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsItem</span></code></a> . The item can the set up its own timers, and control animations with incremental steps in <code class="xref py py-func docutils literal"><span class="pre">QObject.timerEvent()</span></code> .</p>
<p>A third option, which is mostly available for compatibility with QCanvas in Qt 3, is to <em>advance</em> the scene by calling <code class="xref py py-func docutils literal"><span class="pre">QGraphicsScene.advance()</span></code> , which in turn calls <code class="xref py py-func docutils literal"><span class="pre">QGraphicsItem.advance()</span></code> .</p>
</div></blockquote>
</div>
<div class="section" id="opengl-rendering">
<span id="id18"></span><h2>OpenGL Rendering<a class="headerlink" href="#opengl-rendering" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>To enable OpenGL rendering, you simply set a new <a class="reference internal" href="../PySide2/QtOpenGL/QGLWidget.html#PySide2.QtOpenGL.QGLWidget" title="PySide2.QtOpenGL.QGLWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtOpenGL.QGLWidget</span></code></a> as the viewport of <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsView.html#PySide2.QtWidgets.QGraphicsView" title="PySide2.QtWidgets.QGraphicsView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsView</span></code></a> by calling <code class="xref py py-func docutils literal"><span class="pre">QGraphicsView.setViewport()</span></code> . If you want OpenGL with antialiasing, you need OpenGL sample buffer support (see <code class="xref py py-func docutils literal"><span class="pre">QGLFormat.sampleBuffers()</span></code> ).</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QGraphicsView</span> <span class="n">view</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scene</span><span class="p">);</span>
<span class="n">view</span><span class="o">.</span><span class="n">setViewport</span><span class="p">(</span><span class="n">new</span> <span class="n">QGLWidget</span><span class="p">(</span><span class="n">QGLFormat</span><span class="p">(</span><span class="n">QGL</span><span class="p">::</span><span class="n">SampleBuffers</span><span class="p">)));</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="item-groups">
<span id="id19"></span><h2>Item Groups<a class="headerlink" href="#item-groups" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>By making an item a child of another, you can achieve the most essential feature of item grouping: the items will move together, and all transformations are propagated from parent to child.</p>
<p>In addition, <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsItemGroup.html#PySide2.QtWidgets.QGraphicsItemGroup" title="PySide2.QtWidgets.QGraphicsItemGroup"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsItemGroup</span></code></a> is a special item that combines child event handling with a useful interface for adding and removing items to and from a group. Adding an item to a <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsItemGroup.html#PySide2.QtWidgets.QGraphicsItemGroup" title="PySide2.QtWidgets.QGraphicsItemGroup"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsItemGroup</span></code></a> will keep the item’s original position and transformation, whereas reparenting items in general will cause the child to reposition itself relative to its new parent. For convenience, you can create <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsItemGroup.html#PySide2.QtWidgets.QGraphicsItemGroup" title="PySide2.QtWidgets.QGraphicsItemGroup"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsItemGroup</span></code></a> s through the scene by calling <code class="xref py py-func docutils literal"><span class="pre">QGraphicsScene.createItemGroup()</span></code> .</p>
</div></blockquote>
</div>
<div class="section" id="widgets-and-layouts">
<span id="id20"></span><h2>Widgets and Layouts<a class="headerlink" href="#widgets-and-layouts" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>Qt 4.4 introduced support for geometry and layout-aware items through <a class="reference internal" href="#graphics-view-framework"><span class="std std-ref">QGraphicsWidget</span></a> . This special base item is similar to <a class="reference internal" href="../PySide2/QtWidgets/QWidget.html#PySide2.QtWidgets.QWidget" title="PySide2.QtWidgets.QWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QWidget</span></code></a> , but unlike <a class="reference internal" href="../PySide2/QtWidgets/QWidget.html#PySide2.QtWidgets.QWidget" title="PySide2.QtWidgets.QWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QWidget</span></code></a> , it doesn’t inherit from <a class="reference internal" href="../PySide2/QtGui/QPaintDevice.html#PySide2.QtGui.QPaintDevice" title="PySide2.QtGui.QPaintDevice"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtGui.QPaintDevice</span></code></a> ; rather from <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsItem.html#PySide2.QtWidgets.QGraphicsItem" title="PySide2.QtWidgets.QGraphicsItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsItem</span></code></a> instead. This allows you to write complete widgets with events, signals &amp; slots, size hints and policies, and you can also manage your widgets geometries in layouts through <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsLinearLayout.html#PySide2.QtWidgets.QGraphicsLinearLayout" title="PySide2.QtWidgets.QGraphicsLinearLayout"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsLinearLayout</span></code></a> and <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsGridLayout.html#PySide2.QtWidgets.QGraphicsGridLayout" title="PySide2.QtWidgets.QGraphicsGridLayout"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsGridLayout</span></code></a> .</div></blockquote>
</div>
<div class="section" id="qgraphicswidget">
<span id="id21"></span><h2>QGraphicsWidget<a class="headerlink" href="#qgraphicswidget" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Building on top of <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsItem.html#PySide2.QtWidgets.QGraphicsItem" title="PySide2.QtWidgets.QGraphicsItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsItem</span></code></a> ‘s capabilities and lean footprint, <a class="reference internal" href="#graphics-view-framework"><span class="std std-ref">QGraphicsWidget</span></a> provides the best of both worlds: extra functionality from <a class="reference internal" href="../PySide2/QtWidgets/QWidget.html#PySide2.QtWidgets.QWidget" title="PySide2.QtWidgets.QWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QWidget</span></code></a> , such as the style, font, palette, layout direction, and its geometry, and resolution independence and transformation support from <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsItem.html#PySide2.QtWidgets.QGraphicsItem" title="PySide2.QtWidgets.QGraphicsItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsItem</span></code></a> . Because Graphics View uses real coordinates instead of integers, <a class="reference internal" href="#graphics-view-framework"><span class="std std-ref">QGraphicsWidget</span></a> ‘s geometry functions also operate on <a class="reference internal" href="../PySide2/QtCore/QRectF.html#PySide2.QtCore.QRectF" title="PySide2.QtCore.QRectF"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QRectF</span></code></a> and <a class="reference internal" href="../PySide2/QtCore/QPointF.html#PySide2.QtCore.QPointF" title="PySide2.QtCore.QPointF"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QPointF</span></code></a> . This also applies to frame rects, margins and spacing. With <a class="reference internal" href="#graphics-view-framework"><span class="std std-ref">QGraphicsWidget</span></a> it’s not uncommon to specify contents margins of (0.5, 0.5, 0.5, 0.5), for example. You can create both subwidgets and “top-level” windows; in some cases you can now use Graphics View for advanced MDI applications.</p>
<p>Some of <a class="reference internal" href="../PySide2/QtWidgets/QWidget.html#PySide2.QtWidgets.QWidget" title="PySide2.QtWidgets.QWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QWidget</span></code></a> ‘s properties are supported, including window flags and attributes, but not all. You should refer to <a class="reference internal" href="#graphics-view-framework"><span class="std std-ref">QGraphicsWidget</span></a> ‘s class documentation for a complete overview of what is and what is not supported. For example, you can create decorated windows by passing the <code class="xref py py-attr docutils literal"><span class="pre">Qt.Window</span></code> window flag to <a class="reference internal" href="#graphics-view-framework"><span class="std std-ref">QGraphicsWidget</span></a> ‘s constructor, but Graphics View currently doesn’t support the <code class="xref py py-attr docutils literal"><span class="pre">Qt.Sheet</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">Qt.Drawer</span></code> flags that are common on <span class="xref std std-ref">macOS</span> .</p>
</div></blockquote>
</div>
<div class="section" id="qgraphicslayout">
<span id="id22"></span><h2>QGraphicsLayout<a class="headerlink" href="#qgraphicslayout" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><a class="reference internal" href="#graphics-view-framework"><span class="std std-ref">QGraphicsLayout</span></a> is part of a second-generation layout framework designed specifically for <a class="reference internal" href="#graphics-view-framework"><span class="std std-ref">QGraphicsWidget</span></a> . Its API is very similar to that of <a class="reference internal" href="../PySide2/QtWidgets/QLayout.html#PySide2.QtWidgets.QLayout" title="PySide2.QtWidgets.QLayout"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QLayout</span></code></a> . You can manage widgets and sublayouts inside either <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsLinearLayout.html#PySide2.QtWidgets.QGraphicsLinearLayout" title="PySide2.QtWidgets.QGraphicsLinearLayout"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsLinearLayout</span></code></a> and <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsGridLayout.html#PySide2.QtWidgets.QGraphicsGridLayout" title="PySide2.QtWidgets.QGraphicsGridLayout"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsGridLayout</span></code></a> . You can also easily write your own layout by subclassing <a class="reference internal" href="#graphics-view-framework"><span class="std std-ref">QGraphicsLayout</span></a> yourself, or add your own <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsItem.html#PySide2.QtWidgets.QGraphicsItem" title="PySide2.QtWidgets.QGraphicsItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsItem</span></code></a> items to the layout by writing an adaptor subclass of <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsLayoutItem.html#PySide2.QtWidgets.QGraphicsLayoutItem" title="PySide2.QtWidgets.QGraphicsLayoutItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsLayoutItem</span></code></a> .</div></blockquote>
</div>
<div class="section" id="embedded-widget-support">
<span id="id23"></span><h2>Embedded Widget Support<a class="headerlink" href="#embedded-widget-support" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Graphics View provides seamless support for embedding any widget into the scene. You can embed simple widgets, such as <a class="reference internal" href="../PySide2/QtWidgets/QLineEdit.html#PySide2.QtWidgets.QLineEdit" title="PySide2.QtWidgets.QLineEdit"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QLineEdit</span></code></a> or <a class="reference internal" href="../PySide2/QtWidgets/QPushButton.html#PySide2.QtWidgets.QPushButton" title="PySide2.QtWidgets.QPushButton"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QPushButton</span></code></a> , complex widgets such as <a class="reference internal" href="../PySide2/QtWidgets/QTabWidget.html#PySide2.QtWidgets.QTabWidget" title="PySide2.QtWidgets.QTabWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTabWidget</span></code></a> , and even complete main windows. To embed your widget to the scene, simply call <code class="xref py py-func docutils literal"><span class="pre">QGraphicsScene.addWidget()</span></code> , or create an instance of <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsProxyWidget.html#PySide2.QtWidgets.QGraphicsProxyWidget" title="PySide2.QtWidgets.QGraphicsProxyWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsProxyWidget</span></code></a> to embed your widget manually.</p>
<p>Through <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsProxyWidget.html#PySide2.QtWidgets.QGraphicsProxyWidget" title="PySide2.QtWidgets.QGraphicsProxyWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsProxyWidget</span></code></a> , Graphics View is able to deeply integrate the client widget features including its cursors, tooltips, mouse, tablet and keyboard events, child widgets, animations, pop-ups (e.g., <a class="reference internal" href="../PySide2/QtWidgets/QComboBox.html#PySide2.QtWidgets.QComboBox" title="PySide2.QtWidgets.QComboBox"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QComboBox</span></code></a> or <a class="reference internal" href="../PySide2/QtWidgets/QCompleter.html#PySide2.QtWidgets.QCompleter" title="PySide2.QtWidgets.QCompleter"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QCompleter</span></code></a> ), and the widget’s input focus and activation. <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsProxyWidget.html#PySide2.QtWidgets.QGraphicsProxyWidget" title="PySide2.QtWidgets.QGraphicsProxyWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsProxyWidget</span></code></a> even integrates the embedded widget’s tab order so that you can tab in and out of embedded widgets. You can even embed a new <a class="reference internal" href="../PySide2/QtWidgets/QGraphicsView.html#PySide2.QtWidgets.QGraphicsView" title="PySide2.QtWidgets.QGraphicsView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QGraphicsView</span></code></a> into your scene to provide complex nested scenes.</p>
<p>When transforming an embedded widget, Graphics View makes sure that the widget is transformed resolution independently, allowing the fonts and style to stay crisp when zoomed in. (Note that the effect of resolution independence depends on the style.)</p>
</div></blockquote>
</div>
<div class="section" id="performance">
<span id="id24"></span><h2>Performance<a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div></div></blockquote>
</div>
<div class="section" id="floating-point-instructions">
<span id="id25"></span><h2>Floating Point Instructions<a class="headerlink" href="#floating-point-instructions" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>In order to accurately and quickly apply transformations and effects to items, Graphics View is built with the assumption that the user’s hardware is able to provide reasonable performance for floating point instructions.</p>
<p>Many workstations and desktop computers are equipped with suitable hardware to accelerate this kind of computation, but some embedded devices may only provide libraries to handle mathematical operations or emulate floating point instructions in software.</p>
<p>As a result, certain kinds of effects may be slower than expected on certain devices. It may be possible to compensate for this performance hit by making optimizations in other areas; for example, by using <a class="reference internal" href="#graphics-view-framework"><span class="std std-ref">OpenGL</span></a> to render a scene. However, any such optimizations may themselves cause a reduction in performance if they also rely on the presence of floating point hardware.</p>
</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <p>© 2018 The Qt Company Ltd. Documentation contributions included herein are the copyrights of their respective owners. The documentation provided herein is licensed under the terms of the <a href="http://www.gnu.org/license/fdl.html">GNU Free Documentation License version 1.3</a> as published by the Free Software Foundation. Qt and respective logos are trademarks of The Qt Company Ltd. in Finland and/or other countries worldwide. All other trademarks are property of their respective owners.</p>
    </div></div>
    <div id="footer" class="footer">
    </div>
</div>
  </body>
</html>