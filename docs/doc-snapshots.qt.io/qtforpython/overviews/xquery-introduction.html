
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>A Short Path to XQuery &#8212; Qt for Python (Technology Preview)</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '5.11.0~a1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" title="Search" href="../search.html" />
  <link rel="stylesheet" type="text/css" href="/style/pyside.css" />
  <link rel="icon" type="image/png" href="/style/pyside-32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/style/pyside-16px.png" sizes="16x16" />
  <script type="text/javascript"> wpThemeFolder = 'http://qt.io/wp-content/themes/oneqt'; </script>
  <script type="text/javascript" src="/scripts/main.js"></script>
  <script type="text/javascript" src="/scripts/extras.js"></script>
  <script type="text/javascript">
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-54043535-2', 'qt.io');
    ga('set', 'forceSSL', true);
    ga('send', 'pageview');
  </script>

  </head>
  <body>
<div id="container">
    <div class="header">
        <div class="header_container">
            <header id="navbar">
            </header>
        </div>
    </div>
    <div class="main">
        <div class="main-rounded">
            <div class="navigationbar">
                <ul class="sub-navigation">
                    <li><a href="http://wiki.qt.io/">Wiki</a></li>
                    <li><a href="https://doc.qt.io/">Documentation</a></li>
                    <li><a href="http://forum.qt.io/">Forum</a></li>
                    <li><a href="https://bugreports.qt.io/">Bug Reports</a></li>
                    <li><a href="https://codereview.qt-project.org/">Code Review</a></li>
                </ul>
                <div id="main_title_bar"><h1>Qt Documentation</h1></div>
                <div class="related">
                    <ul>
                        <li><a href="../index.html">Qt for Python (Technology Preview)</a></li> 
                    </ul>
                </div>
            </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">A Short Path to XQuery</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#using-path-expressions-to-match-and-select-items">Using Path Expressions To Match And Select Items</a></li>
<li><a class="reference internal" href="#axis-steps">Axis Steps</a></li>
<li><a class="reference internal" href="#axis-specifiers">Axis Specifiers</a></li>
<li><a class="reference internal" href="#node-tests">Node Tests</a></li>
<li><a class="reference internal" href="#id8">Shorthand Form</a></li>
<li><a class="reference internal" href="#id11">Name Tests</a></li>
<li><a class="reference internal" href="#wildcards-in-name-tests">Wildcards in Name Tests</a></li>
<li><a class="reference internal" href="#using-predicates-in-path-expressions">Using Predicates In Path Expressions</a></li>
<li><a class="reference internal" href="#positional-predicates">Positional Predicates</a></li>
<li><a class="reference internal" href="#boolean-predicates">Boolean Predicates</a></li>
<li><a class="reference internal" href="#id19">Constructing Elements</a></li>
<li><a class="reference internal" href="#element-constructors-are-expressions">Element Constructors are Expressions</a></li>
<li><a class="reference internal" href="#constructing-atomic-values">Constructing Atomic Values</a></li>
<li><a class="reference internal" href="#running-the-cookbook-examples">Running The Cookbook Examples</a></li>
<li><a class="reference internal" href="#further-reading">Further Reading</a></li>
<li><a class="reference internal" href="#faq">FAQ</a></li>
<li><a class="reference internal" href="#why-didn-t-my-path-expression-match-anything">Why didn’t my path expression match anything?</a></li>
<li><a class="reference internal" href="#what-if-my-input-namespace-is-different-from-my-output-namespace">What if my input namespace is different from my output namespace?</a></li>
<li><a class="reference internal" href="#why-doesn-t-my-return-clause-work">Why doesn’t my return clause work?</a></li>
<li><a class="reference internal" href="#why-didn-t-my-expression-get-evaluated">Why didn’t my expression get evaluated?</a></li>
<li><a class="reference internal" href="#my-predicate-is-correct-so-why-doesn-t-it-select-the-right-stuff">My predicate is correct, so why doesn’t it select the right stuff?</a></li>
<li><a class="reference internal" href="#why-doesn-t-my-flwor-behave-as-expected">Why doesn’t my FLWOR behave as expected?</a></li>
<li><a class="reference internal" href="#why-are-my-elements-created-in-the-wrong-order">Why are my elements created in the wrong order?</a></li>
<li><a class="reference internal" href="#in-my-xquery">in my XQuery?</a></li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="a-short-path-to-xquery">
<span id="id1"></span><h1>A Short Path to XQuery<a class="headerlink" href="#a-short-path-to-xquery" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p id="constructing-elements"><span id="empty-method-not-robust"></span><span id="name-tests"></span><span id="shorthand-form"></span><a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> is a language for querying XML data or non-XML data that can be modeled as XML. <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> is specified by the W3C.</p>
</div></blockquote>
<div class="section" id="introduction">
<span id="id2"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Where Java and C++ are <em>statement-based</em> languages, the <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> language is <em>expression-based</em> . The simplest <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> expression is an XML element constructor:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">recipe</span><span class="o">/&gt;</span>
</pre></div>
</div>
<p>This <code class="docutils literal"><span class="pre">&lt;recipe/&gt;</span></code> element is an <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> expression that forms a complete <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> . In fact, this <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> doesn’t actually query anything. It just creates an empty <code class="docutils literal"><span class="pre">&lt;recipe/&gt;</span></code> element in the output. But <a class="reference internal" href="#a-short-path-to-xquery"><span class="std std-ref">constructing new elements in an XQuery</span></a> is often necessary.</p>
<p>An <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> expression can also be enclosed in curly braces and embedded in another <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> expression. This <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> has a document expression embedded in a node expression:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">html</span> <span class="n">xmlns</span><span class="o">=</span><span class="s2">&quot;http://www.w3.org/1999/xhtml/&quot;</span>
      <span class="n">xml</span><span class="p">:</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;{doc(&quot;</span><span class="n">other</span><span class="o">.</span><span class="n">html</span><span class="s2">&quot;)/html/@xml:id}&quot;</span><span class="o">/&gt;</span>
</pre></div>
</div>
<p>It creates a new <code class="docutils literal"><span class="pre">&lt;html&gt;</span></code> element in the output and sets its <code class="docutils literal"><span class="pre">id</span></code> attribute to be the <code class="docutils literal"><span class="pre">id</span></code> attribute from an <code class="docutils literal"><span class="pre">&lt;html&gt;</span></code> element in the <code class="docutils literal"><span class="pre">other.html</span></code> file.</p>
</div></blockquote>
</div>
<div class="section" id="using-path-expressions-to-match-and-select-items">
<span id="id3"></span><h2>Using Path Expressions To Match And Select Items<a class="headerlink" href="#using-path-expressions-to-match-and-select-items" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>In C++ and Java, we write nested <code class="docutils literal"><span class="pre">for</span></code> loops and recursive functions to traverse XML trees in search of elements of interest. In <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> , we write these iterative and recursive algorithms with <em>path expressions</em> .</p>
<p>A path expression looks somewhat like a typical <em>file pathname</em> for locating a file in a hierarchical file system. It is a sequence of one or more <em>steps</em> separated by slash ‘/’ or double slash ‘//’. Although path expressions are used for traversing XML trees, not file systems, in Qt XML Patterns we can model a file system to look like an XML tree, so in Qt XML Patterns we can use <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> to traverse a file system. See the <a class="reference internal" href="qtxmlpatterns-filetree-example.html#file-system-example"><span class="std std-ref">file system example</span></a> .</p>
<p>Think of a path expression as an algorithm for traversing an XML tree to find and collect items of interest. This algorithm is evaluated by evaluating each step moving from left to right through the sequence. A step is evaluated with a set of input items (nodes and atomic values), sometimes called the <em>focus</em> . The step is evaluated for each item in the focus. These evaluations produce a new set of items, called the <em>result</em> , which then becomes the focus that is passed to the next step. Evaluation of the final step produces the final result, which is the result of the <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> . The items in the result set are presented in document order and without duplicates.</p>
<p>With Qt XML Patterns, a standard way to present the initial focus to a query is to call <code class="xref py py-func docutils literal"><span class="pre">QXmlQuery.setFocus()</span></code> . Another common way is to let the <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> itself create the initial focus by using the first step of the path expression to call the <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> <code class="docutils literal"><span class="pre">doc()</span></code> function. The <code class="docutils literal"><span class="pre">doc()</span></code> function loads an XML document and returns the <em>document node</em> . Note that the document node is <em>not</em> the same as the <em>document element</em> . The <em>document node</em> is a node constructed in memory, when the document is loaded. It represents the entire XML document, not the document element. The <em>document element</em> is the single, top-level XML element in the file. The <code class="docutils literal"><span class="pre">doc()</span></code> function returns the document node, which becomes the singleton node in the initial focus set. The document node will have one child node, and that child node will represent the document element. Consider the following <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">//</span><span class="n">recipe</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">doc()</span></code> function loads the <code class="docutils literal"><span class="pre">cookbook.xml</span></code> file and returns the document node. The document node then becomes the focus for the next step <code class="docutils literal"><span class="pre">//recipe</span></code> . Here the double slash means select all <code class="docutils literal"><span class="pre">&lt;recipe&gt;</span></code> elements found below the document node, regardless of where they appear in the document tree. The query selects all <code class="docutils literal"><span class="pre">&lt;recipe&gt;</span></code> elements in the cookbook. See <a class="reference internal" href="#a-short-path-to-xquery"><span class="std std-ref">Running The Cookbook Examples</span></a> for instructions on how to run this query (and most of the ones that follow) from the command line.</p>
<p>Conceptually, evaluation of the steps of a path expression is similar to iterating through the same number of nested <em>for</em> loops. Consider the following <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> , which builds on the previous one:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">//</span><span class="n">recipe</span><span class="o">/</span><span class="n">title</span>
</pre></div>
</div>
<p>This <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> is a single path expression composed of three steps. The first step creates the initial focus by calling the <code class="docutils literal"><span class="pre">doc()</span></code> function. We can paraphrase what the query engine does at each step:</p>
<ol class="arabic simple">
<li>for each node in the initial focus (the document node)…</li>
<li>for each descendant node that is a <code class="docutils literal"><span class="pre">&lt;recipe&gt;</span></code> element…</li>
<li>collect the child nodes that are <code class="docutils literal"><span class="pre">&lt;title&gt;</span></code> elements.</li>
</ol>
<p>Again the double slash means select all the <code class="docutils literal"><span class="pre">&lt;recipe&gt;</span></code> elements in the document. The single slash before the <code class="docutils literal"><span class="pre">&lt;title&gt;</span></code> element means select only those <code class="docutils literal"><span class="pre">&lt;title&gt;</span></code> elements that are <em>child</em> elements of a <code class="docutils literal"><span class="pre">&lt;recipe&gt;</span></code> element (i.e. not grandchildren, etc). The <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> evaluates to a final result set containing the <code class="docutils literal"><span class="pre">&lt;title&gt;</span></code> element of each <code class="docutils literal"><span class="pre">&lt;recipe&gt;</span></code> element in the cookbook.</p>
</div></blockquote>
</div>
<div class="section" id="axis-steps">
<span id="id4"></span><h2>Axis Steps<a class="headerlink" href="#axis-steps" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The most common kind of path step is called an <em>axis step</em> , which tells the query engine which way to navigate from the context node, and which test to perform when it encounters nodes along the way. An axis step has two parts, an <em>axis specifier</em> , and a <em>node test</em> . Conceptually, evaluation of an axis step proceeds as follows: For each node in the focus set, the query engine navigates out from the node along the specified axis and applies the node test to each node it encounters. The nodes selected by the node test are collected in the result set, which becomes the focus set for the next step.</p>
<p>In the example <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> above, the second and third steps are both axis steps. Both apply the <code class="docutils literal"><span class="pre">element(name)</span></code> node test to nodes encountered while traversing along some axis. But in this example, the two axis steps are written in a <a class="reference internal" href="#a-short-path-to-xquery"><span class="std std-ref">shorthand form</span></a> , where the axis specifier and the node test are not written explicitly but are implied. XQueries are normally written in this shorthand form, but they can also be written in the longhand form. If we rewrite the <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> in the longhand form, it looks like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">descendant</span><span class="o">-</span><span class="ow">or</span><span class="o">-</span><span class="bp">self</span><span class="p">::</span><span class="n">element</span><span class="p">(</span><span class="n">recipe</span><span class="p">)</span><span class="o">/</span><span class="n">child</span><span class="p">::</span><span class="n">element</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
</pre></div>
</div>
<p>The two axis steps have been expanded. The first step (<code class="docutils literal"><span class="pre">//recipe</span></code> ) has been rewritten as <code class="docutils literal"><span class="pre">/descendant-or-self::element(recipe)</span></code> , where <code class="docutils literal"><span class="pre">descendant-or-self::</span></code> is the axis specifier and <code class="docutils literal"><span class="pre">element(recipe)</span></code> is the node test. The second step (<code class="docutils literal"><span class="pre">title</span></code> ) has been rewritten as <code class="docutils literal"><span class="pre">/child::element(title)</span></code> , where <code class="docutils literal"><span class="pre">child::</span></code> is the axis specifier and <code class="docutils literal"><span class="pre">element(title)</span></code> is the node test. The output of the expanded <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> will be exactly the same as the output of the shorthand form.</p>
<p>To create an axis step, concatenate an axis specifier and a node test. The following sections list the axis specifiers and node tests that are available.</p>
</div></blockquote>
</div>
<div class="section" id="axis-specifiers">
<span id="id5"></span><h2>Axis Specifiers<a class="headerlink" href="#axis-specifiers" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>An axis specifier defines the direction you want the query engine to take, when it navigates away from the context node. Qt XML Patterns supports the following axes.</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Axis Specifier</td>
<td>refers to the axis containing…</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">self::</span></code></td>
<td>the context node itself</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">attribute::</span></code></td>
<td>all attribute nodes of the context node</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">child::</span></code></td>
<td>all child nodes of the context node (not attributes)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">descendant::</span></code></td>
<td>all descendants of the context node (children, grandchildren, etc)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">descendant-or-self::</span></code></td>
<td>all nodes in <code class="docutils literal"><span class="pre">descendant</span></code> + <code class="docutils literal"><span class="pre">self</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">parent::</span></code></td>
<td>the parent node of the context node, or empty if there is no parent</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">ancestor::</span></code></td>
<td>all ancestors of the context node (parent, grandparent, etc)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">ancestor-or-self::</span></code></td>
<td>all nodes in <code class="docutils literal"><span class="pre">ancestor</span></code> + <code class="docutils literal"><span class="pre">self</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">following::</span></code></td>
<td>all nodes in the tree containing the context node, <em>not</em> including <code class="docutils literal"><span class="pre">descendant</span></code> , <em>and</em> that follow the context node in the document</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">preceding::</span></code></td>
<td>all nodes in the tree contianing the context node, <em>not</em> including <code class="docutils literal"><span class="pre">ancestor</span></code> , <em>and</em> that precede the context node in the document</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">following-sibling::</span></code></td>
<td>all children of the context node’s <code class="docutils literal"><span class="pre">parent</span></code> that follow the context node in the document</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">preceding-sibling::</span></code></td>
<td>all children of the context node’s <code class="docutils literal"><span class="pre">parent</span></code> that precede the context node in the document</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="node-tests">
<span id="id6"></span><h2>Node Tests<a class="headerlink" href="#node-tests" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>A node test is a conditional expression that must be true for a node if the node is to be selected by the axis step. The conditional expression can test just the <em>kind</em> of node, or it can test the <em>kind</em> of node and the <em>name</em> of the node. The <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> specification for node tests also defines a third condition, the node’s <em>Schema Type</em> , but schema type tests are not supported in Qt XML Patterns.</p>
<p>Qt XML Patterns supports the following node tests. The tests that have a <code class="docutils literal"><span class="pre">name</span></code> parameter test the node’s name in addition to its <em>kind</em> and are often called the <a class="reference internal" href="#a-short-path-to-xquery"><span class="std std-ref">Name Tests</span></a> .</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Node Test</td>
<td>matches all…</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">node()</span></code></td>
<td>nodes of any kind</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">text()</span></code></td>
<td>text nodes</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">comment()</span></code></td>
<td>comment nodes</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">element()</span></code></td>
<td>element nodes (same as star: *)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">element(name)</span></code></td>
<td>element nodes named <code class="docutils literal"><span class="pre">name</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">attribute()</span></code></td>
<td>attribute nodes</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">attribute(name)</span></code></td>
<td>attribute nodes named <code class="docutils literal"><span class="pre">name</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">processing-instruction()</span></code></td>
<td>processing-instructions</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">processing-instruction(name)</span></code></td>
<td>processing-instructions named <code class="docutils literal"><span class="pre">name</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">document-node()</span></code></td>
<td>document nodes (there is only one)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">document-node(element(name))</span></code></td>
<td>document node with document element <code class="docutils literal"><span class="pre">name</span></code></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="id8">
<span id="id9"></span><h2>Shorthand Form<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Writing axis steps using the longhand form with axis specifiers and node tests is semantically clear but syntactically verbose. The shorthand form is easy to learn and, once you learn it, just as easy to read. In the shorthand form, the axis specifier and node test are implied by the syntax. XQueries are normally written in the shorthand form. Here is a table of some frequently used shorthand forms:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="26%" />
<col width="60%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Shorthand syntax</td>
<td>Short for…</td>
<td>matches all…</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">name</span></code></td>
<td><code class="docutils literal"><span class="pre">child::element(name)</span></code></td>
<td>child nodes that are <code class="docutils literal"><span class="pre">name</span></code> elements</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">*</span></code></td>
<td><code class="docutils literal"><span class="pre">child::element()</span></code></td>
<td>child nodes that are elements (<code class="docutils literal"><span class="pre">node()</span></code> matches <em>all</em> child nodes)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">..</span></code></td>
<td><code class="docutils literal"><span class="pre">parent::node()</span></code></td>
<td>parent nodes (there is only one)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&#64;*</span></code></td>
<td><code class="docutils literal"><span class="pre">attribute::attribute()</span></code></td>
<td>attribute nodes</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&#64;name</span></code></td>
<td><code class="docutils literal"><span class="pre">attribute::attribute(name)</span></code></td>
<td><code class="docutils literal"><span class="pre">name</span></code> attributes</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">//</span></code></td>
<td><code class="docutils literal"><span class="pre">descendant-or-self::node()</span></code></td>
<td>descendent nodes (when used instead of ‘/’)</td>
</tr>
</tbody>
</table>
<p>The <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> language specification has a more detailed section on the shorthand form, which it calls the abbreviated syntax. More examples of path expressions written in the shorthand form are found there. There is also a section listing examples of path expressions written in the longhand form.</p>
</div></blockquote>
</div>
<div class="section" id="id11">
<span id="id12"></span><h2>Name Tests<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The name tests are the <a class="reference internal" href="#a-short-path-to-xquery"><span class="std std-ref">Node Tests</span></a> that have the <code class="docutils literal"><span class="pre">name</span></code> parameter. A name test must match the node <em>name</em> in addition to the node <em>kind</em> . We have already seen name tests used:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">//</span><span class="n">recipe</span><span class="o">/</span><span class="n">title</span>
</pre></div>
</div>
<p>In this path expression, both <code class="docutils literal"><span class="pre">recipe</span></code> and <code class="docutils literal"><span class="pre">title</span></code> are name tests written in the shorthand form. <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> resolves these names (QNames) to their expanded form using whatever namespace declarations it knows about. Resolving a name to its expanded form means replacing its namespace prefix, if one is present (there aren’t any present in the example), with a namespace URI. The expanded name then consists of the namespace URI and the local name.</p>
<p>But the names in the example above don’t have namespace prefixes, because we didn’t include a namespace declaration in our <code class="docutils literal"><span class="pre">cookbook.xml</span></code> file. However, we will often use <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> to query XML documents that use namespaces. Forgetting to declare the correct namespace(s) in an <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> is a common cause of <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> failures. Let’s add a <em>default</em> namespace to <code class="docutils literal"><span class="pre">cookbook.xml</span></code> now. Change the <em>document element</em> in <code class="docutils literal"><span class="pre">cookbook.xml</span></code> from:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">cookbook</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>to…</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">cookbook</span> <span class="n">xmlns</span><span class="o">=</span><span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>This is called a <em>default namespace</em> declaration because it doesn’t include a namespace prefix. By including this default namespace declaration in the document element, we mean that all unprefixed <em>element</em> names in the document, including the document element itself (<code class="docutils literal"><span class="pre">cookbook</span></code> ), are automatically in the default namespace <code class="docutils literal"><span class="pre">http://cookbook/namespace</span></code> . Note that unprefixed <em>attribute</em> names are not affected by the default namespace declaration. They are always considered to be in <em>no namespace</em> . Note also that the URL we choose as our namespace URI need not refer to an actual location, and doesn’t refer to one in this case. But click on <a class="reference external" href="http://www.w3.org/XML/1998/namespace">http://www.w3.org/XML/1998/namespace</a>, for example, which is the namespace URI for elements and attributes prefixed with <code class="docutils literal"><span class="pre">xml:</span></code> .</p>
<p>Now when we try to run the previous <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> example, no output is produced! The path expression no longer matches anything in the cookbook file because our <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> doesn’t yet know about the namespace declaration we added to the cookbook document. There are two ways we can declare the namespace in the <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> . We can give it a <em>namespace prefix</em> (e.g. <code class="docutils literal"><span class="pre">c</span></code> for cookbook) and prefix each name test with the namespace prefix:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">namespace</span> <span class="n">c</span> <span class="o">=</span> <span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="p">;</span>
<span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">//</span><span class="n">c</span><span class="p">:</span><span class="n">recipe</span><span class="o">/</span><span class="n">c</span><span class="p">:</span><span class="n">title</span>
</pre></div>
</div>
<p>Or we can declare the namespace to be the <em>default element namespace</em> , and then we can still run the original <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">default</span> <span class="n">element</span> <span class="n">namespace</span> <span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="p">;</span>
<span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">//</span><span class="n">recipe</span><span class="o">/</span><span class="n">title</span>
</pre></div>
</div>
<p>Both methods will work and produce the same output, all the <code class="docutils literal"><span class="pre">&lt;title&gt;</span></code> elements:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">title</span> <span class="n">xmlns</span><span class="o">=</span><span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="o">&gt;</span><span class="n">Quick</span> <span class="ow">and</span> <span class="n">Easy</span> <span class="n">Mushroom</span> <span class="n">Soup</span><span class="o">&lt;/</span><span class="n">title</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">title</span> <span class="n">xmlns</span><span class="o">=</span><span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="o">&gt;</span><span class="n">Cheese</span> <span class="n">on</span> <span class="n">Toast</span><span class="o">&lt;/</span><span class="n">title</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">title</span> <span class="n">xmlns</span><span class="o">=</span><span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="o">&gt;</span><span class="n">Hard</span><span class="o">-</span><span class="n">Boiled</span> <span class="n">Eggs</span><span class="o">&lt;/</span><span class="n">title</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>But note how the output is slightly different from the output we saw before we added the default namespace declaration to the cookbook file. Qt XML Patterns automatically includes the correct namespace attribute in each <code class="docutils literal"><span class="pre">&lt;title&gt;</span></code> element in the output. When Qt XML Patterns loads a document and expands a QName, it creates an instance of <a class="reference internal" href="../PySide2/QtXmlPatterns/QXmlName.html#PySide2.QtXmlPatterns.QXmlName" title="PySide2.QtXmlPatterns.QXmlName"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtXmlPatterns.QXmlName</span></code></a> , which retains the namespace prefix along with the namespace URI and the local name. See <a class="reference internal" href="../PySide2/QtXmlPatterns/QXmlName.html#PySide2.QtXmlPatterns.QXmlName" title="PySide2.QtXmlPatterns.QXmlName"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtXmlPatterns.QXmlName</span></code></a> for further details.</p>
<p>One thing to keep in mind from this namespace discussion, whether you run XQueries in a Qt program using Qt XML Patterns, or you run them from the command line using xmlpatterns, is that if you don’t get the output you expect, it might be because the data you are querying uses namespaces, but you didn’t declare those namespaces in your <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> .</p>
</div></blockquote>
</div>
<div class="section" id="wildcards-in-name-tests">
<span id="id13"></span><h2>Wildcards in Name Tests<a class="headerlink" href="#wildcards-in-name-tests" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The wildcard <code class="docutils literal"><span class="pre">'*'</span></code> can be used in a name test. To find all the attributes in the cookbook but select only the ones in the <code class="docutils literal"><span class="pre">xml</span></code> namespace, use the <code class="docutils literal"><span class="pre">xml:</span></code> namespace prefix but replace the <em>local name</em> (the attribute name) with the wildcard:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">//</span><span class="nd">@xml</span><span class="p">:</span><span class="o">*</span>
</pre></div>
</div>
<p>Oops! If you save this <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> in <code class="docutils literal"><span class="pre">file.xq</span></code> and run it through <code class="docutils literal"><span class="pre">xmlpatterns</span></code> , it doesn’t work. You get an error message instead, something like this: <em>Error SENR0001 in file:///…file.xq, at line 1, column 1: Attribute xml:id can’t be serialized because it appears at the top level.</em> The <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> actually ran correctly. It selected a bunch of <code class="docutils literal"><span class="pre">xml:id</span></code> attributes and put them in the result set. But then <code class="docutils literal"><span class="pre">xmlpatterns</span></code> sent the result set to a <a class="reference internal" href="../PySide2/QtXmlPatterns/QXmlSerializer.html#PySide2.QtXmlPatterns.QXmlSerializer" title="PySide2.QtXmlPatterns.QXmlSerializer"><code class="xref py py-class docutils literal"><span class="pre">serializer</span></code></a> , which tried to output it as well-formed XML. Since the result set contains only attributes and attributes alone are not well-formed XML, the <a class="reference internal" href="../PySide2/QtXmlPatterns/QXmlSerializer.html#PySide2.QtXmlPatterns.QXmlSerializer" title="PySide2.QtXmlPatterns.QXmlSerializer"><code class="xref py py-class docutils literal"><span class="pre">serializer</span></code></a> reports a serialization error.</p>
<p>Fear not. <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> can do more than just find and select elements and attributes. It can <a class="reference internal" href="#a-short-path-to-xquery"><span class="std std-ref">construct new ones on the fly</span></a> as well, which is what we need to do here if we want <code class="docutils literal"><span class="pre">xmlpatterns</span></code> to let us see the attributes we selected. The example above and the ones below are revisited in the <a class="reference internal" href="#a-short-path-to-xquery"><span class="std std-ref">Constructing Elements</span></a> section. You can jump ahead to see the modified examples now, and then come back, or you can press on from here.</p>
<p>To find all the <code class="docutils literal"><span class="pre">name</span></code> attributes in the cookbook and select them all regardless of their namespace, replace the namespace prefix with the wildcard and write <code class="docutils literal"><span class="pre">name</span></code> (the attribute name) as the local name:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">//@*</span><span class="p">:</span><span class="n">name</span>
</pre></div>
</div>
<p>To find and select all the attributes of the <em>document element</em> in the cookbook, replace the entire name test with the wildcard:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">default</span> <span class="n">element</span> <span class="n">namespace</span> <span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="p">;</span>
<span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">cookbook</span><span class="o">/@*</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="using-predicates-in-path-expressions">
<span id="id14"></span><h2>Using Predicates In Path Expressions<a class="headerlink" href="#using-predicates-in-path-expressions" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Predicates can be used to further filter the nodes selected by a path expression. A predicate is an expression in square brackets (‘[‘ and ‘]’) that either returns a boolean value or a number. A predicate can appear at the end of any path step in a path expression. The predicate is applied to each node in the focus set. If a node passes the filter, the node is included in the result set. The query below selects the recipe element that has the <code class="docutils literal"><span class="pre">&lt;title&gt;</span></code> element <code class="docutils literal"><span class="pre">&quot;Hard-Boiled</span> <span class="pre">Eggs&quot;</span></code> .</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">default</span> <span class="n">element</span> <span class="n">namespace</span> <span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="p">;</span>
<span class="n">doc</span><span class="p">(</span><span class="s2">&quot;cookbook.xml&quot;</span><span class="p">)</span><span class="o">/</span><span class="n">cookbook</span><span class="o">/</span><span class="n">recipe</span><span class="p">[</span><span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;Hard-Boiled Eggs&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>The dot expression (‘.’) can be used in predicates and path expressions to refer to the current context node. The following query uses the dot expression to refer to the current <code class="docutils literal"><span class="pre">&lt;method&gt;</span></code> element. The query selects the empty <code class="docutils literal"><span class="pre">&lt;method&gt;</span></code> elements from the cookbook.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">default</span> <span class="n">element</span> <span class="n">namespace</span> <span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="p">;</span>
<span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">//</span><span class="n">method</span><span class="p">[</span><span class="n">string</span><span class="o">-</span><span class="n">length</span><span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that passing the dot expression to the string- <a class="reference internal" href="stylesheet-reference.html#qt-style-sheets-reference"><span class="std std-ref">length()</span></a> function is optional. When string- <a class="reference internal" href="stylesheet-reference.html#qt-style-sheets-reference"><span class="std std-ref">length()</span></a> is called with no parameter, the context node is assumed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">default</span> <span class="n">element</span> <span class="n">namespace</span> <span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="p">;</span>
<span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">//</span><span class="n">method</span><span class="p">[</span><span class="n">string</span><span class="o">-</span><span class="n">length</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Actually, selecting an empty <code class="docutils literal"><span class="pre">&lt;method&gt;</span></code> element might not be very useful by itself. It doesn’t tell you which recipe has the empty method:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">method</span> <span class="n">xmlns</span><span class="o">=</span><span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="o">/&gt;</span>
</pre></div>
</div>
<p id="id15">What you probably want to see instead are the <code class="docutils literal"><span class="pre">&lt;recipe&gt;</span></code> elements that have empty <code class="docutils literal"><span class="pre">&lt;method&gt;</span></code> elements:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">default</span> <span class="n">element</span> <span class="n">namespace</span> <span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="p">;</span>
<span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">//</span><span class="n">recipe</span><span class="p">[</span><span class="n">string</span><span class="o">-</span><span class="n">length</span><span class="p">(</span><span class="n">method</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>The predicate uses the string- <a class="reference internal" href="stylesheet-reference.html#qt-style-sheets-reference"><span class="std std-ref">length()</span></a> function to test the length of each <code class="docutils literal"><span class="pre">&lt;method&gt;</span></code> element in each <code class="docutils literal"><span class="pre">&lt;recipe&gt;</span></code> element found by the node test. If a <code class="docutils literal"><span class="pre">&lt;method&gt;</span></code> contains no text, the predicate evaluates to <code class="docutils literal"><span class="pre">true</span></code> and the <code class="docutils literal"><span class="pre">&lt;recipe&gt;</span></code> element is selected. If the method contains some text, the predicate evaluates to <code class="docutils literal"><span class="pre">false</span></code> , and the <code class="docutils literal"><span class="pre">&lt;recipe&gt;</span></code> element is discarded. The output is the entire recipe that has no instructions for preparation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">recipe</span> <span class="n">xmlns</span><span class="o">=</span><span class="s2">&quot;http://cookbook/namespace&quot;</span> <span class="n">xml</span><span class="p">:</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;HardBoiledEggs&quot;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">title</span><span class="o">&gt;</span><span class="n">Hard</span><span class="o">-</span><span class="n">Boiled</span> <span class="n">Eggs</span><span class="o">&lt;/</span><span class="n">title</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">ingredient</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Eggs&quot;</span> <span class="n">quantity</span><span class="o">=</span><span class="s2">&quot;3&quot;</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;eggs&quot;</span><span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="n">time</span> <span class="n">quantity</span><span class="o">=</span><span class="s2">&quot;3&quot;</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;minutes&quot;</span><span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="n">method</span><span class="o">/&gt;</span>
<span class="o">&lt;/</span><span class="n">recipe</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The astute reader will have noticed that this use of <code class="docutils literal"><span class="pre">string-length()</span></code> to find an empty element is unreliable. It works in this case, because the method element is written as <code class="docutils literal"><span class="pre">&lt;method/&gt;</span></code> , guaranteeing that its string length will be 0. It will still work if the method element is written as <code class="docutils literal"><span class="pre">&lt;method&gt;&lt;/method&gt;</span></code> , but it will fail if there is any whitespace between the opening and ending <code class="docutils literal"><span class="pre">&lt;method&gt;</span></code> tags. A more robust way to find the recipes with empty methods is presented in the section on <a class="reference internal" href="#a-short-path-to-xquery"><span class="std std-ref">Boolean Predicates</span></a> .</p>
<p>There are many more functions and operators defined for <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> and XPath. They are all documented in the specification.</p>
</div></blockquote>
</div>
<div class="section" id="positional-predicates">
<span id="id16"></span><h2>Positional Predicates<a class="headerlink" href="#positional-predicates" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Predicates are often used to filter items based on their position in a sequence. For path expressions processing items loaded from XML documents, the normal sequence is document order. This query returns the second <code class="docutils literal"><span class="pre">&lt;recipe&gt;</span></code> element in the <code class="docutils literal"><span class="pre">cookbook.xml</span></code> file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">default</span> <span class="n">element</span> <span class="n">namespace</span> <span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="p">;</span>
<span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">cookbook</span><span class="o">/</span><span class="n">recipe</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>The other frequently used positional function is last(), which returns the numeric position of the last item in the focus set. Stated another way, last() returns the size of the focus set. This query returns the last recipe in the cookbook:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">default</span> <span class="n">element</span> <span class="n">namespace</span> <span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="p">;</span>
<span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">cookbook</span><span class="o">/</span><span class="n">recipe</span><span class="p">[</span><span class="n">last</span><span class="p">()]</span>
</pre></div>
</div>
<p>And this query returns the next to last <code class="docutils literal"><span class="pre">&lt;recipe&gt;</span></code> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">default</span> <span class="n">element</span> <span class="n">namespace</span> <span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="p">;</span>
<span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">cookbook</span><span class="o">/</span><span class="n">recipe</span><span class="p">[</span><span class="n">last</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="boolean-predicates">
<span id="id17"></span><h2>Boolean Predicates<a class="headerlink" href="#boolean-predicates" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The other kind of predicate evaluates to <em>true</em> or <em>false</em> . A boolean predicate takes the value of its expression and determines its <em>effective boolean value</em> according to the following rules:</p>
<ul class="simple">
<li>An expression that evaluates to a single node is <code class="docutils literal"><span class="pre">true</span></code>.</li>
<li>An expression that evaluates to a string is <code class="docutils literal"><span class="pre">false</span></code> if the string is empty and <code class="docutils literal"><span class="pre">true</span></code> if the string is not empty.</li>
<li>An expression that evaluates to a boolean value (i.e. type <code class="docutils literal"><span class="pre">xs:boolean</span></code>) is that value.</li>
<li>If the expression evaluates to anything else, it’s an error (e.g. type <code class="docutils literal"><span class="pre">xs:date</span></code>).</li>
</ul>
<p>We have already seen some boolean predicates in use. Earlier, we saw a <em>not so robust</em> way to find the <a class="reference internal" href="#a-short-path-to-xquery"><span class="std std-ref">recipes that have no instructions</span></a> . <code class="docutils literal"><span class="pre">[string-length(method)</span> <span class="pre">=</span> <span class="pre">0]</span></code> is a boolean predicate that would fail in the example if the empty method element was written with both opening and closing tags and there was whitespace between the tags. Here is a more robust way that uses a different boolean predicate.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">default</span> <span class="n">element</span> <span class="n">namespace</span> <span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="p">;</span>
<span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">cookbook</span><span class="o">/</span><span class="n">recipe</span><span class="p">[</span><span class="n">method</span><span class="p">[</span><span class="n">empty</span><span class="p">(</span><span class="n">step</span><span class="p">)]]</span>
</pre></div>
</div>
<p>This one uses the empty() and function to test whether the method contains any steps. If the method contains no steps, then <code class="docutils literal"><span class="pre">empty(step)</span></code> will return <code class="docutils literal"><span class="pre">true</span></code> , and hence the predicate will evaluate to <code class="docutils literal"><span class="pre">true</span></code> .</p>
<p>But even that version isn’t foolproof. Suppose the method does contain steps, but all the steps themselves are empty. That’s still a case of a recipe with no instructions that won’t be detected. There is a better way:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">default</span> <span class="n">element</span> <span class="n">namespace</span> <span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="p">;</span>
<span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">cookbook</span><span class="o">/</span><span class="n">recipe</span><span class="p">[</span><span class="ow">not</span><span class="p">(</span><span class="n">normalize</span><span class="o">-</span><span class="n">space</span><span class="p">(</span><span class="n">method</span><span class="p">))]</span>
</pre></div>
</div>
<p>This version uses the not and normalize-space() functions. <code class="docutils literal"><span class="pre">normalize-space(method))</span></code> returns the contents of the method element as a string, but with all the whitespace normalized, i.e., the string value of each <code class="docutils literal"><span class="pre">&lt;step&gt;</span></code> element will have its whitespace normalized, and then all the normalized step values will be concatenated. If that string is empty, then <code class="docutils literal"><span class="pre">not()</span></code> returns <code class="docutils literal"><span class="pre">true</span></code> and the predicate is <code class="docutils literal"><span class="pre">true</span></code> .</p>
<p>We can also use the position() function in a comparison to inspect positions with conditional logic. The position() function returns the position index of the current context item in the sequence of items:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">default</span> <span class="n">element</span> <span class="n">namespace</span> <span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="p">;</span>
<span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">cookbook</span><span class="o">/</span><span class="n">recipe</span><span class="p">[</span><span class="n">position</span><span class="p">()</span> <span class="o">=</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that the first position in the sequence is position 1, not 0. We can also select <em>all</em> the recipes after the first one:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">default</span> <span class="n">element</span> <span class="n">namespace</span> <span class="s2">&quot;http://cookbook/namespace&quot;</span><span class="p">;</span>
<span class="n">doc</span><span class="p">(</span><span class="s1">&#39;cookbook.xml&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">cookbook</span><span class="o">/</span><span class="n">recipe</span><span class="p">[</span><span class="n">position</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id19">
<span id="id20"></span><h2>Constructing Elements<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>In the section about <a class="reference internal" href="#a-short-path-to-xquery"><span class="std std-ref">using wildcards in name tests</span></a> , we saw three simple example XQueries, each of which selected a different list of XML attributes from the cookbook. We couldn’t use <code class="docutils literal"><span class="pre">xmlpatterns</span></code> to run these queries, however, because <code class="docutils literal"><span class="pre">xmlpatterns</span></code> sends the <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> results to a <a class="reference internal" href="../PySide2/QtXmlPatterns/QXmlSerializer.html#PySide2.QtXmlPatterns.QXmlSerializer" title="PySide2.QtXmlPatterns.QXmlSerializer"><code class="xref py py-class docutils literal"><span class="pre">serializer</span></code></a> , which expects to serialize the results as well-formed XML. Since a list of XML attributes by itself is not well-formed XML, the serializer reported an error for each <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> .</p>
<p>Since an attribute must appear in an element, for each attribute in the result set, we must create an XML element. We can do that using a <em>for</em> clause with a bound variable, and a <em>return</em> clause with an element constructor:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>for $i in doc(&quot;cookbook.xml&quot;)//@xml:*
return &lt;p&gt;{$i}&lt;/p&gt;
</pre></div>
</div>
<p>The <em>for</em> clause produces a sequence of attribute nodes from the result of the path expression. Each attribute node in the sequence is bound to the variable <code class="docutils literal"><span class="pre">$i</span></code> . The <em>return</em> clause then constructs a <code class="docutils literal"><span class="pre">&lt;p&gt;</span></code> element around the attribute node. Here is the output:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">p</span> <span class="n">xml</span><span class="p">:</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;MushroomSoup&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">p</span> <span class="n">xml</span><span class="p">:</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;CheeseOnToast&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">p</span> <span class="n">xml</span><span class="p">:</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;HardBoiledEggs&quot;</span><span class="o">/&gt;</span>
</pre></div>
</div>
<p>The output contains one <code class="docutils literal"><span class="pre">&lt;p&gt;</span></code> element for each <code class="docutils literal"><span class="pre">xml:id</span></code> attribute in the cookbook. Note that <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> puts each attribute in the right place in its <code class="docutils literal"><span class="pre">&lt;p&gt;</span></code> element, despite the fact that in the <em>return</em> clause, the <code class="docutils literal"><span class="pre">$i</span></code> variable is positioned as if it is meant to become <code class="docutils literal"><span class="pre">&lt;p&gt;</span></code> element content.</p>
<p>The other two examples from the <a class="reference internal" href="#a-short-path-to-xquery"><span class="std std-ref">wildcard</span></a> section can be rewritten the same way. Here is the <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> that selects all the <code class="docutils literal"><span class="pre">name</span></code> attributes, regardless of namespace:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>for $i in doc(&quot;cookbook.xml&quot;)//@*:name
return &lt;p&gt;{$i}&lt;/p&gt;
</pre></div>
</div>
<p>And here is its output:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">p</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Fresh mushrooms&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">p</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Garlic&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">p</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Olive oil&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">p</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Milk&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">p</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Water&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">p</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Cream&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">p</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Vegetable soup cube&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">p</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Ground black pepper&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">p</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Dried parsley&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">p</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Bread&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">p</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Cheese&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">p</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Eggs&quot;</span><span class="o">/&gt;</span>
</pre></div>
</div>
<p>And here is the <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> that selects all the attributes from the <em>document element</em> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>declare default element namespace &quot;http://cookbook/namespace&quot;;
for $i in doc(&quot;cookbook.xml&quot;)/cookbook/@*
return &lt;p&gt;{$i}&lt;/p&gt;
</pre></div>
</div>
<p>And here is its output:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">p</span> <span class="n">xmlns</span><span class="o">=</span><span class="s2">&quot;http://cookbook/namespace&quot;</span> <span class="n">count</span><span class="o">=</span><span class="s2">&quot;3&quot;</span><span class="o">/&gt;</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="element-constructors-are-expressions">
<span id="id21"></span><h2>Element Constructors are Expressions<a class="headerlink" href="#element-constructors-are-expressions" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Because node constructors are expressions, they can be used in XQueries wherever expressions are allowed.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>declare default element namespace &quot;http://cookbook/namespace&quot;;
let $docURI := &#39;cookbook.xml&#39;
return if(doc-available($docURI))
       then doc($docURI)//recipe/&lt;oppskrift&gt;{./node()}&lt;/oppskrift&gt;
       else &lt;oppskrift&gt;Failed to load {$docURI}&lt;/oppskrift&gt;
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">cookbook.xml</span></code> is loaded without error, a <code class="docutils literal"><span class="pre">&lt;oppskrift&gt;</span></code> element (Norwegian word for recipe) is constructed for each <code class="docutils literal"><span class="pre">&lt;recipe&gt;</span></code> element in the cookbook, and the child nodes of the <code class="docutils literal"><span class="pre">&lt;recipe&gt;</span></code> are copied into the <code class="docutils literal"><span class="pre">&lt;oppskrift&gt;</span></code> element. But if the cookbook document doesn’t exist or does not contain well-formed XML, a single <code class="docutils literal"><span class="pre">&lt;oppskrift&gt;</span></code> element is constructed containing an error message.</p>
</div></blockquote>
</div>
<div class="section" id="constructing-atomic-values">
<span id="id22"></span><h2>Constructing Atomic Values<a class="headerlink" href="#constructing-atomic-values" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p><a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> also has atomic values. An atomic value is a value in the value space of one of the built-in datatypes in the XML Schema language. These <em>atomic types</em> have built-in operators for doing arithmetic, comparisons, and for converting values to other atomic types. See the Built-in Datatype Hierarchy for the entire tree of built-in, primitive and derived atomic types.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Click on a data type in the tree for its detailed specification.</p>
</div>
<p>To construct an atomic value as element content, enclose an expression in curly braces and embed it in the element constructor:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">e</span><span class="o">&gt;</span><span class="p">{</span><span class="nb">sum</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))}</span><span class="o">&lt;/</span><span class="n">e</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Sending this <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> through xmlpatterns produces:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">e</span><span class="o">&gt;</span><span class="mi">6</span><span class="o">&lt;/</span><span class="n">e</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>To compute the value of an attribute, enclose the expression in curly braces and embed it in the attribute value:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>declare variable $insertion := &quot;example&quot;;
&lt;p class=&quot;important {$insertion} obsolete&quot;/&gt;
</pre></div>
</div>
<p>Sending this <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> through xmlpatterns produces:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>&lt;p class=&quot;important example obsolete&quot;/&gt;
declare default element namespace &quot;http://cookbook/namespace&quot;;
let $docURI := &#39;cookbook.xml&#39;
return if(doc-available($docURI))
       then doc($docURI)//recipe/&lt;oppskrift&gt;{./node()}&lt;/oppskrift&gt;
       else &lt;oppskrift&gt;Failed to load {$docURI}&lt;/oppskrift&gt;
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">cookbook.xml</span></code> is loaded without error, a <code class="docutils literal"><span class="pre">&lt;oppskrift&gt;</span></code> element (Norweigian word for recipe) is constructed for each <code class="docutils literal"><span class="pre">&lt;recipe&gt;</span></code> element in the cookbook, and the child nodes of the <code class="docutils literal"><span class="pre">&lt;recipe&gt;</span></code> are copied into the <code class="docutils literal"><span class="pre">&lt;oppskrift&gt;</span></code> element. But if the cookbook document doesn’t exist or does not contain well-formed XML, a single <code class="docutils literal"><span class="pre">&lt;oppskrift&gt;</span></code> element is constructed containing an error message.</p>
</div></blockquote>
</div>
<div class="section" id="running-the-cookbook-examples">
<span id="id23"></span><h2>Running The Cookbook Examples<a class="headerlink" href="#running-the-cookbook-examples" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Most of the <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> examples in this document refer to the <code class="docutils literal"><span class="pre">cookbook.xml</span></code> example file from the <a class="reference internal" href="qtxmlpatterns-recipes-example.html#recipes-example"><span class="std std-ref">Recipes Example</span></a> . Copy the <code class="docutils literal"><span class="pre">cookbook.xml</span></code> to your current directory, save one of the cookbook <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> examples in a <code class="docutils literal"><span class="pre">.xq</span></code> file (e.g., <code class="docutils literal"><span class="pre">file.xq</span></code> ), and run the <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> using Qt’s command line utility:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">xmlpatterns</span> <span class="n">file</span><span class="o">.</span><span class="n">xq</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="further-reading">
<span id="id24"></span><h2>Further Reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>There is much more to the <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> language than we have presented in this short introduction. We will be adding more here in later releases. In the meantime, playing with the <code class="docutils literal"><span class="pre">xmlpatterns</span></code> utility and making modifications to the <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> examples provided here will be quite informative. An <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> textbook will be a good investment.</p>
<p>You can also ask questions on <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> mail lists:</p>
<ul class="simple">
<li>qt-interest</li>
<li>talk at x-query.com.</li>
</ul>
<p>FunctX has a collection of <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> functions that can be both useful and educational.</p>
<p>This introduction contains many links to the specifications, which, of course, are the ultimate source of information about <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> . They can be a bit difficult, though, so consider investing in a textbook:</p>
<ul class="simple">
<li><a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> 1.0: An XML Query Language - the main source for syntax and semantics.</li>
<li><a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> 1.0 and XPath 2.0 Functions and Operators - the builtin functions and operators.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="faq">
<span id="id25"></span><h2>FAQ<a class="headerlink" href="#faq" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The answers to these frequently asked questions explain the causes of several common mistakes that most beginners make. Reading through the answers ahead of time might save you a lot of head scratching.</div></blockquote>
</div>
<div class="section" id="why-didn-t-my-path-expression-match-anything">
<span id="id26"></span><h2>Why didn’t my path expression match anything?<a class="headerlink" href="#why-didn-t-my-path-expression-match-anything" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The most common cause of this bug is failure to declare one or more namespaces in your <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> . Consider the following query for selecting all the examples in an XHTML document:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">Code</span> <span class="n">snippet</span> <span class="s2">&quot;/tmp/qt-doc-test-511/_qt5/qtbase/patternist/simpleHTML.xq&quot;</span> <span class="ow">not</span> <span class="n">found</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>It won’t match anything because <code class="docutils literal"><span class="pre">index.html</span></code> is an XHTML file, and all XHTML files declare the default namespace <code class="docutils literal"><span class="pre">&quot;http://www.w3.org/1999/xhtml&quot;</span></code> in their top (<code class="docutils literal"><span class="pre">&lt;html&gt;</span></code> ) element. But the query doesn’t declare this namespace, so the path expression expands <code class="docutils literal"><span class="pre">html</span></code> to <code class="docutils literal"><span class="pre">{}html</span></code> and tries to match that expanded name. But the actual expanded name is <code class="docutils literal"><span class="pre">{http://www.w3.org/1999/xhtml}html</span></code> . One possible fix is to declare the correct default namespace in the <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">Code</span> <span class="n">snippet</span> <span class="s2">&quot;/tmp/qt-doc-test-511/_qt5/qtbase/patternist/simpleXHTML.xq&quot;</span> <span class="ow">not</span> <span class="n">found</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Another common cause of this bug is to confuse the <em>document node</em> with the top element node. They are different. This query won’t match anything:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">Code</span> <span class="n">snippet</span> <span class="s2">&quot;/tmp/qt-doc-test-511/_qt5/qtbase/patternist/docPlainHTML.xq&quot;</span> <span class="ow">not</span> <span class="n">found</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">doc()</span></code> function returns the <em>document node</em> , not the top element node (<code class="docutils literal"><span class="pre">&lt;html&gt;</span></code> ). Don’t forget to match the top element node in the path expression:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">Code</span> <span class="n">snippet</span> <span class="s2">&quot;/tmp/qt-doc-test-511/_qt5/qtbase/patternist/docPlainHTML2.xq&quot;</span> <span class="ow">not</span> <span class="n">found</span><span class="o">&gt;</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="what-if-my-input-namespace-is-different-from-my-output-namespace">
<span id="id27"></span><h2>What if my input namespace is different from my output namespace?<a class="headerlink" href="#what-if-my-input-namespace-is-different-from-my-output-namespace" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Just remember to declare both namespaces in your <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> and use them properly. Consider the following query, which is meant to generate XHTML output from XML input:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">Code</span> <span class="n">snippet</span> <span class="s2">&quot;/tmp/qt-doc-test-511/_qt5/qtbase/patternist/embedDataInXHTML.xq&quot;</span> <span class="ow">not</span> <span class="n">found</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>We want the <code class="docutils literal"><span class="pre">&lt;html&gt;</span></code> , <code class="docutils literal"><span class="pre">&lt;body&gt;</span></code> , and <code class="docutils literal"><span class="pre">&lt;p&gt;</span></code> nodes we create in the output to be in the standard XHTML namespace, so we declare the default namespace to be <code class="docutils literal"><span class="pre">http://www.w3.org/1999/xhtml</span></code> . That’s correct for the output, but that same default namespace will also be applied to the node names in the path expression we’re trying to match in the input (<code class="docutils literal"><span class="pre">/tests/test[&#64;status</span> <span class="pre">=</span> <span class="pre">&quot;failure&quot;]</span></code> ), which is wrong, because the namespace used in <code class="docutils literal"><span class="pre">testResult.xml</span></code> is perhaps in the empty namespace. So we must declare that namespace too, with a namespace prefix, and then use the prefix with the node names in the path expression. This one will probably work better:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">Code</span> <span class="n">snippet</span> <span class="s2">&quot;/tmp/qt-doc-test-511/_qt5/qtbase/patternist/embedDataInXHTML2.xq&quot;</span> <span class="ow">not</span> <span class="n">found</span><span class="o">&gt;</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="why-doesn-t-my-return-clause-work">
<span id="id28"></span><h2>Why doesn’t my return clause work?<a class="headerlink" href="#why-doesn-t-my-return-clause-work" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Recall that <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> is an <em>expression-based</em> language, not <em>statement-based</em> . Because an <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> is a lot of expressions, understanding <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> expression precedence is very important. Consider the following query:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">Code</span> <span class="n">snippet</span> <span class="s2">&quot;/tmp/qt-doc-test-511/_qt5/qtbase/patternist/forClause2.xq&quot;</span> <span class="ow">not</span> <span class="n">found</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>It looks ok, but it isn’t. It is supposed to be a FLWOR expression comprising a <em>for</em> clause and a <em>return</em> clause, but it isn’t just that. It <em>has</em> a FLWOR expression, certainly (with the <em>for</em> and <em>return</em> clauses), but it <em>also</em> has an arithmetic expression (<em>+ $d</em> ) dangling at the end because we didn’t enclose the return expression in parentheses.</p>
<p>Using parentheses to establish precedence is more important in <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> than in other languages, because <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> is <em>expression-based</em> . In In this case, without parantheses enclosing <code class="docutils literal"><span class="pre">$i</span> <span class="pre">+</span> <span class="pre">$d</span></code> , the return clause only returns <code class="docutils literal"><span class="pre">$i</span></code> . The <code class="docutils literal"><span class="pre">+$d</span></code> will have the result of the FLWOR expression as its left operand. And, since the scope of variable <code class="docutils literal"><span class="pre">$d</span></code> ends at the end of the <em>return</em> clause, a variable out of scope error will be reported. Correct these problems by using parentheses.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">Code</span> <span class="n">snippet</span> <span class="s2">&quot;/tmp/qt-doc-test-511/_qt5/qtbase/patternist/forClause.xq&quot;</span> <span class="ow">not</span> <span class="n">found</span><span class="o">&gt;</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="why-didn-t-my-expression-get-evaluated">
<span id="id29"></span><h2>Why didn’t my expression get evaluated?<a class="headerlink" href="#why-didn-t-my-expression-get-evaluated" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>You probably misplaced some curly braces. When you want an expression evaluated inside an element constructor, enclose the expression in curly braces. Without the curly braces, the expression will be interpreted as text. Here is a <code class="docutils literal"><span class="pre">sum()</span></code> expression used in an <code class="docutils literal"><span class="pre">&lt;e&gt;</span></code> element. The table shows cases where the curly braces are missing, misplaced, and placed correctly:</p>
<table border="1" class="docutils">
<colgroup>
<col width="64%" />
<col width="36%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>element constructor with expression…</td>
<td>evaluates to…</td>
</tr>
<tr class="row-even"><td>&lt;e&gt;sum((1, 2, 3))&lt;/e&gt;</td>
<td>&lt;e&gt;sum((1, 2, 3))&lt;/e&gt;</td>
</tr>
<tr class="row-odd"><td>&lt;e&gt;sum({(1, 2, 3)})&lt;/e&gt;</td>
<td>&lt;e&gt;sum(1 2 3)&lt;/e&gt;</td>
</tr>
<tr class="row-even"><td>&lt;e&gt;{sum((1, 2, 3))}&lt;/e&gt;</td>
<td>&lt;e&gt;6&lt;/e&gt;</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="my-predicate-is-correct-so-why-doesn-t-it-select-the-right-stuff">
<span id="id30"></span><h2>My predicate is correct, so why doesn’t it select the right stuff?<a class="headerlink" href="#my-predicate-is-correct-so-why-doesn-t-it-select-the-right-stuff" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Either you put your predicate in the wrong place in your path expression, or you forgot to add some parentheses. Consider this input file <code class="docutils literal"><span class="pre">doc.txt</span></code> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">Code</span> <span class="n">snippet</span> <span class="s2">&quot;/tmp/qt-doc-test-511/_qt5/qtbase/patternist/doc.txt&quot;</span> <span class="ow">not</span> <span class="n">found</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Suppose you want the first <code class="docutils literal"><span class="pre">&lt;span&gt;</span></code> element of every <code class="docutils literal"><span class="pre">&lt;p&gt;</span></code> element. Apply a position filter (<code class="docutils literal"><span class="pre">[1]</span></code> ) to the <code class="docutils literal"><span class="pre">/span</span></code> path step:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">Code</span> <span class="n">snippet</span> <span class="s2">&quot;/tmp/qt-doc-test-511/_qt5/qtbase/patternist/filterOnStep.xq&quot;</span> <span class="ow">not</span> <span class="n">found</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Applying the <code class="docutils literal"><span class="pre">[1]</span></code> filter to the <code class="docutils literal"><span class="pre">/span</span></code> step returns the first <code class="docutils literal"><span class="pre">&lt;span&gt;</span></code> element of each <code class="docutils literal"><span class="pre">&lt;p&gt;</span></code> element:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">span</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">&lt;/</span><span class="n">span</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">span</span><span class="o">&gt;</span><span class="mi">3</span><span class="o">&lt;/</span><span class="n">span</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">span</span><span class="o">&gt;</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">span</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">span</span><span class="o">&gt;</span><span class="mi">7</span><span class="o">&lt;/</span><span class="n">span</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">span</span><span class="o">&gt;</span><span class="mi">9</span><span class="o">&lt;/</span><span class="n">span</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">span</span><span class="o">&gt;</span><span class="n">b</span><span class="o">&lt;/</span><span class="n">span</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">span</span><span class="o">&gt;</span><span class="n">d</span><span class="o">&lt;/</span><span class="n">span</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">span</span><span class="o">&gt;</span><span class="n">f</span><span class="o">&lt;/</span><span class="n">span</span><span class="o">&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">: You can write the same query this way:</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>for $a in doc(&#39;doc.txt&#39;)/doc/p/span[1]
return $a
</pre></div>
</div>
<p>Or you can reduce it right down to this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">doc</span><span class="p">(</span><span class="s1">&#39;doc.txt&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">doc</span><span class="o">/</span><span class="n">p</span><span class="o">/</span><span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>On the other hand, suppose you really want only one <code class="docutils literal"><span class="pre">&lt;span&gt;</span></code> element, the first one in the document (i.e., you only want the first <code class="docutils literal"><span class="pre">&lt;span&gt;</span></code> element in the first <code class="docutils literal"><span class="pre">&lt;p&gt;</span></code> element). Then you have to do more filtering. There are two ways you can do it. You can apply the <code class="docutils literal"><span class="pre">[1]</span></code> filter in the same place as above but enclose the path expression in parentheses:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">Code</span> <span class="n">snippet</span> <span class="s2">&quot;/tmp/qt-doc-test-511/_qt5/qtbase/patternist/filterOnPath.xq&quot;</span> <span class="ow">not</span> <span class="n">found</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Or you can apply a second position filter (<code class="docutils literal"><span class="pre">[1]</span></code> again) to the <code class="docutils literal"><span class="pre">/p</span></code> path step:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>let $doc := doc(&#39;doc.txt&#39;)
return $doc/doc/p[1]/span[1]
</pre></div>
</div>
<p>Either way the query will return only the first <code class="docutils literal"><span class="pre">&lt;span&gt;</span></code> element in the document:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">span</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">&lt;/</span><span class="n">span</span><span class="o">&gt;</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="why-doesn-t-my-flwor-behave-as-expected">
<span id="id31"></span><h2>Why doesn’t my FLWOR behave as expected?<a class="headerlink" href="#why-doesn-t-my-flwor-behave-as-expected" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The quick answer is you probably expected your <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> FLWOR to behave just like a C++ <em>for</em> loop. But they aren’t the same. Consider a simple example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">Code</span> <span class="n">snippet</span> <span class="s2">&quot;/tmp/qt-doc-test-511/_qt5/qtbase/patternist/letOrderBy.xq&quot;</span> <span class="ow">not</span> <span class="n">found</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>This query evaluates to <em>4 -4 -2 2 -8 8</em> . The <em>for</em> clause does set up a <em>for</em> loop style iteration, which does evaluate the rest of the FLWOR multiple times, one time for each value returned by the <em>in</em> expression. That much is similar to the C++ <em>for</em> loop.</p>
<p>But consider the <em>return</em> clause. In C++ if you hit a <em>return</em> statement, you break out of the <em>for</em> loop and return from the function with one value. Not so in <a class="reference internal" href="xmlprocessing.html#xquery"><span class="std std-ref">XQuery</span></a> . The <em>return</em> clause is the last clause of the FLWOR, and it means: <em>Append the return value to the result list and then begin the next iteration of the FLWOR</em> . When the <em>for</em> clause’s <em>in</em> expression no longer returns a value, the entire result list is returned.</p>
<p>Next, consider the <em>order by</em> clause. It doesn’t do any sorting on each iteration of the FLWOR. It just evaluates its expression on each iteration (<code class="docutils literal"><span class="pre">$a</span></code> in this case) to get an ordering value to map to the result item from each iteration. These ordering values are kept in a parallel list. The result list is sorted at the end using the parallel list of ordering values.</p>
<p>The last difference to note here is that the <em>let</em> clause does <em>not</em> set up an iteration through a sequence of values like the <em>for</em> clause does. The <em>let</em> clause isn’t a sort of nested loop. It isn’t a loop at all. It is just a variable binding. On each iteration, it binds the <em>entire</em> sequence of values on the right to the variable on the left. In the example above, it binds (4 -4) to <code class="docutils literal"><span class="pre">$b</span></code> on the first iteration, (-2 2) on the second iteration, and (-8 8) on the third iteration. So the following query doesn’t iterate through anything, and doesn’t do any ordering:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">Code</span> <span class="n">snippet</span> <span class="s2">&quot;/tmp/qt-doc-test-511/_qt5/qtbase/patternist/invalidLetOrderBy.xq&quot;</span> <span class="ow">not</span> <span class="n">found</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>It binds the entire sequence (2, 3, 1) to <code class="docutils literal"><span class="pre">$i</span></code> one time only; the <em>order by</em> clause only has one thing to order and hence does nothing, and the query evaluates to 2 3 1, the sequence assigned to <code class="docutils literal"><span class="pre">$i</span></code> .</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We didn’t include a <em>where</em> clause in the example. The <em>where</em> clause is for filtering results.</p>
</div>
</div></blockquote>
</div>
<div class="section" id="why-are-my-elements-created-in-the-wrong-order">
<span id="id32"></span><h2>Why are my elements created in the wrong order?<a class="headerlink" href="#why-are-my-elements-created-in-the-wrong-order" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The short answer is your elements are <em>not</em> created in the wrong order, because when appearing as operands to a path expression, there is no correct order. Consider the following query, which again uses the input file <code class="docutils literal"><span class="pre">doc.txt</span></code> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">doc</span><span class="p">(</span><span class="s1">&#39;doc.txt&#39;</span><span class="p">)</span><span class="o">//</span><span class="n">p</span><span class="o">/&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">{</span><span class="n">span</span><span class="o">/</span><span class="n">node</span><span class="p">()}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The query finds all the <code class="docutils literal"><span class="pre">&lt;p&gt;</span></code> elements in the file. For each <code class="docutils literal"><span class="pre">&lt;p&gt;</span></code> element, it builds a <code class="docutils literal"><span class="pre">&lt;p&gt;</span></code> element in the output containing the concatenated contents of all the <code class="docutils literal"><span class="pre">&lt;p&gt;</span></code> element’s child <code class="docutils literal"><span class="pre">&lt;span&gt;</span></code> elements. Running the query through <code class="docutils literal"><span class="pre">xmlpatterns</span></code> might produce the following output, which is not sorted in the expected order.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="mi">78</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="mi">9</span><span class="n">a</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="mi">12</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">bc</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">de</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="mi">34</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="mi">56</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">f0</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>You can use a <em>for</em> loop to ensure that the order of the result set corresponds to the order of the input sequence:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>for $a in doc(&#39;doc.txt&#39;)//p
 return &lt;p&gt;{$a/span/node()}&lt;/p&gt;
</pre></div>
</div>
<p>This version produces the same result set but in the expected order:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="mi">12</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="mi">34</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="mi">56</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="mi">78</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="mi">9</span><span class="n">a</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">bc</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">de</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">f0</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</pre></div>
</div>
</div></blockquote>
<p id="why-can-t-i-use-keyword-true-keyword-and-keyword-false-keyword-in-my-xquery">Why can’t I use
<code class="docutils literal"><span class="pre">true</span></code></p>
<p>and
<code class="docutils literal"><span class="pre">false</span></code></p>
</div>
<div class="section" id="in-my-xquery">
<h2>in my XQuery?<a class="headerlink" href="#in-my-xquery" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>You can, but not by just using the names <code class="docutils literal"><span class="pre">true</span></code> and <code class="docutils literal"><span class="pre">false</span></code> directly, because they are <a class="reference internal" href="#a-short-path-to-xquery"><span class="std std-ref">name tests</span></a> although they look like boolean constants. The simple way to create the boolean values is to use the builtin functions <code class="docutils literal"><span class="pre">true()</span></code> and <code class="docutils literal"><span class="pre">false()</span></code> wherever you want to use <code class="docutils literal"><span class="pre">true</span></code> and <code class="docutils literal"><span class="pre">false</span></code> . The other way is to invoke the boolean constructor:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">Code</span> <span class="n">snippet</span> <span class="s2">&quot;/tmp/qt-doc-test-511/_qt5/qtbase/patternist/xsBooleanTrue.xq&quot;</span> <span class="ow">not</span> <span class="n">found</span><span class="o">&gt;</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <p>© 2018 The Qt Company Ltd. Documentation contributions included herein are the copyrights of their respective owners. The documentation provided herein is licensed under the terms of the <a href="http://www.gnu.org/license/fdl.html">GNU Free Documentation License version 1.3</a> as published by the Free Software Foundation. Qt and respective logos are trademarks of The Qt Company Ltd. in Finland and/or other countries worldwide. All other trademarks are property of their respective owners.</p>
    </div></div>
    <div id="footer" class="footer">
    </div>
</div>
  </body>
</html>