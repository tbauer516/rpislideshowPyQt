
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Model/View Programming &#8212; Qt for Python (Technology Preview)</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '5.11.0~a1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" title="Search" href="../search.html" />
  <link rel="stylesheet" type="text/css" href="/style/pyside.css" />
  <link rel="icon" type="image/png" href="/style/pyside-32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/style/pyside-16px.png" sizes="16x16" />
  <script type="text/javascript"> wpThemeFolder = 'http://qt.io/wp-content/themes/oneqt'; </script>
  <script type="text/javascript" src="/scripts/main.js"></script>
  <script type="text/javascript" src="/scripts/extras.js"></script>
  <script type="text/javascript">
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-54043535-2', 'qt.io');
    ga('set', 'forceSSL', true);
    ga('send', 'pageview');
  </script>

  </head>
  <body>
<div id="container">
    <div class="header">
        <div class="header_container">
            <header id="navbar">
            </header>
        </div>
    </div>
    <div class="main">
        <div class="main-rounded">
            <div class="navigationbar">
                <ul class="sub-navigation">
                    <li><a href="http://wiki.qt.io/">Wiki</a></li>
                    <li><a href="https://doc.qt.io/">Documentation</a></li>
                    <li><a href="http://forum.qt.io/">Forum</a></li>
                    <li><a href="https://bugreports.qt.io/">Bug Reports</a></li>
                    <li><a href="https://codereview.qt-project.org/">Code Review</a></li>
                </ul>
                <div id="main_title_bar"><h1>Qt Documentation</h1></div>
                <div class="related">
                    <ul>
                        <li><a href="../index.html">Qt for Python (Technology Preview)</a></li> 
                    </ul>
                </div>
            </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Model/View Programming</a><ul>
<li><a class="reference internal" href="#introduction-to-model-view-programming">Introduction to Model/View Programming</a></li>
<li><a class="reference internal" href="#the-model-view-architecture">The model/view architecture</a></li>
<li><a class="reference internal" href="#models">Models</a></li>
<li><a class="reference internal" href="#views">Views</a></li>
<li><a class="reference internal" href="#delegates">Delegates</a></li>
<li><a class="reference internal" href="#sorting">Sorting</a></li>
<li><a class="reference internal" href="#convenience-classes">Convenience classes</a></li>
<li><a class="reference internal" href="#using-models-and-views">Using Models and Views</a></li>
<li><a class="reference internal" href="#two-models-included-in-qt">Two models included in Qt</a></li>
<li><a class="reference internal" href="#using-views-with-an-existing-model">Using views with an existing model</a></li>
<li><a class="reference internal" href="#model-classes">Model Classes</a></li>
<li><a class="reference internal" href="#basic-concepts">Basic concepts</a></li>
<li><a class="reference internal" href="#model-indexes">Model indexes</a></li>
<li><a class="reference internal" href="#rows-and-columns">Rows and columns</a></li>
<li><a class="reference internal" href="#parents-of-items">Parents of items</a></li>
<li><a class="reference internal" href="#item-roles">Item roles</a></li>
<li><a class="reference internal" href="#summary">Summary</a></li>
<li><a class="reference internal" href="#using-model-indexes">Using model indexes</a></li>
<li><a class="reference internal" href="#further-reading">Further reading</a></li>
<li><a class="reference internal" href="#view-classes">View Classes</a></li>
<li><a class="reference internal" href="#concepts">Concepts</a></li>
<li><a class="reference internal" href="#using-an-existing-view">Using an existing view</a></li>
<li><a class="reference internal" href="#using-a-model">Using a model</a></li>
<li><a class="reference internal" href="#using-multiple-views-of-a-model">Using multiple views of a model</a></li>
<li><a class="reference internal" href="#handling-selections-of-items">Handling selections of items</a></li>
<li><a class="reference internal" href="#sharing-selections-among-views">Sharing selections among views</a></li>
<li><a class="reference internal" href="#delegate-classes">Delegate Classes</a></li>
<li><a class="reference internal" href="#id29">Concepts</a></li>
<li><a class="reference internal" href="#using-an-existing-delegate">Using an existing delegate</a></li>
<li><a class="reference internal" href="#a-simple-delegate">A simple delegate</a></li>
<li><a class="reference internal" href="#providing-an-editor">Providing an editor</a></li>
<li><a class="reference internal" href="#submitting-data-to-the-model">Submitting data to the model</a></li>
<li><a class="reference internal" href="#updating-the-editor-s-geometry">Updating the editor’s geometry</a></li>
<li><a class="reference internal" href="#editing-hints">Editing hints</a></li>
<li><a class="reference internal" href="#handling-selections-in-item-views">Handling Selections in Item Views</a></li>
<li><a class="reference internal" href="#id39">Concepts</a></li>
<li><a class="reference internal" href="#current-item-and-selected-items">Current item and selected items</a></li>
<li><a class="reference internal" href="#using-a-selection-model">Using a selection model</a></li>
<li><a class="reference internal" href="#selecting-items">Selecting items</a></li>
<li><a class="reference internal" href="#reading-the-selection-state">Reading the selection state</a></li>
<li><a class="reference internal" href="#updating-a-selection">Updating a selection</a></li>
<li><a class="reference internal" href="#selecting-all-items-in-a-model">Selecting all items in a model</a></li>
<li><a class="reference internal" href="#creating-new-models">Creating New Models</a></li>
<li><a class="reference internal" href="#designing-a-model">Designing a model</a></li>
<li><a class="reference internal" href="#a-read-only-example-model">A read-only example model</a></li>
<li><a class="reference internal" href="#dimensions-of-the-model">Dimensions of the model</a></li>
<li><a class="reference internal" href="#model-headers-and-data">Model headers and data</a></li>
<li><a class="reference internal" href="#an-editable-model">An editable model</a></li>
<li><a class="reference internal" href="#making-the-model-editable">Making the model editable</a></li>
<li><a class="reference internal" href="#inserting-and-removing-rows">Inserting and removing rows</a></li>
<li><a class="reference internal" href="#next-steps">Next steps</a></li>
<li><a class="reference internal" href="#item-view-convenience-classes">Item View Convenience Classes</a></li>
<li><a class="reference internal" href="#list-widgets">List widgets</a></li>
<li><a class="reference internal" href="#tree-widgets">Tree widgets</a></li>
<li><a class="reference internal" href="#table-widgets">Table widgets</a></li>
<li><a class="reference internal" href="#common-features">Common features</a></li>
<li><a class="reference internal" href="#hidden-items">Hidden items</a></li>
<li><a class="reference internal" href="#selections">Selections</a></li>
<li><a class="reference internal" href="#searching">Searching</a></li>
<li><a class="reference internal" href="#using-drag-and-drop-with-item-views">Using Drag and Drop with Item Views</a></li>
<li><a class="reference internal" href="#using-convenience-views">Using convenience views</a></li>
<li><a class="reference internal" href="#using-model-view-classes">Using model/view classes</a></li>
<li><a class="reference internal" href="#enabling-drag-and-drop-for-items">Enabling drag and drop for items</a></li>
<li><a class="reference internal" href="#encoding-exported-data">Encoding exported data</a></li>
<li><a class="reference internal" href="#inserting-dropped-data-into-a-model">Inserting dropped data into a model</a></li>
<li><a class="reference internal" href="#decoding-imported-data">Decoding imported data</a></li>
<li><a class="reference internal" href="#proxy-models">Proxy Models</a></li>
<li><a class="reference internal" href="#using-proxy-models">Using proxy models</a></li>
<li><a class="reference internal" href="#customizing-proxy-models">Customizing proxy models</a></li>
<li><a class="reference internal" href="#custom-filtering-models">Custom filtering models</a></li>
<li><a class="reference internal" href="#custom-sorting-models">Custom sorting models</a></li>
<li><a class="reference internal" href="#model-subclassing-reference">Model Subclassing Reference</a></li>
<li><a class="reference internal" href="#item-data-handling">Item data handling</a></li>
<li><a class="reference internal" href="#read-only-access">Read-Only access</a></li>
<li><a class="reference internal" href="#editable-items">Editable items</a></li>
<li><a class="reference internal" href="#resizable-models">Resizable models</a></li>
<li><a class="reference internal" href="#lazy-population-of-model-data">Lazy population of model data</a></li>
<li><a class="reference internal" href="#navigation-and-model-index-creation">Navigation and model index creation</a></li>
<li><a class="reference internal" href="#parents-and-children">Parents and children</a></li>
<li><a class="reference internal" href="#drag-and-drop-support-and-mime-type-handling">Drag and drop support and MIME type handling</a></li>
<li><a class="reference internal" href="#mime-data">MIME data</a></li>
<li><a class="reference internal" href="#accepting-dropped-data">Accepting dropped data</a></li>
<li><a class="reference internal" href="#convenience-views">Convenience views</a></li>
<li><a class="reference internal" href="#performance-optimization-for-large-amounts-of-data">Performance optimization for large amounts of data</a></li>
<li><a class="reference internal" href="#the-model-view-classes">The Model/View Classes</a></li>
<li><a class="reference internal" href="#related-examples">Related Examples</a></li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="model-view-programming">
<span id="id1"></span><h1>Model/View Programming<a class="headerlink" href="#model-view-programming" title="Permalink to this headline">¶</a></h1>
<p>A guide to Qt’s extensible model/view architecture</p>
<blockquote>
<div><p id="model-view-classes"><span id="editinghints"></span>A guide to Qt’s extensible model/view architecture.</p>
</div></blockquote>
<div class="section" id="introduction-to-model-view-programming">
<span id="id2"></span><h2>Introduction to Model/View Programming<a class="headerlink" href="#introduction-to-model-view-programming" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>Qt contains a set of item view classes that use a model/view architecture to manage the relationship between data and the way it is presented to the user. The separation of functionality introduced by this architecture gives developers greater flexibility to customize the presentation of items, and provides a standard model interface to allow a wide range of data sources to be used with existing item views. In this document, we give a brief introduction to the model/view paradigm, outline the concepts involved, and describe the architecture of the item view system. Each of the components in the architecture is explained, and examples are given that show how to use the classes provided.</div></blockquote>
</div>
<div class="section" id="the-model-view-architecture">
<span id="id3"></span><h2>The model/view architecture<a class="headerlink" href="#the-model-view-architecture" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Model-View-Controller (MVC) is a design pattern originating from Smalltalk that is often used when building user interfaces. In <a class="reference internal" href="guibooks.html#books-about-gui-design"><span class="std std-ref">Design Patterns</span></a> , Gamma et al. write:</p>
<p>MVC consists of three kinds of objects. The Model is the application object, the View is its screen presentation, and the Controller defines the way the user interface reacts to user input. Before MVC, user interface designs tended to lump these objects together. MVC decouples them to increase flexibility and reuse.</p>
<p>If the view and the controller objects are combined, the result is the model/view architecture. This still separates the way that data is stored from the way that it is presented to the user, but provides a simpler framework based on the same principles. This separation makes it possible to display the same data in several different views, and to implement new types of views, without changing the underlying data structures. To allow flexible handling of user input, we introduce the concept of the <em>delegate</em> . The advantage of having a delegate in this framework is that it allows the way items of data are rendered and edited to be customized.</p>
<p>++———————————————————————————————————————————————————————————————————————————-+
||**The model/view architecture**                                                                                                                                                                                                   |
||                                                                                                                                                                                                                                  |
||    The model communicates with a source of data, providing an <em>interface</em> for the other components in the architecture. The nature of the communication depends on the type of data source, and the way the model is implemented.|
||                                                                                                                                                                                                                                  |
||    The view obtains <em>model indexes</em> from the model; these are references to items of data. By supplying model indexes to the model, the view can retrieve items of data from the data source.                                    |
||                                                                                                                                                                                                                                  |
||    In standard views, a <em>delegate</em> renders the items of data. When an item is edited, the delegate communicates with the model directly using model indexes.                                                                     |
++———————————————————————————————————————————————————————————————————————————-+</p>
<p>Generally, the model/view classes can be separated into the three groups described above: models, views, and delegates. Each of these components is defined by <em>abstract</em> classes that provide common interfaces and, in some cases, default implementations of features. Abstract classes are meant to be subclassed in order to provide the full set of functionality expected by other components; this also allows specialized components to be written.</p>
<p>Models, views, and delegates communicate with each other using <em>signals and slots</em> :</p>
<ul class="simple">
<li>Signals from the model inform the view about changes to the data held by the data source.</li>
<li>Signals from the view provide information about the user’s interaction with the items being displayed.</li>
<li>Signals from the delegate are used during editing to tell the model and view about the state of the editor.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="models">
<span id="id4"></span><h2>Models<a class="headerlink" href="#models" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>All item models are based on the <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> class. This class defines an interface that is used by views and delegates to access data. The data itself does not have to be stored in the model; it can be held in a data structure or repository provided by a separate class, a file, a database, or some other application component.</p>
<p>The basic concepts surrounding models are presented in the section on <a class="reference internal" href="#model-view-programming"><span class="std std-ref">Model Classes</span></a> .</p>
<p><a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> provides an interface to data that is flexible enough to handle views that represent data in the form of tables, lists, and trees. However, when implementing new models for list and table-like data structures, the <a class="reference internal" href="../PySide2/QtCore/QAbstractListModel.html#PySide2.QtCore.QAbstractListModel" title="PySide2.QtCore.QAbstractListModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractListModel</span></code></a> and <a class="reference internal" href="../PySide2/QtCore/QAbstractTableModel.html#PySide2.QtCore.QAbstractTableModel" title="PySide2.QtCore.QAbstractTableModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractTableModel</span></code></a> classes are better starting points because they provide appropriate default implementations of common functions. Each of these classes can be subclassed to provide models that support specialized kinds of lists and tables.</p>
<p>The process of subclassing models is discussed in the section on <a class="reference internal" href="#model-view-programming"><span class="std std-ref">Creating New Models</span></a> .</p>
<p>Qt provides some ready-made models that can be used to handle items of data:</p>
<ul class="simple">
<li><a class="reference internal" href="../PySide2/QtCore/QStringListModel.html#PySide2.QtCore.QStringListModel" title="PySide2.QtCore.QStringListModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QStringListModel</span></code></a> is used to store a simple list of <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QString</span></code> items.</li>
<li><a class="reference internal" href="../PySide2/QtGui/QStandardItemModel.html#PySide2.QtGui.QStandardItemModel" title="PySide2.QtGui.QStandardItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtGui.QStandardItemModel</span></code></a> manages more complex tree structures of items, each of which can contain arbitrary data.</li>
<li><a class="reference internal" href="../PySide2/QtWidgets/QFileSystemModel.html#PySide2.QtWidgets.QFileSystemModel" title="PySide2.QtWidgets.QFileSystemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QFileSystemModel</span></code></a> provides information about files and directories in the local filing system.</li>
<li><a class="reference internal" href="../PySide2/QtSql/QSqlQueryModel.html#PySide2.QtSql.QSqlQueryModel" title="PySide2.QtSql.QSqlQueryModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtSql.QSqlQueryModel</span></code></a> , <a class="reference internal" href="../PySide2/QtSql/QSqlTableModel.html#PySide2.QtSql.QSqlTableModel" title="PySide2.QtSql.QSqlTableModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtSql.QSqlTableModel</span></code></a> , and <a class="reference internal" href="../PySide2/QtSql/QSqlRelationalTableModel.html#PySide2.QtSql.QSqlRelationalTableModel" title="PySide2.QtSql.QSqlRelationalTableModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtSql.QSqlRelationalTableModel</span></code></a> are used to access databases using model/view conventions.</li>
</ul>
<p>If these standard models do not meet your requirements, you can subclass <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> , <a class="reference internal" href="../PySide2/QtCore/QAbstractListModel.html#PySide2.QtCore.QAbstractListModel" title="PySide2.QtCore.QAbstractListModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractListModel</span></code></a> , or <a class="reference internal" href="../PySide2/QtCore/QAbstractTableModel.html#PySide2.QtCore.QAbstractTableModel" title="PySide2.QtCore.QAbstractTableModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractTableModel</span></code></a> to create your own custom models.</p>
</div></blockquote>
</div>
<div class="section" id="views">
<span id="id5"></span><h2>Views<a class="headerlink" href="#views" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Complete implementations are provided for different kinds of views: <a class="reference internal" href="../PySide2/QtWidgets/QListView.html#PySide2.QtWidgets.QListView" title="PySide2.QtWidgets.QListView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QListView</span></code></a> displays a list of items, <a class="reference internal" href="../PySide2/QtWidgets/QTableView.html#PySide2.QtWidgets.QTableView" title="PySide2.QtWidgets.QTableView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTableView</span></code></a> displays data from a model in a table, and <a class="reference internal" href="../PySide2/QtWidgets/QTreeView.html#PySide2.QtWidgets.QTreeView" title="PySide2.QtWidgets.QTreeView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTreeView</span></code></a> shows model items of data in a hierarchical list. Each of these classes is based on the <a class="reference internal" href="../PySide2/QtWidgets/QAbstractItemView.html#PySide2.QtWidgets.QAbstractItemView" title="PySide2.QtWidgets.QAbstractItemView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QAbstractItemView</span></code></a> abstract base class. Although these classes are ready-to-use implementations, they can also be subclassed to provide customized views.</p>
<p>The available views are examined in the section on <a class="reference internal" href="#model-view-programming"><span class="std std-ref">View Classes</span></a> .</p>
</div></blockquote>
</div>
<div class="section" id="delegates">
<span id="id6"></span><h2>Delegates<a class="headerlink" href="#delegates" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p><a class="reference internal" href="../PySide2/QtWidgets/QAbstractItemDelegate.html#PySide2.QtWidgets.QAbstractItemDelegate" title="PySide2.QtWidgets.QAbstractItemDelegate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QAbstractItemDelegate</span></code></a> is the abstract base class for delegates in the model/view framework. The default delegate implementation is provided by <a class="reference internal" href="../PySide2/QtWidgets/QStyledItemDelegate.html#PySide2.QtWidgets.QStyledItemDelegate" title="PySide2.QtWidgets.QStyledItemDelegate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QStyledItemDelegate</span></code></a> , and this is used as the default delegate by Qt’s standard views. However, <a class="reference internal" href="../PySide2/QtWidgets/QStyledItemDelegate.html#PySide2.QtWidgets.QStyledItemDelegate" title="PySide2.QtWidgets.QStyledItemDelegate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QStyledItemDelegate</span></code></a> and <a class="reference internal" href="../PySide2/QtWidgets/QItemDelegate.html#PySide2.QtWidgets.QItemDelegate" title="PySide2.QtWidgets.QItemDelegate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QItemDelegate</span></code></a> are independent alternatives to painting and providing editors for items in views. The difference between them is that <a class="reference internal" href="../PySide2/QtWidgets/QStyledItemDelegate.html#PySide2.QtWidgets.QStyledItemDelegate" title="PySide2.QtWidgets.QStyledItemDelegate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QStyledItemDelegate</span></code></a> uses the current style to paint its items. We therefore recommend using <a class="reference internal" href="../PySide2/QtWidgets/QStyledItemDelegate.html#PySide2.QtWidgets.QStyledItemDelegate" title="PySide2.QtWidgets.QStyledItemDelegate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QStyledItemDelegate</span></code></a> as the base class when implementing custom delegates or when working with Qt style sheets.</p>
<p>Delegates are described in the section on <a class="reference internal" href="#model-view-programming"><span class="std std-ref">Delegate Classes</span></a> .</p>
</div></blockquote>
</div>
<div class="section" id="sorting">
<span id="id7"></span><h2>Sorting<a class="headerlink" href="#sorting" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>There are two ways of approaching sorting in the model/view architecture; which approach to choose depends on your underlying model.</p>
<p>If your model is sortable, i.e, if it reimplements the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.sort()</span></code> function, both <a class="reference internal" href="../PySide2/QtWidgets/QTableView.html#PySide2.QtWidgets.QTableView" title="PySide2.QtWidgets.QTableView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTableView</span></code></a> and <a class="reference internal" href="../PySide2/QtWidgets/QTreeView.html#PySide2.QtWidgets.QTreeView" title="PySide2.QtWidgets.QTreeView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTreeView</span></code></a> provide an API that allows you to sort your model data programmatically. In addition, you can enable interactive sorting (i.e. allowing the users to sort the data by clicking the view’s headers), by connecting the <code class="xref py py-func docutils literal"><span class="pre">QHeaderView.sortIndicatorChanged()</span></code> signal to the <code class="xref py py-func docutils literal"><span class="pre">QTableView.sortByColumn()</span></code> slot or the <code class="xref py py-func docutils literal"><span class="pre">QTreeView.sortByColumn()</span></code> slot, respectively.</p>
<p>The alternative approach, if your model does not have the required interface or if you want to use a list view to present your data, is to use a proxy model to transform the structure of your model before presenting the data in the view. This is covered in detail in the section on <a class="reference internal" href="#model-view-programming"><span class="std std-ref">Proxy Models</span></a> .</p>
</div></blockquote>
</div>
<div class="section" id="convenience-classes">
<span id="id8"></span><h2>Convenience classes<a class="headerlink" href="#convenience-classes" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>A number of <em>convenience</em> classes are derived from the standard view classes for the benefit of applications that rely on Qt’s item-based item view and table classes. They are not intended to be subclassed.</p>
<p>Examples of such classes include <a class="reference internal" href="../PySide2/QtWidgets/QListWidget.html#PySide2.QtWidgets.QListWidget" title="PySide2.QtWidgets.QListWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QListWidget</span></code></a> , <a class="reference internal" href="../PySide2/QtWidgets/QTreeWidget.html#PySide2.QtWidgets.QTreeWidget" title="PySide2.QtWidgets.QTreeWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTreeWidget</span></code></a> , and <a class="reference internal" href="../PySide2/QtWidgets/QTableWidget.html#PySide2.QtWidgets.QTableWidget" title="PySide2.QtWidgets.QTableWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTableWidget</span></code></a> .</p>
<p>These classes are less flexible than the view classes, and cannot be used with arbitrary models. We recommend that you use a model/view approach to handling data in item views unless you strongly need an item-based set of classes.</p>
<p>If you wish to take advantage of the features provided by the model/view approach while still using an item-based interface, consider using view classes, such as <a class="reference internal" href="../PySide2/QtWidgets/QListView.html#PySide2.QtWidgets.QListView" title="PySide2.QtWidgets.QListView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QListView</span></code></a> , <a class="reference internal" href="../PySide2/QtWidgets/QTableView.html#PySide2.QtWidgets.QTableView" title="PySide2.QtWidgets.QTableView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTableView</span></code></a> , and <a class="reference internal" href="../PySide2/QtWidgets/QTreeView.html#PySide2.QtWidgets.QTreeView" title="PySide2.QtWidgets.QTreeView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTreeView</span></code></a> with <a class="reference internal" href="../PySide2/QtGui/QStandardItemModel.html#PySide2.QtGui.QStandardItemModel" title="PySide2.QtGui.QStandardItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtGui.QStandardItemModel</span></code></a> .</p>
</div></blockquote>
</div>
<div class="section" id="using-models-and-views">
<span id="id9"></span><h2>Using Models and Views<a class="headerlink" href="#using-models-and-views" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The following sections explain how to use the model/view pattern in Qt. Each section includes an example and is followed by a section showing how to create new components.</div></blockquote>
</div>
<div class="section" id="two-models-included-in-qt">
<span id="id10"></span><h2>Two models included in Qt<a class="headerlink" href="#two-models-included-in-qt" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Two of the standard models provided by Qt are <a class="reference internal" href="../PySide2/QtGui/QStandardItemModel.html#PySide2.QtGui.QStandardItemModel" title="PySide2.QtGui.QStandardItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtGui.QStandardItemModel</span></code></a> and <a class="reference internal" href="../PySide2/QtWidgets/QFileSystemModel.html#PySide2.QtWidgets.QFileSystemModel" title="PySide2.QtWidgets.QFileSystemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QFileSystemModel</span></code></a> . <a class="reference internal" href="../PySide2/QtGui/QStandardItemModel.html#PySide2.QtGui.QStandardItemModel" title="PySide2.QtGui.QStandardItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtGui.QStandardItemModel</span></code></a> is a multi-purpose model that can be used to represent various different data structures needed by list, table, and tree views. This model also holds the items of data. <a class="reference internal" href="../PySide2/QtWidgets/QFileSystemModel.html#PySide2.QtWidgets.QFileSystemModel" title="PySide2.QtWidgets.QFileSystemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QFileSystemModel</span></code></a> is a model that maintains information about the contents of a directory. As a result, it does not hold any items of data itself, but simply represents files and directories on the local filing system.</p>
<p><a class="reference internal" href="../PySide2/QtWidgets/QFileSystemModel.html#PySide2.QtWidgets.QFileSystemModel" title="PySide2.QtWidgets.QFileSystemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QFileSystemModel</span></code></a> provides a ready-to-use model to experiment with, and can be easily configured to use existing data. Using this model, we can show how to set up a model for use with ready-made views, and explore how to manipulate data using model indexes.</p>
</div></blockquote>
</div>
<div class="section" id="using-views-with-an-existing-model">
<span id="id11"></span><h2>Using views with an existing model<a class="headerlink" href="#using-views-with-an-existing-model" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The <a class="reference internal" href="../PySide2/QtWidgets/QListView.html#PySide2.QtWidgets.QListView" title="PySide2.QtWidgets.QListView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QListView</span></code></a> and <a class="reference internal" href="../PySide2/QtWidgets/QTreeView.html#PySide2.QtWidgets.QTreeView" title="PySide2.QtWidgets.QTreeView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTreeView</span></code></a> classes are the most suitable views to use with <a class="reference internal" href="../PySide2/QtWidgets/QFileSystemModel.html#PySide2.QtWidgets.QFileSystemModel" title="PySide2.QtWidgets.QFileSystemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QFileSystemModel</span></code></a> . The example presented below displays the contents of a directory in a tree view next to the same information in a list view. The views share the user’s selection so that the selected items are highlighted in both views.</p>
<p>We set up a <a class="reference internal" href="../PySide2/QtWidgets/QFileSystemModel.html#PySide2.QtWidgets.QFileSystemModel" title="PySide2.QtWidgets.QFileSystemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QFileSystemModel</span></code></a> so that it is ready for use, and create some views to display the contents of a directory. This shows the simplest way to use a model. The construction and use of the model is performed from within a single <code class="docutils literal"><span class="pre">main()</span></code> function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">app</span> <span class="o">=</span> <span class="n">QApplication</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span>
    <span class="n">splitter</span> <span class="o">=</span> <span class="n">QSplitter</span><span class="p">()</span>


    <span class="n">model</span> <span class="o">=</span> <span class="n">QFileSystemModel</span><span class="p">()</span>
    <span class="n">model</span><span class="o">.</span><span class="n">setRootPath</span><span class="p">(</span><span class="n">QDir</span><span class="o">.</span><span class="n">currentPath</span><span class="p">())</span>
</pre></div>
</div>
<p>The model is set up to use data from a certain file system. The call to <code class="xref py py-func docutils literal"><span class="pre">QFileSystemModel.setRootPath()</span></code> tells the model which drive on the file system to expose to the views.</p>
<p>We create two views so that we can examine the items held in the model in two different ways:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">tree</span> <span class="o">=</span>  <span class="n">QTreeView</span><span class="p">()</span>

<span class="n">tree</span><span class="o">.</span><span class="n">setModel</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

<span class="n">tree</span><span class="o">.</span><span class="n">setRootIndex</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">QDir</span><span class="o">.</span><span class="n">currentPath</span><span class="p">()))</span>


<span class="nb">list</span> <span class="o">=</span>  <span class="n">QListView</span><span class="p">(</span><span class="n">splitter</span><span class="p">)</span>
<span class="nb">list</span><span class="o">.</span><span class="n">setModel</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="nb">list</span><span class="o">.</span><span class="n">setRootIndex</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">QDir</span><span class="o">.</span><span class="n">currentPath</span><span class="p">()))</span>
</pre></div>
</div>
<p>The views are constructed in the same way as other widgets. Setting up a view to display the items in the model is simply a matter of calling its <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemView.setModel()</span></code> function with the directory model as the argument. We filter the data supplied by the model by calling the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemView.setRootIndex()</span></code> function on each view, passing a suitable <em>model index</em> from the file system model for the current directory.</p>
<p>The <code class="docutils literal"><span class="pre">index()</span></code> function used in this case is unique to <a class="reference internal" href="../PySide2/QtWidgets/QFileSystemModel.html#PySide2.QtWidgets.QFileSystemModel" title="PySide2.QtWidgets.QFileSystemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QFileSystemModel</span></code></a> ; we supply it with a directory and it returns a model index. Model indexes are discussed in <a class="reference internal" href="#model-view-programming"><span class="std std-ref">Model Classes</span></a> .</p>
<p>The rest of the function just displays the views within a splitter widget, and runs the application’s event loop:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">splitter</span><span class="o">.</span><span class="n">setWindowTitle</span><span class="p">(</span><span class="s2">&quot;Two views onto the same directory model&quot;</span><span class="p">)</span>
<span class="n">splitter</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="k">return</span> <span class="n">app</span><span class="o">.</span><span class="n">exec_</span><span class="p">()</span>
</pre></div>
</div>
<p>In the above example, we neglected to mention how to handle selections of items. This subject is covered in more detail in the section about <a class="reference internal" href="#model-view-programming"><span class="std std-ref">Handling Selections in Item Views</span></a> .</p>
</div></blockquote>
</div>
<div class="section" id="model-classes">
<span id="id12"></span><h2>Model Classes<a class="headerlink" href="#model-classes" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>Before examining how selections are handled, you may find it useful to examine the concepts used in the model/view framework.</div></blockquote>
</div>
<div class="section" id="basic-concepts">
<span id="id13"></span><h2>Basic concepts<a class="headerlink" href="#basic-concepts" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>In the model/view architecture, the model provides a standard interface that views and delegates use to access data. In Qt, the standard interface is defined by the <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> class. No matter how the items of data are stored in any underlying data structure, all subclasses of <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> represent the data as a hierarchical structure containing tables of items. Views use this <em>convention</em> to access items of data in the model, but they are not restricted in the way that they present this information to the user.</p>
<p>Models also notify any attached views about changes to data through the signals and slots mechanism.</p>
<p>This section describes some basic concepts that are central to the way items of data are accessed by other components via a model class. More advanced concepts are discussed in later sections.</p>
</div></blockquote>
</div>
<div class="section" id="model-indexes">
<span id="id14"></span><h2>Model indexes<a class="headerlink" href="#model-indexes" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>To ensure that the representation of the data is kept separate from the way it is accessed, the concept of a <em>model index</em> is introduced. Each piece of information that can be obtained via a model is represented by a model index. Views and delegates use these indexes to request items of data to display.</p>
<p>As a result, only the model needs to know how to obtain data, and the type of data managed by the model can be defined fairly generally. Model indexes contain a pointer to the model that created them, and this prevents confusion when working with more than one model.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QAbstractItemModel</span> <span class="o">*</span><span class="n">model</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">model</span><span class="p">();</span>
</pre></div>
</div>
<p>Model indexes provide <em>temporary</em> references to pieces of information, and can be used to retrieve or modify data via the model. Since models may reorganize their internal structures from time to time, model indexes may become invalid, and <em>should not be stored</em> . If a long-term reference to a piece of information is required, a <em>persistent model index</em> must be created. This provides a reference to the information that the model keeps up-to-date. Temporary model indexes are provided by the <a class="reference internal" href="../PySide2/QtCore/QModelIndex.html#PySide2.QtCore.QModelIndex" title="PySide2.QtCore.QModelIndex"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QModelIndex</span></code></a> class, and persistent model indexes are provided by the <a class="reference internal" href="../PySide2/QtCore/QPersistentModelIndex.html#PySide2.QtCore.QPersistentModelIndex" title="PySide2.QtCore.QPersistentModelIndex"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QPersistentModelIndex</span></code></a> class.</p>
<p>To obtain a model index that corresponds to an item of data, three properties must be specified to the model: a row number, a column number, and the model index of a parent item. The following sections describe and explain these properties in detail.</p>
</div></blockquote>
</div>
<div class="section" id="rows-and-columns">
<span id="id15"></span><h2>Rows and columns<a class="headerlink" href="#rows-and-columns" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>In its most basic form, a model can be accessed as a simple table in which items are located by their row and column numbers. <em>This does not mean that the underlying pieces of data are stored in an array structure</em> ; the use of row and column numbers is only a convention to allow components to communicate with each other. We can retrieve information about any given item by specifying its row and column numbers to the model, and we receive an index that represents the item:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QModelIndex</span> <span class="n">index</span> <span class="o">=</span> <span class="n">model</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>Models that provide interfaces to simple, single level data structures like lists and tables do not need any other information to be provided but, as the above code indicates, we need to supply more information when obtaining a model index.</p>
<p>++—————————————————————————————————————————————————————————————————————————————————-+
||**Rows and columns**                                                                                                                                                                                                                                |
||                                                                                                                                                                                                                                                    |
||    The diagram shows a representation of a basic table model in which each item is located by a pair of row and column numbers. We obtain a model index that refers to an item of data by passing the relevant row and column numbers to the model.|
||                                                                                                                                                                                                                                                    |
||    ::                                                                                                                                                                                                                                              |
||                                                                                                                                                                                                                                                    |
||        QModelIndex indexA = model-&gt;index(0, 0, QModelIndex());                                                                                                                                                                                     |
||        QModelIndex indexB = model-&gt;index(1, 1, QModelIndex());                                                                                                                                                                                     |
||        QModelIndex indexC = model-&gt;index(2, 1, QModelIndex());                                                                                                                                                                                     |
||                                                                                                                                                                                                                                                    |
||                                                                                                                                                                                                                                                    |
||    Top level items in a model are always referenced by specifying <code class="docutils literal"><span class="pre">QModelIndex()</span></code> as their parent item. This is discussed in the next section.                                                                                                   |
++—————————————————————————————————————————————————————————————————————————————————-+</p>
</div></blockquote>
</div>
<div class="section" id="parents-of-items">
<span id="id16"></span><h2>Parents of items<a class="headerlink" href="#parents-of-items" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The table-like interface to item data provided by models is ideal when using data in a table or list view; the row and column number system maps exactly to the way the views display items. However, structures such as tree views require the model to expose a more flexible interface to the items within. As a result, each item can also be the parent of another table of items, in much the same way that a top-level item in a tree view can contain another list of items.</p>
<p>When requesting an index for a model item, we must provide some information about the item’s parent. Outside the model, the only way to refer to an item is through a model index, so a parent model index must also be given:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QModelIndex</span> <span class="n">index</span> <span class="o">=</span> <span class="n">model</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
</pre></div>
</div>
<p>++—————————————————————————————————————————————-+
||**Parents, rows, and columns**                                                                                                          |
||                                                                                                                                        |
||    The diagram shows a representation of a tree model in which each item is referred to by a parent, a row number, and a column number.|
||                                                                                                                                        |
||    Items “A” and “C” are represented as top-level siblings in the model:                                                               |
||                                                                                                                                        |
||    ::                                                                                                                                  |
||                                                                                                                                        |
||        QModelIndex indexA = model-&gt;index(0, 0, QModelIndex());                                                                         |
||        QModelIndex indexC = model-&gt;index(2, 1, QModelIndex());                                                                         |
||                                                                                                                                        |
||                                                                                                                                        |
||    Item “A” has a number of children. A model index for item “B” is obtained with the following code:                                  |
||                                                                                                                                        |
||    ::                                                                                                                                  |
||                                                                                                                                        |
||        QModelIndex indexB = model-&gt;index(1, 0, indexA);                                                                                |
++—————————————————————————————————————————————-+</p>
</div></blockquote>
</div>
<div class="section" id="item-roles">
<span id="id17"></span><h2>Item roles<a class="headerlink" href="#item-roles" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Items in a model can perform various <em>roles</em> for other components, allowing different kinds of data to be supplied for different situations. For example, <code class="xref py py-attr docutils literal"><span class="pre">Qt.DisplayRole</span></code> is used to access a string that can be displayed as text in a view. Typically, items contain data for a number of different roles, and the standard roles are defined by <code class="xref py py-attr docutils literal"><span class="pre">Qt.ItemDataRole</span></code> .</p>
<p>We can ask the model for the item’s data by passing it the model index corresponding to the item, and by specifying a role to obtain the type of data we want:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QVariant</span> <span class="n">value</span> <span class="o">=</span> <span class="n">model</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">role</span><span class="p">);</span>
</pre></div>
</div>
<p>++———————————————————————————————————————————————————————————————–+
||**Item roles**                                                                                                                                                                                 |
||                                                                                                                                                                                               |
||    The role indicates to the model which type of data is being referred to. Views can display the roles in different ways, so it is important to supply appropriate information for each role.|
||                                                                                                                                                                                               |
||    The <a class="reference internal" href="#model-view-programming"><span class="std std-ref">Creating New Models</span></a> section covers some specific uses of roles in more detail.                                                                          |
++———————————————————————————————————————————————————————————————–+</p>
<p>Most common uses for item data are covered by the standard roles defined in <code class="xref py py-attr docutils literal"><span class="pre">Qt.ItemDataRole</span></code> . By supplying appropriate item data for each role, models can provide hints to views and delegates about how items should be presented to the user. Different kinds of views have the freedom to interpret or ignore this information as required. It is also possible to define additional roles for application-specific purposes.</p>
</div></blockquote>
</div>
<div class="section" id="summary">
<span id="id18"></span><h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li>Model indexes give views and delegates information about the location of items provided by models in a way that is independent of any underlying data structures.</li>
<li>Items are referred to by their row and column numbers, and by the model index of their parent items.</li>
<li>Model indexes are constructed by models at the request of other components, such as views and delegates.</li>
<li>If a valid model index is specified for the parent item when an index is requested using <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.index()</span></code> , the index returned refers to an item beneath that parent item in the model. The index obtained refers to a child of that item.</li>
<li>If an invalid model index is specified for the parent item when an index is requested using <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.index()</span></code> , the index returned refers to a top-level item in the model.</li>
<li>The <code class="xref py py-attr docutils literal"><span class="pre">role</span></code> distinguishes between the different kinds of data associated with an item.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="using-model-indexes">
<span id="id19"></span><h2>Using model indexes<a class="headerlink" href="#using-model-indexes" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>To demonstrate how data can be retrieved from a model, using model indexes, we set up a <a class="reference internal" href="../PySide2/QtWidgets/QFileSystemModel.html#PySide2.QtWidgets.QFileSystemModel" title="PySide2.QtWidgets.QFileSystemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QFileSystemModel</span></code></a> without a view and display the names of files and directories in a widget. Although this does not show a normal way of using a model, it demonstrates the conventions used by models when dealing with model indexes.</p>
<p>We construct a file system model in the following way:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">QFileSystemModel</span><span class="p">()</span>
<span class="n">parentIndex</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">QDir</span><span class="o">.</span><span class="n">currentPath</span><span class="p">())</span>
<span class="n">numRows</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">rowCount</span><span class="p">(</span><span class="n">parentIndex</span><span class="p">)</span>
</pre></div>
</div>
<p>In this case, we set up a default <a class="reference internal" href="../PySide2/QtWidgets/QFileSystemModel.html#PySide2.QtWidgets.QFileSystemModel" title="PySide2.QtWidgets.QFileSystemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QFileSystemModel</span></code></a> , obtain a parent index using a specific implementation of <code class="xref py py-func docutils literal"><span class="pre">QFileSystemModel.index()</span></code> provided by that model, and we count the number of rows in the model using the <code class="xref py py-func docutils literal"><span class="pre">QFileSystemModel.rowCount()</span></code> function.</p>
<p>For simplicity, we are only interested in the items in the first column of the model. We examine each row in turn, obtaining a model index for the first item in each row, and read the data stored for that item in the model.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numRows</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">parentIndex</span><span class="p">)</span>
</pre></div>
</div>
<p>To obtain a model index, we specify the row number, column number (zero for the first column), and the appropriate model index for the parent of all the items that we want. The text stored in each item is retrieved using the model’s <code class="xref py py-func docutils literal"><span class="pre">QFileSystemModel.data()</span></code> function. We specify the model index and the <code class="xref py py-attr docutils literal"><span class="pre">DisplayRole</span></code> to obtain data for the item in the form of a string.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>        <span class="n">text</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Qt</span><span class="o">.</span><span class="n">DisplayRole</span><span class="p">)</span>
        <span class="o">//</span> <span class="n">Display</span> <span class="n">the</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">widget</span><span class="o">.</span>

<span class="o">&lt;</span><span class="n">Code</span> <span class="n">snippet</span> <span class="s2">&quot;simplemodel-use/main.cpp:3&quot;</span> <span class="ow">not</span> <span class="n">found</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The above example demonstrates the basic principles used to retrieve data from a model:</p>
<ul class="simple">
<li>The dimensions of a model can be found using <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.rowCount()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.columnCount()</span></code> . These functions generally require a parent model index to be specified.</li>
<li>Model indexes are used to access items in the model. The row, column, and parent model index are needed to specify the item.</li>
<li>To access top-level items in a model, specify a null model index as the parent index with <code class="docutils literal"><span class="pre">QModelIndex()</span></code>.</li>
<li>Items contain data for different roles. To obtain the data for a particular role, both the model index and the role must be supplied to the model.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="further-reading">
<span id="id20"></span><h2>Further reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>New models can be created by implementing the standard interface provided by <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> . In the <a class="reference internal" href="#model-view-programming"><span class="std std-ref">Creating New Models</span></a> section, we demonstrate this by creating a convenient ready-to-use model for holding lists of strings.</div></blockquote>
</div>
<div class="section" id="view-classes">
<span id="id21"></span><h2>View Classes<a class="headerlink" href="#view-classes" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div></div></blockquote>
</div>
<div class="section" id="concepts">
<span id="id22"></span><h2>Concepts<a class="headerlink" href="#concepts" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>In the model/view architecture, the view obtains items of data from the model and presents them to the user. The way that the data is presented need not resemble the representation of the data provided by the model, and may be <em>completely different</em> from the underlying data structure used to store items of data.</p>
<p>The separation of content and presentation is achieved by the use of a standard model interface provided by <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> , a standard view interface provided by <a class="reference internal" href="../PySide2/QtWidgets/QAbstractItemView.html#PySide2.QtWidgets.QAbstractItemView" title="PySide2.QtWidgets.QAbstractItemView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QAbstractItemView</span></code></a> , and the use of model indexes that represent items of data in a general way. Views typically manage the overall layout of the data obtained from models. They may render individual items of data themselves, or use <a class="reference internal" href="#model-view-programming"><span class="std std-ref">delegates</span></a> to handle both rendering and editing features.</p>
<p>As well as presenting data, views handle navigation between items, and some aspects of item selection. The views also implement basic user interface features, such as context menus and drag and drop. A view can provide default editing facilities for items, or it may work with a <a class="reference internal" href="#model-view-programming"><span class="std std-ref">delegate</span></a> to provide a custom editor.</p>
<p>A view can be constructed without a model, but a model must be provided before it can display useful information. Views keep track of the items that the user has selected through the use of <a class="reference internal" href="#model-view-programming"><span class="std std-ref">selections</span></a> which can be maintained separately for each view, or shared between multiple views.</p>
<p>Some views, such as <a class="reference internal" href="../PySide2/QtWidgets/QTableView.html#PySide2.QtWidgets.QTableView" title="PySide2.QtWidgets.QTableView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTableView</span></code></a> and <a class="reference internal" href="../PySide2/QtWidgets/QTreeView.html#PySide2.QtWidgets.QTreeView" title="PySide2.QtWidgets.QTreeView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTreeView</span></code></a> , display headers as well as items. These are also implemented by a view class, <a class="reference internal" href="../PySide2/QtWidgets/QHeaderView.html#PySide2.QtWidgets.QHeaderView" title="PySide2.QtWidgets.QHeaderView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QHeaderView</span></code></a> . Headers usually access the same model as the view that contains them. They retrieve data from the model using the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.headerData()</span></code> function, and usually display header information in the form of a label. New headers can be subclassed from the <a class="reference internal" href="../PySide2/QtWidgets/QHeaderView.html#PySide2.QtWidgets.QHeaderView" title="PySide2.QtWidgets.QHeaderView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QHeaderView</span></code></a> class to provide more specialized labels for views.</p>
</div></blockquote>
</div>
<div class="section" id="using-an-existing-view">
<span id="id23"></span><h2>Using an existing view<a class="headerlink" href="#using-an-existing-view" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Qt provides three ready-to-use view classes that present data from models in ways that are familiar to most users. <a class="reference internal" href="../PySide2/QtWidgets/QListView.html#PySide2.QtWidgets.QListView" title="PySide2.QtWidgets.QListView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QListView</span></code></a> can display items from a model as a simple list, or in the form of a classic icon view. <a class="reference internal" href="../PySide2/QtWidgets/QTreeView.html#PySide2.QtWidgets.QTreeView" title="PySide2.QtWidgets.QTreeView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTreeView</span></code></a> displays items from a model as a hierarchy of lists, allowing deeply nested structures to be represented in a compact way. <a class="reference internal" href="../PySide2/QtWidgets/QTableView.html#PySide2.QtWidgets.QTableView" title="PySide2.QtWidgets.QTableView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTableView</span></code></a> presents items from a model in the form of a table, much like the layout of a spreadsheet application.</p>
<p>The default behavior of the standard views shown above should be sufficient for most applications. They provide basic editing facilities, and can be customized to suit the needs of more specialized user interfaces.</p>
</div></blockquote>
</div>
<div class="section" id="using-a-model">
<span id="id24"></span><h2>Using a model<a class="headerlink" href="#using-a-model" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>We take the string list model that <a class="reference internal" href="#model-view-programming"><span class="std std-ref">we created as an example model</span></a> , set it up with some data, and construct a view to display the contents of the model. This can all be performed within a single function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">app</span> <span class="o">=</span> <span class="n">QApplication</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span>

<span class="o">//</span> <span class="n">Unindented</span> <span class="k">for</span> <span class="n">quoting</span> <span class="n">purposes</span><span class="p">:</span>

<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;One&quot;</span><span class="p">,</span> <span class="s2">&quot;Two&quot;</span><span class="p">,</span> <span class="s2">&quot;Three&quot;</span><span class="p">,</span> <span class="s2">&quot;Four&quot;</span><span class="p">,</span> <span class="s2">&quot;Five&quot;</span><span class="p">]</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">StringListModel</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal"><span class="pre">StringListModel</span></code> is declared as a <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> . This allows us to use the abstract interface to the model, and ensures that the code still works, even if we replace the string list model with a different model.</p>
<p>The list view provided by <a class="reference internal" href="../PySide2/QtWidgets/QListView.html#PySide2.QtWidgets.QListView" title="PySide2.QtWidgets.QListView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QListView</span></code></a> is sufficient for presenting the items in the string list model. We construct the view, and set up the model using the following lines of code:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">view</span> <span class="o">=</span> <span class="n">QListView</span><span class="p">()</span>
<span class="n">view</span><span class="o">.</span><span class="n">setModel</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
<p>The view is shown in the normal way:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">view</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">exec_</span><span class="p">())</span>
</pre></div>
</div>
<p>The view renders the contents of a model, accessing data via the model’s interface. When the user tries to edit an item, the view uses a default delegate to provide an editor widget.</p>
<p>The above image shows how a <a class="reference internal" href="../PySide2/QtWidgets/QListView.html#PySide2.QtWidgets.QListView" title="PySide2.QtWidgets.QListView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QListView</span></code></a> represents the data in the string list model. Since the model is editable, the view automatically allows each item in the list to be edited using the default delegate.</p>
</div></blockquote>
</div>
<div class="section" id="using-multiple-views-of-a-model">
<span id="id25"></span><h2>Using multiple views of a model<a class="headerlink" href="#using-multiple-views-of-a-model" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Providing multiple views onto the same model is simply a matter of setting the same model for each view. In the following code we create two table views, each using the same simple table model which we have created for this example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QTableView</span> <span class="o">*</span><span class="n">firstTableView</span> <span class="o">=</span> <span class="n">new</span> <span class="n">QTableView</span><span class="p">;</span>
<span class="n">QTableView</span> <span class="o">*</span><span class="n">secondTableView</span> <span class="o">=</span> <span class="n">new</span> <span class="n">QTableView</span><span class="p">;</span>

<span class="n">firstTableView</span><span class="o">-&gt;</span><span class="n">setModel</span><span class="p">(</span><span class="n">model</span><span class="p">);</span>
<span class="n">secondTableView</span><span class="o">-&gt;</span><span class="n">setModel</span><span class="p">(</span><span class="n">model</span><span class="p">);</span>
</pre></div>
</div>
<p>The use of signals and slots in the model/view architecture means that changes to the model can be propagated to all the attached views, ensuring that we can always access the same data regardless of the view being used.</p>
<p>The above image shows two different views onto the same model, each containing a number of selected items. Although the data from the model is shown consistently across view, each view maintains its own internal selection model. This can be useful in certain situations but, for many applications, a shared selection model is desirable.</p>
</div></blockquote>
</div>
<div class="section" id="handling-selections-of-items">
<span id="id26"></span><h2>Handling selections of items<a class="headerlink" href="#handling-selections-of-items" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The mechanism for handling selections of items within views is provided by the <a class="reference internal" href="../PySide2/QtCore/QItemSelectionModel.html#PySide2.QtCore.QItemSelectionModel" title="PySide2.QtCore.QItemSelectionModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QItemSelectionModel</span></code></a> class. All of the standard views construct their own selection models by default, and interact with them in the normal way. The selection model being used by a view can be obtained through the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemView.selectionModel()</span></code> function, and a replacement selection model can be specified with <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemView.setSelectionModel()</span></code> . The ability to control the selection model used by a view is useful when we want to provide multiple consistent views onto the same model data.</p>
<p>Generally, unless you are subclassing a model or view, you don’t need to manipulate the contents of selections directly. However, the interface to the selection model can be accessed, if required, and this is explored in <a class="reference internal" href="#model-view-programming"><span class="std std-ref">Handling Selections in Item Views</span></a> .</p>
</div></blockquote>
</div>
<div class="section" id="sharing-selections-among-views">
<span id="id27"></span><h2>Sharing selections among views<a class="headerlink" href="#sharing-selections-among-views" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Although it is convenient that the view classes provide their own selection models by default, when we use more than one view onto the same model it is often desirable that both the model’s data and the user’s selection are shown consistently in all views. Since the view classes allow their internal selection models to be replaced, we can achieve a unified selection between views with the following line:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">secondTableView</span><span class="o">-&gt;</span><span class="n">setSelectionModel</span><span class="p">(</span><span class="n">firstTableView</span><span class="o">-&gt;</span><span class="n">selectionModel</span><span class="p">());</span>
</pre></div>
</div>
<p>The second view is given the selection model for the first view. Both views now operate on the same selection model, keeping both the data and the selected items synchronized.</p>
<p>In the example shown above, two views of the same type were used to display the same model’s data. However, if two different types of view were used, the selected items may be represented very differently in each view; for example, a contiguous selection in a table view can be represented as a fragmented set of highlighted items in a tree view.</p>
</div></blockquote>
</div>
<div class="section" id="delegate-classes">
<span id="id28"></span><h2>Delegate Classes<a class="headerlink" href="#delegate-classes" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div></div></blockquote>
</div>
<div class="section" id="id29">
<span id="id30"></span><h2>Concepts<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Unlike the Model-View-Controller pattern, the model/view design does not include a completely separate component for managing interaction with the user. Generally, the view is responsible for the presentation of model data to the user, and for processing user input. To allow some flexibility in the way this input is obtained, the interaction is performed by delegates. These components provide input capabilities and are also responsible for rendering individual items in some views. The standard interface for controlling delegates is defined in the <a class="reference internal" href="../PySide2/QtWidgets/QAbstractItemDelegate.html#PySide2.QtWidgets.QAbstractItemDelegate" title="PySide2.QtWidgets.QAbstractItemDelegate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QAbstractItemDelegate</span></code></a> class.</p>
<p>Delegates are expected to be able to render their contents themselves by implementing the <code class="xref py py-func docutils literal"><span class="pre">QItemDelegate.paint()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">QItemDelegate.sizeHint()</span></code> functions. However, simple widget-based delegates can subclass <a class="reference internal" href="../PySide2/QtWidgets/QItemDelegate.html#PySide2.QtWidgets.QItemDelegate" title="PySide2.QtWidgets.QItemDelegate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QItemDelegate</span></code></a> instead of <a class="reference internal" href="../PySide2/QtWidgets/QAbstractItemDelegate.html#PySide2.QtWidgets.QAbstractItemDelegate" title="PySide2.QtWidgets.QAbstractItemDelegate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QAbstractItemDelegate</span></code></a> , and take advantage of the default implementations of these functions.</p>
<p>Editors for delegates can be implemented either by using widgets to manage the editing process or by handling events directly. The first approach is covered later in this section, and it is also shown in the <a class="reference internal" href="qtwidgets-itemviews-spinboxdelegate-example.html#spin-box-delegate-example"><span class="std std-ref">Spin Box Delegate</span></a> example.</p>
<p>The <a class="reference internal" href="qtwidgets-itemviews-pixelator-example.html#pixelator-example"><span class="std std-ref">Pixelator</span></a> example shows how to create a custom delegate that performs specialized rendering for a table view.</p>
</div></blockquote>
</div>
<div class="section" id="using-an-existing-delegate">
<span id="id31"></span><h2>Using an existing delegate<a class="headerlink" href="#using-an-existing-delegate" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The standard views provided with Qt use instances of <a class="reference internal" href="../PySide2/QtWidgets/QItemDelegate.html#PySide2.QtWidgets.QItemDelegate" title="PySide2.QtWidgets.QItemDelegate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QItemDelegate</span></code></a> to provide editing facilities. This default implementation of the delegate interface renders items in the usual style for each of the standard views: <a class="reference internal" href="../PySide2/QtWidgets/QListView.html#PySide2.QtWidgets.QListView" title="PySide2.QtWidgets.QListView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QListView</span></code></a> , <a class="reference internal" href="../PySide2/QtWidgets/QTableView.html#PySide2.QtWidgets.QTableView" title="PySide2.QtWidgets.QTableView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTableView</span></code></a> , and <a class="reference internal" href="../PySide2/QtWidgets/QTreeView.html#PySide2.QtWidgets.QTreeView" title="PySide2.QtWidgets.QTreeView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTreeView</span></code></a> .</p>
<p>All the standard roles are handled by the default delegate used by the standard views. The way these are interpreted is described in the <a class="reference internal" href="../PySide2/QtWidgets/QItemDelegate.html#PySide2.QtWidgets.QItemDelegate" title="PySide2.QtWidgets.QItemDelegate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QItemDelegate</span></code></a> documentation.</p>
<p>The delegate used by a view is returned by the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemView.itemDelegate()</span></code> function. The <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemView.setItemDelegate()</span></code> function allows you to install a custom delegate for a standard view, and it is necessary to use this function when setting the delegate for a custom view.</p>
</div></blockquote>
</div>
<div class="section" id="a-simple-delegate">
<span id="id32"></span><h2>A simple delegate<a class="headerlink" href="#a-simple-delegate" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The delegate implemented here uses a <a class="reference internal" href="../PySide2/QtWidgets/QSpinBox.html#PySide2.QtWidgets.QSpinBox" title="PySide2.QtWidgets.QSpinBox"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QSpinBox</span></code></a> to provide editing facilities, and is mainly intended for use with models that display integers. Although we set up a custom integer-based table model for this purpose, we could easily have used <a class="reference internal" href="../PySide2/QtGui/QStandardItemModel.html#PySide2.QtGui.QStandardItemModel" title="PySide2.QtGui.QStandardItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtGui.QStandardItemModel</span></code></a> instead, since the custom delegate controls data entry. We construct a table view to display the contents of the model, and this will use the custom delegate for editing.</p>
<p>We subclass the delegate from <a class="reference internal" href="../PySide2/QtWidgets/QStyledItemDelegate.html#PySide2.QtWidgets.QStyledItemDelegate" title="PySide2.QtWidgets.QStyledItemDelegate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QStyledItemDelegate</span></code></a> because we do not want to write custom display functions. However, we must still provide functions to manage the editor widget:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SpinBoxDelegate</span> <span class="p">:</span> <span class="n">public</span> <span class="n">QStyledItemDelegate</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>

<span class="n">public</span><span class="p">:</span>
    <span class="n">SpinBoxDelegate</span><span class="p">(</span><span class="n">QObject</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="o">*</span><span class="n">createEditor</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="n">const</span> <span class="n">QStyleOptionViewItem</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">,</span>
                          <span class="n">const</span> <span class="n">QModelIndex</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>

    <span class="n">void</span> <span class="n">setEditorData</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">editor</span><span class="p">,</span> <span class="n">const</span> <span class="n">QModelIndex</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
    <span class="n">void</span> <span class="n">setModelData</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">editor</span><span class="p">,</span> <span class="n">QAbstractItemModel</span> <span class="o">*</span><span class="n">model</span><span class="p">,</span>
                      <span class="n">const</span> <span class="n">QModelIndex</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>

    <span class="n">void</span> <span class="n">updateEditorGeometry</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">editor</span><span class="p">,</span>
        <span class="n">const</span> <span class="n">QStyleOptionViewItem</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">,</span> <span class="n">const</span> <span class="n">QModelIndex</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that no editor widgets are set up when the delegate is constructed. We only construct an editor widget when it is needed.</p>
</div></blockquote>
</div>
<div class="section" id="providing-an-editor">
<span id="id33"></span><h2>Providing an editor<a class="headerlink" href="#providing-an-editor" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>In this example, when the table view needs to provide an editor, it asks the delegate to provide an editor widget that is appropriate for the item being modified. The <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemDelegate.createEditor()</span></code> function is supplied with everything that the delegate needs to be able to set up a suitable widget:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QWidget</span> <span class="o">*</span><span class="n">SpinBoxDelegate</span><span class="p">::</span><span class="n">createEditor</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
    <span class="n">const</span> <span class="n">QStyleOptionViewItem</span> <span class="o">&amp;/*</span> <span class="n">option</span> <span class="o">*/</span><span class="p">,</span>
    <span class="n">const</span> <span class="n">QModelIndex</span> <span class="o">&amp;/*</span> <span class="n">index</span> <span class="o">*/</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
    <span class="n">QSpinBox</span> <span class="o">*</span><span class="n">editor</span> <span class="o">=</span> <span class="n">new</span> <span class="n">QSpinBox</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
    <span class="n">editor</span><span class="o">-&gt;</span><span class="n">setFrame</span><span class="p">(</span><span class="n">false</span><span class="p">);</span>
    <span class="n">editor</span><span class="o">-&gt;</span><span class="n">setMinimum</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">editor</span><span class="o">-&gt;</span><span class="n">setMaximum</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">editor</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that we do not need to keep a pointer to the editor widget because the view takes responsibility for destroying it when it is no longer needed.</p>
<p>We install the delegate’s default event filter on the editor to ensure that it provides the standard editing shortcuts that users expect. Additional shortcuts can be added to the editor to allow more sophisticated behavior; these are discussed in the section on <a class="reference internal" href="#model-view-programming"><span class="std std-ref">Editing Hints</span></a> .</p>
<p>The view ensures that the editor’s data and geometry are set correctly by calling functions that we define later for these purposes. We can create different editors depending on the model index supplied by the view. For example, if we have a column of integers and a column of strings we could return either a <code class="docutils literal"><span class="pre">QSpinBox</span></code> or a <code class="docutils literal"><span class="pre">QLineEdit</span></code> , depending on which column is being edited.</p>
<p>The delegate must provide a function to copy model data into the editor. In this example, we read the data stored in the <code class="xref py py-attr docutils literal"><span class="pre">display</span> <span class="pre">role</span></code> , and set the value in the spin box accordingly.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">SpinBoxDelegate</span><span class="p">::</span><span class="n">setEditorData</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">editor</span><span class="p">,</span>
                                    <span class="n">const</span> <span class="n">QModelIndex</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
    <span class="nb">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">model</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Qt</span><span class="p">::</span><span class="n">EditRole</span><span class="p">)</span><span class="o">.</span><span class="n">toInt</span><span class="p">();</span>

    <span class="n">QSpinBox</span> <span class="o">*</span><span class="n">spinBox</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">QSpinBox</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">editor</span><span class="p">);</span>
    <span class="n">spinBox</span><span class="o">-&gt;</span><span class="n">setValue</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, we know that the editor widget is a spin box, but we could have provided different editors for different types of data in the model, in which case we would need to cast the widget to the appropriate type before accessing its member functions.</p>
</div></blockquote>
</div>
<div class="section" id="submitting-data-to-the-model">
<span id="id34"></span><h2>Submitting data to the model<a class="headerlink" href="#submitting-data-to-the-model" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>When the user has finished editing the value in the spin box, the view asks the delegate to store the edited value in the model by calling the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemDelegate.setModelData()</span></code> function.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">SpinBoxDelegate</span><span class="p">::</span><span class="n">setModelData</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">editor</span><span class="p">,</span> <span class="n">QAbstractItemModel</span> <span class="o">*</span><span class="n">model</span><span class="p">,</span>
                                   <span class="n">const</span> <span class="n">QModelIndex</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
    <span class="n">QSpinBox</span> <span class="o">*</span><span class="n">spinBox</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">QSpinBox</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">editor</span><span class="p">);</span>
    <span class="n">spinBox</span><span class="o">-&gt;</span><span class="n">interpretText</span><span class="p">();</span>
    <span class="nb">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">spinBox</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>

    <span class="n">model</span><span class="o">-&gt;</span><span class="n">setData</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">Qt</span><span class="p">::</span><span class="n">EditRole</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since the view manages the editor widgets for the delegate, we only need to update the model with the contents of the editor supplied. In this case, we ensure that the spin box is up-to-date, and update the model with the value it contains using the index specified.</p>
<p>The standard <a class="reference internal" href="../PySide2/QtWidgets/QItemDelegate.html#PySide2.QtWidgets.QItemDelegate" title="PySide2.QtWidgets.QItemDelegate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QItemDelegate</span></code></a> class informs the view when it has finished editing by emitting the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemDelegate.closeEditor()</span></code> signal. The view ensures that the editor widget is closed and destroyed. In this example, we only provide simple editing facilities, so we need never emit this signal.</p>
<p>All the operations on data are performed through the interface provided by <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> . This makes the delegate mostly independent from the type of data it manipulates, but some assumptions must be made in order to use certain types of editor widgets. In this example, we have assumed that the model always contains integer values, but we can still use this delegate with different kinds of models because <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QVariant</span></code> provides sensible default values for unexpected data.</p>
</div></blockquote>
</div>
<div class="section" id="updating-the-editor-s-geometry">
<span id="id35"></span><h2>Updating the editor’s geometry<a class="headerlink" href="#updating-the-editor-s-geometry" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>It is the responsibility of the delegate to manage the editor’s geometry. The geometry must be set when the editor is created, and when the item’s size or position in the view is changed. Fortunately, the view provides all the necessary geometry information inside a <a class="reference internal" href="../PySide2/QtWidgets/QStyleOptionViewItem.html#PySide2.QtWidgets.QStyleOptionViewItem" title="PySide2.QtWidgets.QStyleOptionViewItem"><code class="xref py py-class docutils literal"><span class="pre">view</span> <span class="pre">option</span></code></a> object.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">SpinBoxDelegate</span><span class="p">::</span><span class="n">updateEditorGeometry</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">editor</span><span class="p">,</span>
    <span class="n">const</span> <span class="n">QStyleOptionViewItem</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">,</span> <span class="n">const</span> <span class="n">QModelIndex</span> <span class="o">&amp;/*</span> <span class="n">index</span> <span class="o">*/</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
    <span class="n">editor</span><span class="o">-&gt;</span><span class="n">setGeometry</span><span class="p">(</span><span class="n">option</span><span class="o">.</span><span class="n">rect</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this case, we just use the geometry information provided by the view option in the item rectangle. A delegate that renders items with several elements would not use the item rectangle directly. It would position the editor in relation to the other elements in the item.</p>
</div></blockquote>
</div>
<div class="section" id="editing-hints">
<span id="id36"></span><span id="id37"></span><h2>Editing hints<a class="headerlink" href="#editing-hints" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>After editing, delegates should provide hints to the other components about the result of the editing process, and provide hints that will assist any subsequent editing operations. This is achieved by emitting the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemDelegate.closeEditor()</span></code> signal with a suitable hint. This is taken care of by the default <a class="reference internal" href="../PySide2/QtWidgets/QItemDelegate.html#PySide2.QtWidgets.QItemDelegate" title="PySide2.QtWidgets.QItemDelegate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QItemDelegate</span></code></a> event filter which we installed on the spin box when it was constructed.</p>
<p>The behavior of the spin box could be adjusted to make it more user friendly. In the default event filter supplied by <a class="reference internal" href="../PySide2/QtWidgets/QItemDelegate.html#PySide2.QtWidgets.QItemDelegate" title="PySide2.QtWidgets.QItemDelegate"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QItemDelegate</span></code></a> , if the user hits Return to confirm their choice in the spin box, the delegate commits the value to the model and closes the spin box. We can change this behavior by installing our own event filter on the spin box, and provide editing hints that suit our needs; for example, we might emit <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemDelegate.closeEditor()</span></code> with the <code class="xref py py-attr docutils literal"><span class="pre">EditNextItem</span></code> hint to automatically start editing the next item in the view.</p>
<p>Another approach that does not require the use of an event filter is to provide our own editor widget, perhaps subclassing <a class="reference internal" href="../PySide2/QtWidgets/QSpinBox.html#PySide2.QtWidgets.QSpinBox" title="PySide2.QtWidgets.QSpinBox"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QSpinBox</span></code></a> for convenience. This alternative approach would give us more control over how the editor widget behaves at the cost of writing additional code. It is usually easier to install an event filter in the delegate if you need to customize the behavior of a standard Qt editor widget.</p>
<p>Delegates do not have to emit these hints, but those that do not will be less integrated into applications, and will be less usable than those that emit hints to support common editing actions.</p>
</div></blockquote>
</div>
<div class="section" id="handling-selections-in-item-views">
<span id="id38"></span><h2>Handling Selections in Item Views<a class="headerlink" href="#handling-selections-in-item-views" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div></div></blockquote>
</div>
<div class="section" id="id39">
<span id="id40"></span><h2>Concepts<a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The selection model used in the item view classes provides a general description of selections based on the facilities of the model/view architecture. Although the standard classes for manipulating selections are sufficient for the item views provided, the selection model allows you to create specialized selection models to suit the requirements for your own item models and views.</p>
<p>Information about the items selected in a view is stored in an instance of the <a class="reference internal" href="../PySide2/QtCore/QItemSelectionModel.html#PySide2.QtCore.QItemSelectionModel" title="PySide2.QtCore.QItemSelectionModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QItemSelectionModel</span></code></a> class. This maintains model indexes for items in a single model, and is independent of any views. Since there can be many views onto a model, it is possible to share selections between views, allowing applications to show multiple views in a consistent way.</p>
<p>Selections are made up of <em>selection ranges</em> . These efficiently maintain information about large selections of items by recording only the starting and ending model indexes for each range of selected items. Non-contiguous selections of items are constructed by using more than one selection range to describe the selection.</p>
<p>Selections are applied to a collection of model indexes held by a selection model. The most recent selection of items applied is known as the <em>current selection</em> . The effects of this selection can be modified even after its application through the use of certain types of selection commands. These are discussed later in this section.</p>
</div></blockquote>
</div>
<div class="section" id="current-item-and-selected-items">
<span id="id41"></span><h2>Current item and selected items<a class="headerlink" href="#current-item-and-selected-items" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>In a view, there is always a current item and a selected item - two independent states. An item can be the current item and selected at the same time. The view is responsible for ensuring that there is always a current item as keyboard navigation, for example, requires a current item.</p>
<p>The table below highlights the differences between current item and selected items.</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Current Item</td>
<td>Selected Items</td>
</tr>
<tr class="row-even"><td>There can only be one current item.</td>
<td>There can be multiple selected items.</td>
</tr>
<tr class="row-odd"><td>The current item will be changed with key navigation or mouse button clicks.</td>
<td>The selected state of items is set or unset, depending on several pre-defined modes - e.g., single selection, multiple selection, etc. - when the user interacts with the items.</td>
</tr>
<tr class="row-even"><td>The current item will be edited if the edit key, F2, is pressed or the item is double-clicked (provided that editing is enabled).</td>
<td>The current item can be used together with an anchor to specify a range that should be selected or deselected (or a combination of the two).</td>
</tr>
<tr class="row-odd"><td>The current item is indicated by the focus rectangle.</td>
<td>The selected items are indicated with the selection rectangle.</td>
</tr>
</tbody>
</table>
<p>When manipulating selections, it is often helpful to think of <a class="reference internal" href="../PySide2/QtCore/QItemSelectionModel.html#PySide2.QtCore.QItemSelectionModel" title="PySide2.QtCore.QItemSelectionModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QItemSelectionModel</span></code></a> as a record of the selection state of all the items in an item model. Once a selection model is set up, collections of items can be selected, deselected, or their selection states can be toggled without the need to know which items are already selected. The indexes of all selected items can be retrieved at any time, and other components can be informed of changes to the selection model via the signals and slots mechanism.</p>
</div></blockquote>
</div>
<div class="section" id="using-a-selection-model">
<span id="id42"></span><h2>Using a selection model<a class="headerlink" href="#using-a-selection-model" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The standard view classes provide default selection models that can be used in most applications. A selection model belonging to one view can be obtained using the view’s <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemView.selectionModel()</span></code> function, and shared between many views with <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemView.setSelectionModel()</span></code> , so the construction of new selection models is generally not required.</p>
<p>A selection is created by specifying a model, and a pair of model indexes to a <a class="reference internal" href="../PySide2/QtCore/QItemSelection.html#PySide2.QtCore.QItemSelection" title="PySide2.QtCore.QItemSelection"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QItemSelection</span></code></a> . This uses the indexes to refer to items in the given model, and interprets them as the top-left and bottom-right items in a block of selected items. To apply the selection to items in a model requires the selection to be submitted to a selection model; this can be achieved in a number of ways, each having a different effect on the selections already present in the selection model.</p>
</div></blockquote>
</div>
<div class="section" id="selecting-items">
<span id="id43"></span><h2>Selecting items<a class="headerlink" href="#selecting-items" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>To demonstrate some of the principal features of selections, we construct an instance of a custom table model with 32 items in total, and open a table view onto its data:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">TableModel</span> <span class="o">*</span><span class="n">model</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TableModel</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">app</span><span class="p">);</span>

<span class="n">QTableView</span> <span class="o">*</span><span class="n">table</span> <span class="o">=</span> <span class="n">new</span> <span class="n">QTableView</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">table</span><span class="o">-&gt;</span><span class="n">setModel</span><span class="p">(</span><span class="n">model</span><span class="p">);</span>

<span class="n">QItemSelectionModel</span> <span class="o">*</span><span class="n">selectionModel</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">selectionModel</span><span class="p">();</span>
</pre></div>
</div>
<p>The table view’s default selection model is retrieved for later use. We do not modify any items in the model, but instead select a few items that the view will display at the top-left of the table. To do this, we need to retrieve the model indexes corresponding to the top-left and bottom-right items in the region to be selected:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QModelIndex</span> <span class="n">topLeft</span><span class="p">;</span>
<span class="n">QModelIndex</span> <span class="n">bottomRight</span><span class="p">;</span>

<span class="n">topLeft</span> <span class="o">=</span> <span class="n">model</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">QModelIndex</span><span class="p">());</span>
<span class="n">bottomRight</span> <span class="o">=</span> <span class="n">model</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">QModelIndex</span><span class="p">());</span>
</pre></div>
</div>
<p>To select these items in the model, and see the corresponding change in the table view, we need to construct a selection object then apply it to the selection model:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QItemSelection</span> <span class="n">selection</span><span class="p">(</span><span class="n">topLeft</span><span class="p">,</span> <span class="n">bottomRight</span><span class="p">);</span>
<span class="n">selectionModel</span><span class="o">-&gt;</span><span class="n">select</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">QItemSelectionModel</span><span class="p">::</span><span class="n">Select</span><span class="p">);</span>
</pre></div>
</div>
<p>The selection is applied to the selection model using a command defined by a combination of <code class="xref py py-attr docutils literal"><span class="pre">selection</span> <span class="pre">flags</span></code> . In this case, the flags used cause the items recorded in the selection object to be included in the selection model, regardless of their previous state. The resulting selection is shown by the view.</p>
<p>The selection of items can be modified using various operations that are defined by the selection flags. The selection that results from these operations may have a complex structure, but it is represented efficiently by the selection model. The use of different selection flags to manipulate the selected items is described when we examine how to update a selection.</p>
</div></blockquote>
</div>
<div class="section" id="reading-the-selection-state">
<span id="id44"></span><h2>Reading the selection state<a class="headerlink" href="#reading-the-selection-state" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The model indexes stored in the selection model can be read using the <code class="xref py py-func docutils literal"><span class="pre">QItemSelectionModel.selectedIndexes()</span></code> function. This returns an unsorted list of model indexes that we can iterate over as long as we know which model they are for:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QModelIndexList</span> <span class="n">indexes</span> <span class="o">=</span> <span class="n">selectionModel</span><span class="o">-&gt;</span><span class="n">selectedIndexes</span><span class="p">();</span>
<span class="n">QModelIndex</span> <span class="n">index</span><span class="p">;</span>

<span class="n">foreach</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">indexes</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">QString</span> <span class="n">text</span> <span class="o">=</span> <span class="n">QString</span><span class="p">(</span><span class="s2">&quot;(%1,%2)&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">row</span><span class="p">())</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">column</span><span class="p">());</span>
    <span class="n">model</span><span class="o">-&gt;</span><span class="n">setData</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">text</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above code uses Qt’s convenient <span class="xref std std-ref">foreach keyword</span> to iterate over, and modify, the items corresponding to the indexes returned by the selection model.</p>
<p>The selection model emits signals to indicate changes in the selection. These notify other components about changes to both the selection as a whole and the currently focused item in the item model. We can connect the <code class="xref py py-func docutils literal"><span class="pre">QItemSelectionModel.selectionChanged()</span></code> signal to a slot, and examine the items in the model that are selected or deselected when the selection changes. The slot is called with two <a class="reference internal" href="../PySide2/QtCore/QItemSelection.html#PySide2.QtCore.QItemSelection" title="PySide2.QtCore.QItemSelection"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QItemSelection</span></code></a> objects: one contains a list of indexes that correspond to newly selected items; the other contains indexes that correspond to newly deselected items.</p>
<p>In the following code, we provide a slot that receives the <code class="xref py py-func docutils literal"><span class="pre">QItemSelectionModel.selectionChanged()</span></code> signal, fills in the selected items with a string, and clears the contents of the deselected items.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">MainWindow</span><span class="p">::</span><span class="n">updateSelection</span><span class="p">(</span><span class="n">const</span> <span class="n">QItemSelection</span> <span class="o">&amp;</span><span class="n">selected</span><span class="p">,</span>
    <span class="n">const</span> <span class="n">QItemSelection</span> <span class="o">&amp;</span><span class="n">deselected</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">QModelIndex</span> <span class="n">index</span><span class="p">;</span>
    <span class="n">QModelIndexList</span> <span class="n">items</span> <span class="o">=</span> <span class="n">selected</span><span class="o">.</span><span class="n">indexes</span><span class="p">();</span>

    <span class="n">foreach</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">items</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">QString</span> <span class="n">text</span> <span class="o">=</span> <span class="n">QString</span><span class="p">(</span><span class="s2">&quot;(%1,%2)&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">row</span><span class="p">())</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">column</span><span class="p">());</span>
        <span class="n">model</span><span class="o">-&gt;</span><span class="n">setData</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">text</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">items</span> <span class="o">=</span> <span class="n">deselected</span><span class="o">.</span><span class="n">indexes</span><span class="p">();</span>

    <span class="n">foreach</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">items</span><span class="p">)</span>
        <span class="n">model</span><span class="o">-&gt;</span><span class="n">setData</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can keep track of the currently focused item by connecting the <code class="xref py py-func docutils literal"><span class="pre">QItemSelectionModel.currentChanged()</span></code> signal to a slot that is called with two model indexes. These correspond to the previously focused item, and the currently focused item.</p>
<p>In the following code, we provide a slot that receives the <code class="xref py py-func docutils literal"><span class="pre">QItemSelectionModel.currentChanged()</span></code> signal, and uses the information provided to update the status bar of a <a class="reference internal" href="../PySide2/QtWidgets/QMainWindow.html#PySide2.QtWidgets.QMainWindow" title="PySide2.QtWidgets.QMainWindow"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QMainWindow</span></code></a> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">MainWindow</span><span class="p">::</span><span class="n">changeCurrent</span><span class="p">(</span><span class="n">const</span> <span class="n">QModelIndex</span> <span class="o">&amp;</span><span class="n">current</span><span class="p">,</span>
    <span class="n">const</span> <span class="n">QModelIndex</span> <span class="o">&amp;</span><span class="n">previous</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">statusBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">showMessage</span><span class="p">(</span>
        <span class="n">tr</span><span class="p">(</span><span class="s2">&quot;Moved from (%1,%2) to (%3,%4)&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">previous</span><span class="o">.</span><span class="n">row</span><span class="p">())</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">previous</span><span class="o">.</span><span class="n">column</span><span class="p">())</span>
            <span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">row</span><span class="p">())</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">column</span><span class="p">()));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Monitoring selections made by the user is straightforward with these signals, but we can also update the selection model directly.</p>
</div></blockquote>
</div>
<div class="section" id="updating-a-selection">
<span id="id45"></span><h2>Updating a selection<a class="headerlink" href="#updating-a-selection" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Selection commands are provided by a combination of selection flags, defined by <code class="xref py py-attr docutils literal"><span class="pre">QItemSelectionModel.SelectionFlag</span></code> . Each selection flag tells the selection model how to update its internal record of selected items when either of the <code class="xref py py-func docutils literal"><span class="pre">QItemSelection.select()</span></code> functions are called. The most commonly used flag is the <code class="xref py py-attr docutils literal"><span class="pre">Select</span></code> flag which instructs the selection model to record the specified items as being selected. The <code class="xref py py-attr docutils literal"><span class="pre">Toggle</span></code> flag causes the selection model to invert the state of the specified items, selecting any deselected items given, and deselecting any currently selected items. The <code class="xref py py-attr docutils literal"><span class="pre">Deselect</span></code> flag deselects all the specified items.</p>
<p>Individual items in the selection model are updated by creating a selection of items, and applying them to the selection model. In the following code, we apply a second selection of items to the table model shown above, using the <code class="xref py py-attr docutils literal"><span class="pre">Toggle</span></code> command to invert the selection state of the items given.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QItemSelection</span> <span class="n">toggleSelection</span><span class="p">;</span>

<span class="n">topLeft</span> <span class="o">=</span> <span class="n">model</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">QModelIndex</span><span class="p">());</span>
<span class="n">bottomRight</span> <span class="o">=</span> <span class="n">model</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">QModelIndex</span><span class="p">());</span>
<span class="n">toggleSelection</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">topLeft</span><span class="p">,</span> <span class="n">bottomRight</span><span class="p">);</span>

<span class="n">selectionModel</span><span class="o">-&gt;</span><span class="n">select</span><span class="p">(</span><span class="n">toggleSelection</span><span class="p">,</span> <span class="n">QItemSelectionModel</span><span class="p">::</span><span class="n">Toggle</span><span class="p">);</span>
</pre></div>
</div>
<p>The results of this operation are displayed in the table view, providing a convenient way of visualizing what we have achieved:</p>
<p>By default, the selection commands only operate on the individual items specified by the model indexes. However, the flag used to describe the selection command can be combined with additional flags to change entire rows and columns. For example if you call <code class="xref py py-func docutils literal"><span class="pre">QItemSelectionModel.select()</span></code> with only one index, but with a command that is a combination of <code class="xref py py-attr docutils literal"><span class="pre">Select</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">Rows</span></code> , the entire row containing the item referred to is selected. The following code demonstrates the use of the <code class="xref py py-attr docutils literal"><span class="pre">Rows</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">Columns</span></code> flags:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QItemSelection</span> <span class="n">columnSelection</span><span class="p">;</span>

<span class="n">topLeft</span> <span class="o">=</span> <span class="n">model</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">QModelIndex</span><span class="p">());</span>
<span class="n">bottomRight</span> <span class="o">=</span> <span class="n">model</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">QModelIndex</span><span class="p">());</span>

<span class="n">columnSelection</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">topLeft</span><span class="p">,</span> <span class="n">bottomRight</span><span class="p">);</span>

<span class="n">selectionModel</span><span class="o">-&gt;</span><span class="n">select</span><span class="p">(</span><span class="n">columnSelection</span><span class="p">,</span>
    <span class="n">QItemSelectionModel</span><span class="p">::</span><span class="n">Select</span> <span class="o">|</span> <span class="n">QItemSelectionModel</span><span class="p">::</span><span class="n">Columns</span><span class="p">);</span>

<span class="n">QItemSelection</span> <span class="n">rowSelection</span><span class="p">;</span>

<span class="n">topLeft</span> <span class="o">=</span> <span class="n">model</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">QModelIndex</span><span class="p">());</span>
<span class="n">bottomRight</span> <span class="o">=</span> <span class="n">model</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">QModelIndex</span><span class="p">());</span>

<span class="n">rowSelection</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">topLeft</span><span class="p">,</span> <span class="n">bottomRight</span><span class="p">);</span>

<span class="n">selectionModel</span><span class="o">-&gt;</span><span class="n">select</span><span class="p">(</span><span class="n">rowSelection</span><span class="p">,</span>
    <span class="n">QItemSelectionModel</span><span class="p">::</span><span class="n">Select</span> <span class="o">|</span> <span class="n">QItemSelectionModel</span><span class="p">::</span><span class="n">Rows</span><span class="p">);</span>
</pre></div>
</div>
<p>Although only four indexes are supplied to the selection model, the use of the <code class="xref py py-attr docutils literal"><span class="pre">Columns</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">Rows</span></code> selection flags means that two columns and two rows are selected. The following image shows the result of these two selections:</p>
<p>The commands performed on the example model have all involved accumulating a selection of items in the model. It is also possible to clear the selection, or to replace the current selection with a new one.</p>
<p>To replace the current selection with a new selection, combine the other selection flags with the <code class="xref py py-attr docutils literal"><span class="pre">Current</span></code> flag. A command using this flag instructs the selection model to replace its current collection of model indexes with those specified in a call to <code class="xref py py-func docutils literal"><span class="pre">QItemSelectionModel.select()</span></code> . To clear all selections before you start adding new ones, combine the other selection flags with the <code class="xref py py-attr docutils literal"><span class="pre">Clear</span></code> flag. This has the effect of resetting the selection model’s collection of model indexes.</p>
</div></blockquote>
</div>
<div class="section" id="selecting-all-items-in-a-model">
<span id="id46"></span><h2>Selecting all items in a model<a class="headerlink" href="#selecting-all-items-in-a-model" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>To select all items in a model, it is necessary to create a selection for each level of the model that covers all items in that level. We do this by retrieving the indexes corresponding to the top-left and bottom-right items with a given parent index:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QModelIndex</span> <span class="n">topLeft</span> <span class="o">=</span> <span class="n">model</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
<span class="n">QModelIndex</span> <span class="n">bottomRight</span> <span class="o">=</span> <span class="n">model</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">(</span><span class="n">model</span><span class="o">-&gt;</span><span class="n">rowCount</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">model</span><span class="o">-&gt;</span><span class="n">columnCount</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
</pre></div>
</div>
<p>A selection is constructed with these indexes and the model. The corresponding items are then selected in the selection model:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QItemSelection</span> <span class="n">selection</span><span class="p">(</span><span class="n">topLeft</span><span class="p">,</span> <span class="n">bottomRight</span><span class="p">);</span>
<span class="n">selectionModel</span><span class="o">-&gt;</span><span class="n">select</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">QItemSelectionModel</span><span class="p">::</span><span class="n">Select</span><span class="p">);</span>
</pre></div>
</div>
<p>This needs to be performed for all levels in the model. For top-level items, we would define the parent index in the usual way:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QModelIndex</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">QModelIndex</span><span class="p">();</span>
</pre></div>
</div>
<p>For hierarchical models, the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.hasChildren()</span></code> function is used to determine whether any given item is the parent of another level of items.</p>
</div></blockquote>
</div>
<div class="section" id="creating-new-models">
<span id="id47"></span><h2>Creating New Models<a class="headerlink" href="#creating-new-models" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The separation of functionality between the model/view components allows models to be created that can take advantage of existing views. This approach lets us present data from a variety of sources using standard graphical user interface components, such as <a class="reference internal" href="../PySide2/QtWidgets/QListView.html#PySide2.QtWidgets.QListView" title="PySide2.QtWidgets.QListView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QListView</span></code></a> , <a class="reference internal" href="../PySide2/QtWidgets/QTableView.html#PySide2.QtWidgets.QTableView" title="PySide2.QtWidgets.QTableView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTableView</span></code></a> , and <a class="reference internal" href="../PySide2/QtWidgets/QTreeView.html#PySide2.QtWidgets.QTreeView" title="PySide2.QtWidgets.QTreeView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTreeView</span></code></a> .</p>
<p>The <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> class provides an interface that is flexible enough to support data sources that arrange information in hierarchical structures, allowing for the possibility that data will be inserted, removed, modified, or sorted in some way. It also provides support for drag and drop operations.</p>
<p>The <a class="reference internal" href="../PySide2/QtCore/QAbstractListModel.html#PySide2.QtCore.QAbstractListModel" title="PySide2.QtCore.QAbstractListModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractListModel</span></code></a> and <a class="reference internal" href="../PySide2/QtCore/QAbstractTableModel.html#PySide2.QtCore.QAbstractTableModel" title="PySide2.QtCore.QAbstractTableModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractTableModel</span></code></a> classes provide support for interfaces to simpler non-hierarchical data structures, and are easier to use as a starting point for simple list and table models.</p>
<p>In this section, we create a simple read-only model to explore the basic principles of the model/view architecture. Later in this section, we adapt this simple model so that items can be modified by the user.</p>
<p>For an example of a more complex model, see the <a class="reference internal" href="qtwidgets-itemviews-simpletreemodel-example.html#simple-tree-model-example"><span class="std std-ref">Simple Tree Model</span></a> example.</p>
<p>The requirements of <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> subclasses is described in more detail in the <a class="reference internal" href="#model-view-programming"><span class="std std-ref">Model Subclassing Reference</span></a> document.</p>
</div></blockquote>
</div>
<div class="section" id="designing-a-model">
<span id="id48"></span><h2>Designing a model<a class="headerlink" href="#designing-a-model" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>When creating a new model for an existing data structure, it is important to consider which type of model should be used to provide an interface onto the data. If the data structure can be represented as a list or table of items, you can subclass <a class="reference internal" href="../PySide2/QtCore/QAbstractListModel.html#PySide2.QtCore.QAbstractListModel" title="PySide2.QtCore.QAbstractListModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractListModel</span></code></a> or <a class="reference internal" href="../PySide2/QtCore/QAbstractTableModel.html#PySide2.QtCore.QAbstractTableModel" title="PySide2.QtCore.QAbstractTableModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractTableModel</span></code></a> since these classes provide suitable default implementations for many functions.</p>
<p>However, if the underlying data structure can only be represented by a hierarchical tree structure, it is necessary to subclass <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> . This approach is taken in the <a class="reference internal" href="qtwidgets-itemviews-simpletreemodel-example.html#simple-tree-model-example"><span class="std std-ref">Simple Tree Model</span></a> example.</p>
<p>In this section, we implement a simple model based on a list of strings, so the <a class="reference internal" href="../PySide2/QtCore/QAbstractListModel.html#PySide2.QtCore.QAbstractListModel" title="PySide2.QtCore.QAbstractListModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractListModel</span></code></a> provides an ideal base class on which to build.</p>
<p>Whatever form the underlying data structure takes, it is usually a good idea to supplement the standard <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> API in specialized models with one that allows more natural access to the underlying data structure. This makes it easier to populate the model with data, yet still enables other general model/view components to interact with it using the standard API. The model described below provides a custom constructor for just this purpose.</p>
</div></blockquote>
</div>
<div class="section" id="a-read-only-example-model">
<span id="id49"></span><h2>A read-only example model<a class="headerlink" href="#a-read-only-example-model" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The model implemented here is a simple, non-hierarchical, read-only data model based on the standard <a class="reference internal" href="../PySide2/QtCore/QStringListModel.html#PySide2.QtCore.QStringListModel" title="PySide2.QtCore.QStringListModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QStringListModel</span></code></a> class. It has a <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QStringList</span></code> as its internal data source, and implements only what is needed to make a functioning model. To make the implementation easier, we subclass <a class="reference internal" href="../PySide2/QtCore/QAbstractListModel.html#PySide2.QtCore.QAbstractListModel" title="PySide2.QtCore.QAbstractListModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractListModel</span></code></a> because it defines sensible default behavior for list models, and it exposes a simpler interface than the <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> class.</p>
<p>When implementing a model it is important to remember that <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> does not store any data itself, it merely presents an interface that the views use to access the data. For a minimal read-only model it is only necessary to implement a few functions as there are default implementations for most of the interface. The class declaration is as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">StringListModel</span> <span class="p">(</span><span class="n">QAbstractListModel</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">QAbstractListModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stringList</span> <span class="o">=</span> <span class="n">strings</span>


    <span class="k">def</span> <span class="nf">rowCount</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">QModelIndex</span><span class="p">()):</span>
        <span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">role</span><span class="p">):</span>
        <span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">headerData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">orientation</span><span class="p">,</span>
                        <span class="n">role</span> <span class="o">=</span> <span class="n">Qt</span><span class="o">.</span><span class="n">DisplayRole</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stringList</span> <span class="o">=</span> <span class="n">strings</span>
</pre></div>
</div>
<p>Apart from the model’s constructor, we only need to implement two functions: <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.rowCount()</span></code> returns the number of rows in the model and <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.data()</span></code> returns an item of data corresponding to a specified model index.</p>
<p>Well behaved models also implement <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.headerData()</span></code> to give tree and table views something to display in their headers.</p>
<p>Note that this is a non-hierarchical model, so we don’t have to worry about the parent-child relationships. If our model was hierarchical, we would also have to implement the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.index()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.parent()</span></code> functions.</p>
<p>The list of strings is stored internally in the <code class="docutils literal"><span class="pre">stringList</span></code> private member variable.</p>
</div></blockquote>
</div>
<div class="section" id="dimensions-of-the-model">
<span id="id50"></span><h2>Dimensions of the model<a class="headerlink" href="#dimensions-of-the-model" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>We want the number of rows in the model to be the same as the number of strings in the string list. We implement the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.rowCount()</span></code> function with this in mind:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rowCount</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stringList</span><span class="p">)</span>
</pre></div>
</div>
<p>Since the model is non-hierarchical, we can safely ignore the model index corresponding to the parent item. By default, models derived from <a class="reference internal" href="../PySide2/QtCore/QAbstractListModel.html#PySide2.QtCore.QAbstractListModel" title="PySide2.QtCore.QAbstractListModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractListModel</span></code></a> only contain one column, so we do not need to reimplement the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.columnCount()</span></code> function.</p>
</div></blockquote>
</div>
<div class="section" id="model-headers-and-data">
<span id="id51"></span><h2>Model headers and data<a class="headerlink" href="#model-headers-and-data" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>For items in the view, we want to return the strings in the string list. The <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.data()</span></code> function is responsible for returning the item of data that corresponds to the index argument:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>QVariant StringListModel::data(const QModelIndex &amp;index, int role) const
{
    if (!index.isValid())
        return QVariant();

    if (index.row() &gt;= stringList.size())
        return QVariant();

    if (role == Qt::DisplayRole)
        return stringList.at(index.row());
    else
        return QVariant();
}
</pre></div>
</div>
<p>We only return a valid <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QVariant</span></code> if the model index supplied is valid, the row number is within the range of items in the string list, and the requested role is one that we support.</p>
<p>Some views, such as <a class="reference internal" href="../PySide2/QtWidgets/QTreeView.html#PySide2.QtWidgets.QTreeView" title="PySide2.QtWidgets.QTreeView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTreeView</span></code></a> and <a class="reference internal" href="../PySide2/QtWidgets/QTableView.html#PySide2.QtWidgets.QTableView" title="PySide2.QtWidgets.QTableView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTableView</span></code></a> , are able to display headers along with the item data. If our model is displayed in a view with headers, we want the headers to show the row and column numbers. We can provide information about the headers by subclassing the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.headerData()</span></code> function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">headerData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">orientation</span><span class="p">,</span> <span class="n">role</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">role</span> <span class="o">!=</span> <span class="n">Qt</span><span class="p">::</span><span class="n">DisplayRole</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="n">Qt</span><span class="p">::</span><span class="n">Horizontal</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;Column </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">section</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;Row </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">section</span>
</pre></div>
</div>
<p>Again, we return a valid <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QVariant</span></code> only if the role is one that we support. The orientation of the header is also taken into account when deciding the exact data to return.</p>
<p>Not all views display headers with the item data, and those that do may be configured to hide them. Nonetheless, it is recommended that you implement the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.headerData()</span></code> function to provide relevant information about the data provided by the model.</p>
<p>An item can have several roles, giving out different data depending on the role specified. The items in our model only have one role, <code class="xref py py-attr docutils literal"><span class="pre">DisplayRole</span></code> , so we return the data for items irrespective of the role specified. However, we could reuse the data we provide for the <code class="xref py py-attr docutils literal"><span class="pre">DisplayRole</span></code> in other roles, such as the <code class="xref py py-attr docutils literal"><span class="pre">ToolTipRole</span></code> that views can use to display information about items in a tooltip.</p>
</div></blockquote>
</div>
<div class="section" id="an-editable-model">
<span id="id52"></span><h2>An editable model<a class="headerlink" href="#an-editable-model" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The read-only model shows how simple choices could be presented to the user but, for many applications, an editable list model is much more useful. We can modify the read-only model to make the items editable by changing the <a class="reference internal" href="qtdatavisualization-qmlbars-example.html#qt-quick-2-bars-example"><span class="std std-ref">data()</span></a> function we implemented for read-only, and by implementing two extra functions: <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.flags()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.setData()</span></code> . The following function declarations are added to the class definition:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">flags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="c1"># ...</span>
<span class="k">def</span> <span class="nf">setData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span>
             <span class="n">role</span> <span class="o">=</span> <span class="n">Qt</span><span class="o">.</span><span class="n">EditRole</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="making-the-model-editable">
<span id="id53"></span><h2>Making the model editable<a class="headerlink" href="#making-the-model-editable" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>A delegate checks whether an item is editable before creating an editor. The model must let the delegate know that its items are editable. We do this by returning the correct flags for each item in the model; in this case, we enable all items and make them both selectable and editable:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">flags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">index</span><span class="o">.</span><span class="n">isValid</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Qt</span><span class="o">.</span><span class="n">ItemIsEnabled</span>

    <span class="k">return</span> <span class="n">QAbstractItemModel</span><span class="o">.</span><span class="n">flags</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">|</span> <span class="n">Qt</span><span class="o">.</span><span class="n">ItemIsEditable</span>
</pre></div>
</div>
<p>Note that we do not have to know how the delegate performs the actual editing process. We only have to provide a way for the delegate to set the data in the model. This is achieved through the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.setData()</span></code> function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">setData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">role</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">isValid</span><span class="p">()</span> <span class="ow">and</span> <span class="n">role</span> <span class="o">==</span> <span class="n">Qt</span><span class="o">.</span><span class="n">EditRole</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stringList</span><span class="p">[</span><span class="n">index</span><span class="o">.</span><span class="n">row</span><span class="p">()]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataChanged</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">;</span>
    <span class="k">return</span> <span class="kc">False</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this model, the item in the string list that corresponds to the model index is replaced by the value provided. However, before we can modify the string list, we must make sure that the index is valid, the item is of the correct type, and that the role is supported. By convention, we insist that the role is the <code class="xref py py-attr docutils literal"><span class="pre">EditRole</span></code> since this is the role used by the standard item delegate. For boolean values, however, you can use <code class="xref py py-attr docutils literal"><span class="pre">Qt.CheckStateRole</span></code> and set the <code class="xref py py-attr docutils literal"><span class="pre">Qt.ItemIsUserCheckable</span></code> flag; a checkbox is then used for editing the value. The underlying data in this model is the same for all roles, so this detail just makes it easier to integrate the model with standard components.</p>
<p>When the data has been set, the model must let the views know that some data has changed. This is done by emitting the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.dataChanged()</span></code> signal. Since only one item of data has changed, the range of items specified in the signal is limited to just one model index.</p>
<p>Also the <a class="reference internal" href="qtdatavisualization-qmlbars-example.html#qt-quick-2-bars-example"><span class="std std-ref">data()</span></a> function needs to be changed to add the <code class="xref py py-attr docutils literal"><span class="pre">Qt.EditRole</span></code> test:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">role</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">index</span><span class="o">.</span><span class="n">isValid</span><span class="p">():</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">row</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">stringList</span><span class="o">.</span><span class="n">size</span><span class="p">():</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">role</span> <span class="o">==</span> <span class="n">Qt</span><span class="o">.</span><span class="n">DisplayRole</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stringList</span><span class="p">[</span><span class="n">index</span><span class="o">.</span><span class="n">row</span><span class="p">()]</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="kc">None</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="inserting-and-removing-rows">
<span id="id54"></span><h2>Inserting and removing rows<a class="headerlink" href="#inserting-and-removing-rows" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>It is possible to change the number of rows and columns in a model. In the string list model it only makes sense to change the number of rows, so we only reimplement the functions for inserting and removing rows. These are declared in the class definition:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">insertRows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">QModelIndex</span><span class="p">()):</span>
    <span class="c1"># ...</span>
<span class="k">def</span> <span class="nf">removeRows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">QModelIndex</span><span class="p">()):</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>Since rows in this model correspond to strings in a list, the <code class="docutils literal"><span class="pre">insertRows()</span></code> function inserts a number of empty strings into the string list before the specified position. The number of strings inserted is equivalent to the number of rows specified.</p>
<p>The parent index is normally used to determine where in the model the rows should be added. In this case, we only have a single top-level list of strings, so we just insert empty strings into that list.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">insertRows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">beginInsertRows</span><span class="p">(</span><span class="n">QModelIndex</span><span class="p">(),</span> <span class="n">position</span><span class="p">,</span> <span class="n">position</span><span class="o">+</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rows</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stringList</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">endInsertRows</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">True</span><span class="p">;</span>
<span class="o">&lt;</span><span class="n">Code</span> <span class="n">snippet</span> <span class="s2">&quot;stringlistmodel/model.cpp:7&quot;</span> <span class="ow">not</span> <span class="n">found</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The model first calls the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.beginInsertRows()</span></code> function to inform other components that the number of rows is about to change. The function specifies the row numbers of the first and last new rows to be inserted, and the model index for their parent item. After changing the string list, it calls <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.endInsertRows()</span></code> to complete the operation and inform other components that the dimensions of the model have changed, returning true to indicate success.</p>
<p>The function to remove rows from the model is also simple to write. The rows to be removed from the model are specified by the position and the number of rows given. We ignore the parent index to simplify our implementation, and just remove the corresponding items from the string list.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">removeRows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">beginRemoveRows</span><span class="p">(</span><span class="n">QModelIndex</span><span class="p">(),</span> <span class="n">position</span><span class="p">,</span> <span class="n">position</span><span class="o">+</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rows</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">stringList</span><span class="p">[</span><span class="n">position</span><span class="p">]</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">endRemoveRows</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">True</span><span class="p">;</span>
<span class="o">&lt;</span><span class="n">Code</span> <span class="n">snippet</span> <span class="s2">&quot;stringlistmodel/model.cpp:9&quot;</span> <span class="ow">not</span> <span class="n">found</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.beginRemoveRows()</span></code> function is always called before any underlying data is removed, and specifies the first and last rows to be removed. This allows other components to access the data before it becomes unavailable. After the rows have been removed, the model emits <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.endRemoveRows()</span></code> to finish the operation and let other components know that the dimensions of the model have changed.</p>
</div></blockquote>
</div>
<div class="section" id="next-steps">
<span id="id55"></span><h2>Next steps<a class="headerlink" href="#next-steps" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>We can display the data provided by this model, or any other model, using the <a class="reference internal" href="../PySide2/QtWidgets/QListView.html#PySide2.QtWidgets.QListView" title="PySide2.QtWidgets.QListView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QListView</span></code></a> class to present the model’s items in the form of a vertical list. For the string list model, this view also provides a default editor so that the items can be manipulated. We examine the possibilities made available by the standard view classes in <a class="reference internal" href="#model-view-programming"><span class="std std-ref">View Classes</span></a> .</p>
<p>The <a class="reference internal" href="#model-view-programming"><span class="std std-ref">Model Subclassing Reference</span></a> document discusses the requirements of <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> subclasses in more detail, and provides a guide to the virtual functions that must be implemented to enable various features in different types of models.</p>
</div></blockquote>
</div>
<div class="section" id="item-view-convenience-classes">
<span id="id56"></span><h2>Item View Convenience Classes<a class="headerlink" href="#item-view-convenience-classes" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The item-based widgets have names which reflect their uses: <code class="docutils literal"><span class="pre">QListWidget</span></code> provides a list of items, <code class="docutils literal"><span class="pre">QTreeWidget</span></code> displays a multi-level tree structure, and <code class="docutils literal"><span class="pre">QTableWidget</span></code> provides a table of cell items. Each class inherits the behavior of the <code class="docutils literal"><span class="pre">QAbstractItemView</span></code> class which implements common behavior for item selection and header management.</div></blockquote>
</div>
<div class="section" id="list-widgets">
<span id="id57"></span><h2>List widgets<a class="headerlink" href="#list-widgets" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Single level lists of items are typically displayed using a <code class="docutils literal"><span class="pre">QListWidget</span></code> and a number of <code class="docutils literal"><span class="pre">QListWidgetItem</span></code> s. A list widget is constructed in the same way as any other widget:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">listWidget</span> <span class="o">=</span> <span class="n">QListWidget</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>List items can be added directly to the list widget when they are constructed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QListWidgetItem</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s2">&quot;Sycamore&quot;</span><span class="p">),</span> <span class="n">listWidget</span><span class="p">)</span>
<span class="n">QListWidgetItem</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s2">&quot;Chestnut&quot;</span><span class="p">),</span> <span class="n">listWidget</span><span class="p">)</span>
<span class="n">QListWidgetItem</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s2">&quot;Mahogany&quot;</span><span class="p">),</span> <span class="n">listWidget</span><span class="p">)</span>
</pre></div>
</div>
<p>They can also be constructed without a parent list widget and added to a list at some later time:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">newItem</span> <span class="o">=</span> <span class="n">QListWidgetItem</span><span class="p">()</span>
<span class="n">newItem</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="n">itemText</span><span class="p">)</span>
<span class="n">listWidget</span><span class="o">.</span><span class="n">insertItem</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">newItem</span><span class="p">)</span>
</pre></div>
</div>
<p>Each item in a list can display a text label and an icon. The colors and font used to render the text can be changed to provide a customized appearance for items. Tooltips, status tips, and “What’s This?” help are all easily configured to ensure that the list is properly integrated into the application.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">newItem</span><span class="o">.</span><span class="n">setToolTip</span><span class="p">(</span><span class="n">toolTipText</span><span class="p">)</span>
<span class="n">newItem</span><span class="o">.</span><span class="n">setStatusTip</span><span class="p">(</span><span class="n">toolTipText</span><span class="p">)</span>
<span class="n">newItem</span><span class="o">.</span><span class="n">setWhatsThis</span><span class="p">(</span><span class="n">whatsThisText</span><span class="p">)</span>
</pre></div>
</div>
<p>By default, items in a list are presented in the order of their creation. Lists of items can be sorted according to the criteria given in <code class="xref py py-attr docutils literal"><span class="pre">Qt.SortOrder</span></code> to produce a list of items that is sorted in forward or reverse alphabetical order:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">listWidget</span><span class="o">.</span><span class="n">sortItems</span><span class="p">(</span><span class="n">Qt</span><span class="o">.</span><span class="n">AscendingOrder</span><span class="p">)</span>
<span class="n">listWidget</span><span class="o">.</span><span class="n">sortItems</span><span class="p">(</span><span class="n">Qt</span><span class="o">.</span><span class="n">DescendingOrder</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="tree-widgets">
<span id="id58"></span><h2>Tree widgets<a class="headerlink" href="#tree-widgets" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Trees or hierarchical lists of items are provided by the <code class="docutils literal"><span class="pre">QTreeWidget</span></code> and <code class="docutils literal"><span class="pre">QTreeWidgetItem</span></code> classes. Each item in the tree widget can have child items of its own, and can display a number of columns of information. Tree widgets are created just like any other widget:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">treeWidget</span> <span class="o">=</span>  <span class="n">QTreeWidget</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>Before items can be added to the tree widget, the number of columns must be set. For example, we could define two columns, and create a header to provide labels at the top of each column:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">treeWidget</span><span class="o">.</span><span class="n">setColumnCount</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">headers</span> <span class="o">=</span> <span class="n">QStringList</span><span class="p">()</span>
<span class="n">headers</span> <span class="o">&lt;&lt;</span> <span class="n">tr</span><span class="p">(</span><span class="s2">&quot;Subject&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">tr</span><span class="p">(</span><span class="s2">&quot;Default&quot;</span><span class="p">)</span>
<span class="n">treeWidget</span><span class="o">.</span><span class="n">setHeaderLabels</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span>
</pre></div>
</div>
<p>The easiest way to set up the labels for each section is to supply a string list. For more sophisticated headers, you can construct a tree item, decorate it as you wish, and use that as the tree widget’s header.</p>
<p>Top-level items in the tree widget are constructed with the tree widget as their parent widget. They can be inserted in an arbitrary order, or you can ensure that they are listed in a particular order by specifying the previous item when constructing each item:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">cities</span> <span class="o">=</span>  <span class="n">QTreeWidgetItem</span><span class="p">(</span><span class="n">treeWidget</span><span class="p">)</span>
<span class="n">cities</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tr</span><span class="p">(</span><span class="s2">&quot;Cities&quot;</span><span class="p">))</span>
<span class="n">osloItem</span> <span class="o">=</span>  <span class="n">QTreeWidgetItem</span><span class="p">(</span><span class="n">cities</span><span class="p">)</span>
<span class="n">osloItem</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tr</span><span class="p">(</span><span class="s2">&quot;Oslo&quot;</span><span class="p">))</span>
<span class="n">osloItem</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">tr</span><span class="p">(</span><span class="s2">&quot;Yes&quot;</span><span class="p">))</span>

<span class="n">planets</span> <span class="o">=</span>  <span class="n">QTreeWidgetItem</span><span class="p">(</span><span class="n">treeWidget</span><span class="p">,</span> <span class="n">cities</span><span class="p">)</span>
</pre></div>
</div>
<p>Tree widgets deal with top-level items slightly differently to other items from deeper within the tree. Items can be removed from the top level of the tree by calling the tree widget’s <code class="xref py py-func docutils literal"><span class="pre">QTreeWidget.takeTopLevelItem()</span></code> function, but items from lower levels are removed by calling their parent item’s <code class="xref py py-func docutils literal"><span class="pre">QTreeWidgetItem.takeChild()</span></code> function. Items are inserted in the top level of the tree with the <code class="xref py py-func docutils literal"><span class="pre">QTreeWidget.insertTopLevelItem()</span></code> function. At lower levels in the tree, the parent item’s <code class="xref py py-func docutils literal"><span class="pre">QTreeWidgetItem.insertChild()</span></code> function is used.</p>
<p>It is easy to move items around between the top level and lower levels in the tree. We just need to check whether the items are top-level items or not, and this information is supplied by each item’s <code class="docutils literal"><span class="pre">parent()</span></code> function. For example, we can remove the current item in the tree widget regardless of its location:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parent</span> <span class="o">=</span> <span class="n">currentItem</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>

<span class="k">if</span> <span class="n">parent</span><span class="p">:</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">indexOfChild</span><span class="p">(</span><span class="n">treeWidget</span><span class="o">-&gt;</span><span class="n">currentItem</span><span class="p">())</span>
    <span class="n">delete</span> <span class="n">parent</span><span class="o">.</span><span class="n">takeChild</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">treeWidget</span><span class="o">.</span><span class="n">indexOfTopLevelItem</span><span class="p">(</span><span class="n">treeWidget</span><span class="o">-&gt;</span><span class="n">currentItem</span><span class="p">())</span>
    <span class="n">delete</span> <span class="n">treeWidget</span><span class="o">.</span><span class="n">takeTopLevelItem</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
</pre></div>
</div>
<p>Inserting the item somewhere else in the tree widget follows the same pattern:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parent</span> <span class="o">=</span> <span class="n">currentItem</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="k">if</span> <span class="n">parent</span><span class="p">:</span>
    <span class="n">Item</span> <span class="o">=</span> <span class="n">QTreeWidgetItem</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">treeWidget</span><span class="o">.</span><span class="n">currentItem</span><span class="p">())</span>
<span class="k">else</span>
    <span class="n">Item</span> <span class="o">=</span> <span class="n">QTreeWidgetItem</span><span class="p">(</span><span class="n">treeWidget</span><span class="p">,</span> <span class="n">treeWidget</span><span class="o">.</span><span class="n">currentItem</span><span class="p">())</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="table-widgets">
<span id="id59"></span><h2>Table widgets<a class="headerlink" href="#table-widgets" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Tables of items similar to those found in spreadsheet applications are constructed with the <code class="docutils literal"><span class="pre">QTableWidget</span></code> and <code class="docutils literal"><span class="pre">QTableWidgetItem</span></code> . These provide a scrolling table widget with headers and items to use within it.</p>
<p>Tables can be created with a set number of rows and columns, or these can be added to an unsized table as they are needed.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QTableWidget</span> <span class="o">*</span><span class="n">tableWidget</span><span class="p">;</span>
<span class="n">tableWidget</span> <span class="o">=</span> <span class="n">QTableWidget</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>Items are constructed outside the table before being added to the table at the required location:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">newItem</span> <span class="o">=</span> <span class="n">QTableWidgetItem</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">pow</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
<span class="n">tableWidget</span><span class="o">.</span><span class="n">setItem</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">newItem</span><span class="p">)</span>
</pre></div>
</div>
<p>Horizontal and vertical headers can be added to the table by constructing items outside the table and using them as headers:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">valuesHeaderItem</span> <span class="o">=</span> <span class="n">QTableWidgetItem</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s2">&quot;Values&quot;</span><span class="p">))</span>
<span class="n">tableWidget</span><span class="o">.</span><span class="n">setHorizontalHeaderItem</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">valuesHeaderItem</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the rows and columns in the table begin at zero.</p>
</div></blockquote>
</div>
<div class="section" id="common-features">
<span id="id60"></span><h2>Common features<a class="headerlink" href="#common-features" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>There are a number of item-based features common to each of the convenience classes that are available through the same interfaces in each class. We present these in the following sections with some examples for different widgets. Look at the list of <a class="reference internal" href="#model-view-programming"><span class="std std-ref">Model/View Classes</span></a> for each of the widgets for more details about the use of each function used.</div></blockquote>
</div>
<div class="section" id="hidden-items">
<span id="id61"></span><h2>Hidden items<a class="headerlink" href="#hidden-items" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>It is sometimes useful to be able to hide items in an item view widget rather than remove them. Items for all of the above widgets can be hidden and later shown again. You can determine whether an item is hidden by calling the isItemHidden() function, and items can be hidden with <code class="docutils literal"><span class="pre">setItemHidden()</span></code> .</p>
<p>Since this operation is item-based, the same function is available for all three convenience classes.</p>
</div></blockquote>
</div>
<div class="section" id="selections">
<span id="id62"></span><h2>Selections<a class="headerlink" href="#selections" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The way items are selected is controlled by the widget’s selection mode ( <code class="xref py py-attr docutils literal"><span class="pre">QAbstractItemView.SelectionMode</span></code> ). This property controls whether the user can select one or many items and, in many-item selections, whether the selection must be a continuous range of items. The selection mode works in the same way for all of the above widgets.</p>
<p>++————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————–+
||**Single item selections:** Where the user needs to choose a single item from a widget, the default <code class="docutils literal"><span class="pre">SingleSelection</span></code> mode is most suitable. In this mode, the current item and the selected item are the same.                                                                                                                                                                                                                     |
++————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————–+
||**Multi-item selections:** In this mode, the user can toggle the selection state of any item in the widget without changing the existing selection, much like the way non-exclusive checkboxes can be toggled independently.                                                                                                                                                                                                          |
++————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————–+
||**Extended selections:** Widgets that often require many adjacent items to be selected, such as those found in spreadsheets, require the <code class="docutils literal"><span class="pre">ExtendedSelection</span></code> mode. In this mode, continuous ranges of items in the widget can be selected with both the mouse and the keyboard. Complex selections, involving many items that are not adjacent to other selected items in the widget, can also be created if modifier keys are used.|
||                                                                                                                                                                                                                                                                                                                                                                                                                                      |
||    If the user selects an item without using a modifier key, the existing selection is cleared.                                                                                                                                                                                                                                                                                                                                      |
++————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————–+</p>
<p>The selected items in a widget are read using the <code class="docutils literal"><span class="pre">selectedItems()</span></code> function, providing a list of relevant items that can be iterated over. For example, we can find the sum of all the numeric values within a list of selected items with the following code:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>QList&lt;QTableWidgetItem *&gt; selected = tableWidget-&gt;selectedItems();
QTableWidgetItem *item;
int number = 0;
double total = 0;

foreach (item, selected) {
    bool ok;
    double value = item-&gt;text().toDouble(&amp;ok);

    if (ok &amp;&amp; !item-&gt;text().isEmpty()) {
        total += value;
        number++;
    }
}
</pre></div>
</div>
<p>Note that for the single selection mode, the current item will be in the selection. In the multi-selection and extended selection modes, the current item may not lie within the selection, depending on the way the user formed the selection.</p>
</div></blockquote>
</div>
<div class="section" id="searching">
<span id="id63"></span><h2>Searching<a class="headerlink" href="#searching" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>It is often useful to be able to find items within an item view widget, either as a developer or as a service to present to users. All three item view convenience classes provide a common <code class="docutils literal"><span class="pre">findItems()</span></code> function to make this as consistent and simple as possible.</p>
<p>Items are searched for by the text that they contain according to criteria specified by a selection of values from <code class="xref py py-class docutils literal"><span class="pre">Qt.MatchFlags</span></code> . We can obtain a list of matching items with the <code class="docutils literal"><span class="pre">findItems()</span></code> function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">item</span> <span class="o">=</span> <span class="n">QTreeWidgetItem</span><span class="p">()</span>
<span class="n">found</span> <span class="o">=</span> <span class="n">treeWidget</span><span class="o">.</span><span class="n">findItems</span><span class="p">(</span><span class="n">itemText</span><span class="p">,</span> <span class="n">Qt</span><span class="o">.</span><span class="n">MatchWildcard</span><span class="p">)</span>

<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">found</span><span class="p">:</span>
    <span class="n">treeWidget</span><span class="o">.</span><span class="n">setItemSelected</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Show the item.text(0) for each item.</span>
</pre></div>
</div>
<p>The above code causes items in a tree widget to be selected if they contain the text given in the search string. This pattern can also be used in the list and table widgets.</p>
</div></blockquote>
</div>
<div class="section" id="using-drag-and-drop-with-item-views">
<span id="id64"></span><h2>Using Drag and Drop with Item Views<a class="headerlink" href="#using-drag-and-drop-with-item-views" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Qt’s drag and drop infrastructure is fully supported by the model/view framework. Items in lists, tables, and trees can be dragged within the views, and data can be imported and exported as MIME-encoded data.</p>
<p>The standard views automatically support internal drag and drop, where items are moved around to change the order in which they are displayed. By default, drag and drop is not enabled for these views because they are configured for the simplest, most common uses. To allow items to be dragged around, certain properties of the view need to be enabled, and the items themselves must also allow dragging to occur.</p>
<p>The requirements for a model that only allows items to be exported from a view, and which does not allow data to be dropped into it, are fewer than those for a fully-enabled drag and drop model.</p>
<p>See also the <a class="reference internal" href="#model-view-programming"><span class="std std-ref">Model Subclassing Reference</span></a> for more information about enabling drag and drop support in new models.</p>
</div></blockquote>
</div>
<div class="section" id="using-convenience-views">
<span id="id65"></span><h2>Using convenience views<a class="headerlink" href="#using-convenience-views" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Each of the types of item used with <a class="reference internal" href="../PySide2/QtWidgets/QListWidget.html#PySide2.QtWidgets.QListWidget" title="PySide2.QtWidgets.QListWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QListWidget</span></code></a> , <a class="reference internal" href="../PySide2/QtWidgets/QTableWidget.html#PySide2.QtWidgets.QTableWidget" title="PySide2.QtWidgets.QTableWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTableWidget</span></code></a> , and <a class="reference internal" href="../PySide2/QtWidgets/QTreeWidget.html#PySide2.QtWidgets.QTreeWidget" title="PySide2.QtWidgets.QTreeWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTreeWidget</span></code></a> is configured to use a different set of flags by default. For example, each <a class="reference internal" href="../PySide2/QtWidgets/QListWidgetItem.html#PySide2.QtWidgets.QListWidgetItem" title="PySide2.QtWidgets.QListWidgetItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QListWidgetItem</span></code></a> or <a class="reference internal" href="../PySide2/QtWidgets/QTreeWidgetItem.html#PySide2.QtWidgets.QTreeWidgetItem" title="PySide2.QtWidgets.QTreeWidgetItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTreeWidgetItem</span></code></a> is initially enabled, checkable, selectable, and can be used as the source of a drag and drop operation; each <a class="reference internal" href="../PySide2/QtWidgets/QTableWidgetItem.html#PySide2.QtWidgets.QTableWidgetItem" title="PySide2.QtWidgets.QTableWidgetItem"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTableWidgetItem</span></code></a> can also be edited and used as the target of a drag and drop operation.</p>
<p>Although all of the standard items have one or both flags set for drag and drop, you generally need to set various properties in the view itself to take advantage of the built-in support for drag and drop:</p>
<ul class="simple">
<li>To enable item dragging, set the view’s <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemView.dragEnabled()</span></code> property to <code class="docutils literal"><span class="pre">true</span></code>.</li>
<li>To allow the user to drop either internal or external items within the view, set the view’s <code class="xref py py-func docutils literal"><span class="pre">QAbstractScrollArea.viewport()</span></code> ‘s <code class="xref py py-func docutils literal"><span class="pre">QWidget.acceptDrops()</span></code> property to <code class="docutils literal"><span class="pre">true</span></code>.</li>
<li>To show the user where the item currently being dragged will be placed if dropped, set the view’s <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemView.showDropIndicator()</span></code> property. This provides the user with continuously updating information about item placement within the view.</li>
</ul>
<p>For example, we can enable drag and drop in a list widget with the following lines of code:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QListWidget</span> <span class="o">*</span><span class="n">listWidget</span> <span class="o">=</span> <span class="n">new</span> <span class="n">QListWidget</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="n">listWidget</span><span class="o">-&gt;</span><span class="n">setSelectionMode</span><span class="p">(</span><span class="n">QAbstractItemView</span><span class="p">::</span><span class="n">SingleSelection</span><span class="p">);</span>
<span class="n">listWidget</span><span class="o">-&gt;</span><span class="n">setDragEnabled</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>
<span class="n">listWidget</span><span class="o">-&gt;</span><span class="n">viewport</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setAcceptDrops</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>
<span class="n">listWidget</span><span class="o">-&gt;</span><span class="n">setDropIndicatorShown</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>
</pre></div>
</div>
<p>The result is a list widget which allows the items to be copied around within the view, and even lets the user drag items between views containing the same type of data. In both situations, the items are copied rather than moved.</p>
<p>To enable the user to move the items around within the view, we must set the list widget’s <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemView.dragDropMode()</span></code> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">listWidget</span><span class="o">-&gt;</span><span class="n">setDragDropMode</span><span class="p">(</span><span class="n">QAbstractItemView</span><span class="p">::</span><span class="n">InternalMove</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="using-model-view-classes">
<span id="id66"></span><h2>Using model/view classes<a class="headerlink" href="#using-model-view-classes" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Setting up a view for drag and drop follows the same pattern used with the convenience views. For example, a <a class="reference internal" href="../PySide2/QtWidgets/QListView.html#PySide2.QtWidgets.QListView" title="PySide2.QtWidgets.QListView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QListView</span></code></a> can be set up in the same way as a <a class="reference internal" href="../PySide2/QtWidgets/QListWidget.html#PySide2.QtWidgets.QListWidget" title="PySide2.QtWidgets.QListWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QListWidget</span></code></a> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QListView</span> <span class="o">*</span><span class="n">listView</span> <span class="o">=</span> <span class="n">new</span> <span class="n">QListView</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="n">listView</span><span class="o">-&gt;</span><span class="n">setSelectionMode</span><span class="p">(</span><span class="n">QAbstractItemView</span><span class="p">::</span><span class="n">ExtendedSelection</span><span class="p">);</span>
<span class="n">listView</span><span class="o">-&gt;</span><span class="n">setDragEnabled</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>
<span class="n">listView</span><span class="o">-&gt;</span><span class="n">setAcceptDrops</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>
<span class="n">listView</span><span class="o">-&gt;</span><span class="n">setDropIndicatorShown</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>
</pre></div>
</div>
<p>Since access to the data displayed by the view is controlled by a model, the model used also has to provide support for drag and drop operations. The actions supported by a model can be specified by reimplementing the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.supportedDropActions()</span></code> function. For example, copy and move operations are enabled with the following code:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Qt</span><span class="p">::</span><span class="n">DropActions</span> <span class="n">DragDropListModel</span><span class="p">::</span><span class="n">supportedDropActions</span><span class="p">()</span> <span class="n">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Qt</span><span class="p">::</span><span class="n">CopyAction</span> <span class="o">|</span> <span class="n">Qt</span><span class="p">::</span><span class="n">MoveAction</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Although any combination of values from <code class="xref py py-class docutils literal"><span class="pre">Qt.DropActions</span></code> can be given, the model needs to be written to support them. For example, to allow <code class="xref py py-attr docutils literal"><span class="pre">Qt.MoveAction</span></code> to be used properly with a list model, the model must provide an implementation of <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.removeRows()</span></code> , either directly or by inheriting the implementation from its base class.</p>
</div></blockquote>
</div>
<div class="section" id="enabling-drag-and-drop-for-items">
<span id="id67"></span><h2>Enabling drag and drop for items<a class="headerlink" href="#enabling-drag-and-drop-for-items" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Models indicate to views which items can be dragged, and which will accept drops, by reimplementing the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.flags()</span></code> function to provide suitable flags.</p>
<p>For example, a model which provides a simple list based on <a class="reference internal" href="../PySide2/QtCore/QAbstractListModel.html#PySide2.QtCore.QAbstractListModel" title="PySide2.QtCore.QAbstractListModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractListModel</span></code></a> can enable drag and drop for each of the items by ensuring that the flags returned contain the <code class="xref py py-attr docutils literal"><span class="pre">Qt.ItemIsDragEnabled</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">Qt.ItemIsDropEnabled</span></code> values:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Qt</span><span class="p">::</span><span class="n">ItemFlags</span> <span class="n">DragDropListModel</span><span class="p">::</span><span class="n">flags</span><span class="p">(</span><span class="n">const</span> <span class="n">QModelIndex</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">)</span> <span class="n">const</span>
<span class="p">{</span>
    <span class="n">Qt</span><span class="p">::</span><span class="n">ItemFlags</span> <span class="n">defaultFlags</span> <span class="o">=</span> <span class="n">QStringListModel</span><span class="p">::</span><span class="n">flags</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">isValid</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">Qt</span><span class="p">::</span><span class="n">ItemIsDragEnabled</span> <span class="o">|</span> <span class="n">Qt</span><span class="p">::</span><span class="n">ItemIsDropEnabled</span> <span class="o">|</span> <span class="n">defaultFlags</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">Qt</span><span class="p">::</span><span class="n">ItemIsDropEnabled</span> <span class="o">|</span> <span class="n">defaultFlags</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that items can be dropped into the top level of the model, but dragging is only enabled for valid items.</p>
<p>In the above code, since the model is derived from <a class="reference internal" href="../PySide2/QtCore/QStringListModel.html#PySide2.QtCore.QStringListModel" title="PySide2.QtCore.QStringListModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QStringListModel</span></code></a> , we obtain a default set of flags by calling its implementation of the flags() function.</p>
</div></blockquote>
</div>
<div class="section" id="encoding-exported-data">
<span id="id68"></span><h2>Encoding exported data<a class="headerlink" href="#encoding-exported-data" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>When items of data are exported from a model in a drag and drop operation, they are encoded into an appropriate format corresponding to one or more MIME types. Models declare the MIME types that they can use to supply items by reimplementing the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.mimeTypes()</span></code> function, returning a list of standard MIME types.</p>
<p>For example, a model that only provides plain text would provide the following implementation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QStringList</span> <span class="n">DragDropListModel</span><span class="p">::</span><span class="n">mimeTypes</span><span class="p">()</span> <span class="n">const</span>
<span class="p">{</span>
    <span class="n">QStringList</span> <span class="n">types</span><span class="p">;</span>
    <span class="n">types</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;application/vnd.text.list&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">types</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The model must also provide code to encode data in the advertised format. This is achieved by reimplementing the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.mimeData()</span></code> function to provide a <a class="reference internal" href="../PySide2/QtCore/QMimeData.html#PySide2.QtCore.QMimeData" title="PySide2.QtCore.QMimeData"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QMimeData</span></code></a> object, just as in any other drag and drop operation.</p>
<p>The following code shows how each item of data, corresponding to a given list of indexes, is encoded as plain text and stored in a <a class="reference internal" href="../PySide2/QtCore/QMimeData.html#PySide2.QtCore.QMimeData" title="PySide2.QtCore.QMimeData"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QMimeData</span></code></a> object.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mimeData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexes</span><span class="p">):</span>
    <span class="n">mimeData</span> <span class="o">=</span> <span class="n">QMimeData</span><span class="p">()</span>
    <span class="n">encodedData</span> <span class="o">=</span> <span class="n">QByteArray</span><span class="p">()</span>
    <span class="n">stream</span> <span class="o">=</span> <span class="n">QDataStream</span><span class="p">(</span><span class="n">encodedData</span><span class="p">,</span> <span class="n">QIODevice</span><span class="o">.</span><span class="n">WriteOnly</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">isValid</span><span class="p">():</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Qt</span><span class="o">.</span><span class="n">DisplayRole</span><span class="p">)</span>

    <span class="n">mimeData</span><span class="o">.</span><span class="n">setData</span><span class="p">(</span><span class="s2">&quot;application/vnd.text.list&quot;</span><span class="p">,</span> <span class="n">encodedData</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mimeData</span><span class="p">;</span>
</pre></div>
</div>
<p>Since a list of model indexes is supplied to the function, this approach is general enough to be used in both hierarchical and non-heirarchical models.</p>
<p>Note that custom datatypes must be declared as <a class="reference internal" href="../PySide2/QtCore/QMetaObject.html#PySide2.QtCore.QMetaObject" title="PySide2.QtCore.QMetaObject"><code class="xref py py-class docutils literal"><span class="pre">meta</span> <span class="pre">objects</span></code></a> and that stream operators must be implemented for them. See the <a class="reference internal" href="../PySide2/QtCore/QMetaObject.html#PySide2.QtCore.QMetaObject" title="PySide2.QtCore.QMetaObject"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QMetaObject</span></code></a> class description for details.</p>
</div></blockquote>
</div>
<div class="section" id="inserting-dropped-data-into-a-model">
<span id="id69"></span><h2>Inserting dropped data into a model<a class="headerlink" href="#inserting-dropped-data-into-a-model" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The way that any given model handles dropped data depends on both its type (list, table, or tree) and the way its contents is likely to be presented to the user. Generally, the approach taken to accommodate dropped data should be the one that most suits the model’s underlying data store.</p>
<p>Different types of model tend to handle dropped data in different ways. List and table models only provide a flat structure in which items of data are stored. As a result, they may insert new rows (and columns) when data is dropped on an existing item in a view, or they may overwrite the item’s contents in the model using some of the data supplied. Tree models are often able to add child items containing new data to their underlying data stores, and will therefore behave more predictably as far as the user is concerned.</p>
<p>Dropped data is handled by a model’s reimplementation of <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.dropMimeData()</span></code> . For example, a model that handles a simple list of strings can provide an implementation that handles data dropped onto existing items separately to data dropped into the top level of the model (i.e., onto an invalid item).</p>
<p>Models can forbid dropping on certain items, or depending on the dropped data, by reimplementing <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.canDropMimeData()</span></code> .</p>
<p>The model first has to make sure that the operation should be acted on, the data supplied is in a format that can be used, and that its destination within the model is valid:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>bool DragDropListModel::dropMimeData(const QMimeData *data,
    Qt::DropAction action, int row, int column, const QModelIndex &amp;parent)
{
    if (action == Qt::IgnoreAction)
        return true;

    if (!data-&gt;hasFormat(&quot;application/vnd.text.list&quot;))
        return false;

    if (column &gt; 0)
        return false;
</pre></div>
</div>
<p>A simple one column string list model can indicate failure if the data supplied is not plain text, or if the column number given for the drop is invalid.</p>
<p>The data to be inserted into the model is treated differently depending on whether it is dropped onto an existing item or not. In this simple example, we want to allow drops between existing items, before the first item in the list, and after the last item.</p>
<p>When a drop occurs, the model index corresponding to the parent item will either be valid, indicating that the drop occurred on an item, or it will be invalid, indicating that the drop occurred somewhere in the view that corresponds to top level of the model.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">beginRow</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">beginRow</span> <span class="o">=</span> <span class="n">row</span><span class="p">;</span>
</pre></div>
</div>
<p>We initially examine the row number supplied to see if we can use it to insert items into the model, regardless of whether the parent index is valid or not.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">isValid</span><span class="p">())</span>
    <span class="n">beginRow</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">row</span><span class="p">();</span>
</pre></div>
</div>
<p>If the parent model index is valid, the drop occurred on an item. In this simple list model, we find out the row number of the item and use that value to insert dropped items into the top level of the model.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">else</span>
    <span class="n">beginRow</span> <span class="o">=</span> <span class="n">rowCount</span><span class="p">(</span><span class="n">QModelIndex</span><span class="p">());</span>
</pre></div>
</div>
<p>When a drop occurs elsewhere in the view, and the row number is unusable, we append items to the top level of the model.</p>
<p>In hierarchical models, when a drop occurs on an item, it would be better to insert new items into the model as children of that item. In the simple example shown here, the model only has one level, so this approach is not appropriate.</p>
</div></blockquote>
</div>
<div class="section" id="decoding-imported-data">
<span id="id70"></span><h2>Decoding imported data<a class="headerlink" href="#decoding-imported-data" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Each implementation of <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.dropMimeData()</span></code> must also decode the data and insert it into the model’s underlying data structure.</p>
<p>For a simple string list model, the encoded items can be decoded and streamed into a <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QStringList</span></code> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>QByteArray encodedData = data-&gt;data(&quot;application/vnd.text.list&quot;);
QDataStream stream(&amp;encodedData, QIODevice::ReadOnly);
QStringList newItems;
int rows = 0;

while (!stream.atEnd()) {
    QString text;
    stream &gt;&gt; text;
    newItems &lt;&lt; text;
    ++rows;
}
</pre></div>
</div>
<p>The strings can then be inserted into the underlying data store. For consistency, this can be done through the model’s own interface:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="n">insertRows</span><span class="p">(</span><span class="n">beginRow</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">QModelIndex</span><span class="p">());</span>
    <span class="n">foreach</span> <span class="p">(</span><span class="n">QString</span> <span class="n">text</span><span class="p">,</span> <span class="n">newItems</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">QModelIndex</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">index</span><span class="p">(</span><span class="n">beginRow</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">QModelIndex</span><span class="p">());</span>
        <span class="n">setData</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">text</span><span class="p">);</span>
        <span class="n">beginRow</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that the model will typically need to provide implementations of the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.insertRows()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.setData()</span></code> functions.</p>
</div></blockquote>
</div>
<div class="section" id="proxy-models">
<span id="id71"></span><h2>Proxy Models<a class="headerlink" href="#proxy-models" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>In the model/view framework, items of data supplied by a single model can be shared by any number of views, and each of these can possibly represent the same information in completely different ways. Custom views and delegates are effective ways to provide radically different representations of the same data. However, applications often need to provide conventional views onto processed versions of the same data, such as differently-sorted views onto a list of items.</p>
<p>Although it seems appropriate to perform sorting and filtering operations as internal functions of views, this approach does not allow multiple views to share the results of such potentially costly operations. The alternative approach, involving sorting within the model itself, leads to the similar problem where each view has to display items of data that are organized according to the most recent processing operation.</p>
<p>To solve this problem, the model/view framework uses proxy models to manage the information supplied between individual models and views. Proxy models are components that behave like ordinary models from the perspective of a view, and access data from source models on behalf of that view. The signals and slots used by the model/view framework ensure that each view is updated appropriately no matter how many proxy models are placed between itself and the source model.</p>
</div></blockquote>
</div>
<div class="section" id="using-proxy-models">
<span id="id72"></span><h2>Using proxy models<a class="headerlink" href="#using-proxy-models" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Proxy models can be inserted between an existing model and any number of views. Qt is supplied with a standard proxy model, <a class="reference internal" href="../PySide2/QtCore/QSortFilterProxyModel.html#PySide2.QtCore.QSortFilterProxyModel" title="PySide2.QtCore.QSortFilterProxyModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QSortFilterProxyModel</span></code></a> , that is usually instantiated and used directly, but can also be subclassed to provide custom filtering and sorting behavior. The <a class="reference internal" href="../PySide2/QtCore/QSortFilterProxyModel.html#PySide2.QtCore.QSortFilterProxyModel" title="PySide2.QtCore.QSortFilterProxyModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QSortFilterProxyModel</span></code></a> class can be used in the following way:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QSortFilterProxyModel</span> <span class="o">*</span><span class="n">filterModel</span> <span class="o">=</span> <span class="n">new</span> <span class="n">QSortFilterProxyModel</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
<span class="n">filterModel</span><span class="o">-&gt;</span><span class="n">setSourceModel</span><span class="p">(</span><span class="n">stringListModel</span><span class="p">);</span>

<span class="n">QListView</span> <span class="o">*</span><span class="n">filteredView</span> <span class="o">=</span> <span class="n">new</span> <span class="n">QListView</span><span class="p">;</span>
<span class="n">filteredView</span><span class="o">-&gt;</span><span class="n">setModel</span><span class="p">(</span><span class="n">filterModel</span><span class="p">);</span>
</pre></div>
</div>
<p>Since proxy models inherit from <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> , they can be connected to any kind of view, and can be shared between views. They can also be used to process the information obtained from other proxy models in a pipeline arrangement.</p>
<p>The <a class="reference internal" href="../PySide2/QtCore/QSortFilterProxyModel.html#PySide2.QtCore.QSortFilterProxyModel" title="PySide2.QtCore.QSortFilterProxyModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QSortFilterProxyModel</span></code></a> class is designed to be instantiated and used directly in applications. More specialized proxy models can be created by subclassing this classes and implementing the required comparison operations.</p>
</div></blockquote>
</div>
<div class="section" id="customizing-proxy-models">
<span id="id73"></span><h2>Customizing proxy models<a class="headerlink" href="#customizing-proxy-models" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Generally, the type of processing used in a proxy model involves mapping each item of data from its original location in the source model to either a different location in the proxy model. In some models, some items may have no corresponding location in the proxy model; these models are <em>filtering</em> proxy models. Views access items using model indexes provided by the proxy model, and these contain no information about the source model or the locations of the original items in that model.</p>
<p><a class="reference internal" href="../PySide2/QtCore/QSortFilterProxyModel.html#PySide2.QtCore.QSortFilterProxyModel" title="PySide2.QtCore.QSortFilterProxyModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QSortFilterProxyModel</span></code></a> enables data from a source model to be filtered before being supplied to views, and also allows the contents of a source model to be supplied to views as pre-sorted data.</p>
</div></blockquote>
</div>
<div class="section" id="custom-filtering-models">
<span id="id74"></span><h2>Custom filtering models<a class="headerlink" href="#custom-filtering-models" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The <a class="reference internal" href="../PySide2/QtCore/QSortFilterProxyModel.html#PySide2.QtCore.QSortFilterProxyModel" title="PySide2.QtCore.QSortFilterProxyModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QSortFilterProxyModel</span></code></a> class provides a filtering model that is fairly versatile, and which can be used in a variety of common situations. For advanced users, <a class="reference internal" href="../PySide2/QtCore/QSortFilterProxyModel.html#PySide2.QtCore.QSortFilterProxyModel" title="PySide2.QtCore.QSortFilterProxyModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QSortFilterProxyModel</span></code></a> can be subclassed, providing a mechanism that enables custom filters to be implemented.</p>
<p>Subclasses of <a class="reference internal" href="../PySide2/QtCore/QSortFilterProxyModel.html#PySide2.QtCore.QSortFilterProxyModel" title="PySide2.QtCore.QSortFilterProxyModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QSortFilterProxyModel</span></code></a> can reimplement two virtual functions that are called whenever a model index from the proxy model is requested or used:</p>
<ul class="simple">
<li><code class="xref py py-func docutils literal"><span class="pre">QSortFilterProxyModel.filterAcceptsColumn()</span></code> is used to filter specific columns from part of the source model.</li>
<li><code class="xref py py-func docutils literal"><span class="pre">QSortFilterProxyModel.filterAcceptsRow()</span></code> is used to filter specific rows from part of the source model.</li>
</ul>
<p>The default implementations of the above functions in <a class="reference internal" href="../PySide2/QtCore/QSortFilterProxyModel.html#PySide2.QtCore.QSortFilterProxyModel" title="PySide2.QtCore.QSortFilterProxyModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QSortFilterProxyModel</span></code></a> return true to ensure that all items are passed through to views; reimplementations of these functions should return false to filter out individual rows and columns.</p>
</div></blockquote>
</div>
<div class="section" id="custom-sorting-models">
<span id="id75"></span><h2>Custom sorting models<a class="headerlink" href="#custom-sorting-models" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><a class="reference internal" href="../PySide2/QtCore/QSortFilterProxyModel.html#PySide2.QtCore.QSortFilterProxyModel" title="PySide2.QtCore.QSortFilterProxyModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QSortFilterProxyModel</span></code></a> instances use Qt’s built-in <code class="xref py py-func docutils literal"><span class="pre">qStableSort()</span></code> function to set up mappings between items in the source model and those in the proxy model, allowing a sorted hierarchy of items to be exposed to views without modifying the structure of the source model. To provide custom sorting behavior, reimplement the <code class="xref py py-func docutils literal"><span class="pre">QSortFilterProxyModel.lessThan()</span></code> function to perform custom comparisons.</div></blockquote>
</div>
<div class="section" id="model-subclassing-reference">
<span id="id76"></span><h2>Model Subclassing Reference<a class="headerlink" href="#model-subclassing-reference" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Model subclasses need to provide implementations of many of the virtual functions defined in the <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> base class. The number of these functions that need to be implemented depends on the type of model - whether it supplies views with a simple list, a table, or a complex hierarchy of items. Models that inherit from <a class="reference internal" href="../PySide2/QtCore/QAbstractListModel.html#PySide2.QtCore.QAbstractListModel" title="PySide2.QtCore.QAbstractListModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractListModel</span></code></a> and <a class="reference internal" href="../PySide2/QtCore/QAbstractTableModel.html#PySide2.QtCore.QAbstractTableModel" title="PySide2.QtCore.QAbstractTableModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractTableModel</span></code></a> can take advantage of the default implementations of functions provided by those classes. Models that expose items of data in tree-like structures must provide implementations for many of the virtual functions in <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> .</p>
<p>The functions that need to be implemented in a model subclass can be divided into three groups:</p>
<ul class="simple">
<li><strong>Item data handling:</strong> All models need to implement functions to enable views and delegates to query the dimensions of the model, examine items, and retrieve data.</li>
<li><strong>Navigation and index creation:</strong> Hierarchical models need to provide functions that views can call to navigate the tree-like structures they expose, and obtain model indexes for items.</li>
<li><strong>Drag and drop support and MIME type handling:</strong> Models inherit functions that control the way that internal and external drag and drop operations are performed. These functions allow items of data to be described in terms of MIME types that other components and applications can understand.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="item-data-handling">
<span id="id77"></span><h2>Item data handling<a class="headerlink" href="#item-data-handling" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>Models can provide varying levels of access to the data they provide: They can be simple read-only components, some models may support resizing operations, and others may allow items to be edited.</div></blockquote>
</div>
<div class="section" id="read-only-access">
<span id="id78"></span><h2>Read-Only access<a class="headerlink" href="#read-only-access" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>To provide read-only access to data provided by a model, the following functions <em>must</em> be implemented in the model’s subclass:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.flags()</span></code></td>
<td>Used by other components to obtain information about each item provided by the model. In many models, the combination of flags should include <code class="xref py py-attr docutils literal"><span class="pre">Qt.ItemIsEnabled</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">Qt.ItemIsSelectable</span></code> .</td>
</tr>
<tr class="row-even"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.data()</span></code></td>
<td>Used to supply item data to views and delegates. Generally, models only need to supply data for <code class="xref py py-attr docutils literal"><span class="pre">Qt.DisplayRole</span></code> and any application-specific user roles, but it is also good practice to provide data for <code class="xref py py-attr docutils literal"><span class="pre">Qt.ToolTipRole</span></code> , <code class="xref py py-attr docutils literal"><span class="pre">Qt.AccessibleTextRole</span></code> , and <code class="xref py py-attr docutils literal"><span class="pre">Qt.AccessibleDescriptionRole</span></code> . See the <code class="xref py py-attr docutils literal"><span class="pre">Qt.ItemDataRole</span></code> enum documentation for information about the types associated with each role.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.headerData()</span></code></td>
<td>Provides views with information to show in their headers. The information is only retrieved by views that can display header information.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.rowCount()</span></code></td>
<td>Provides the number of rows of data exposed by the model.</td>
</tr>
</tbody>
</table>
<p>These four functions must be implemented in all types of model, including list models ( <a class="reference internal" href="../PySide2/QtCore/QAbstractListModel.html#PySide2.QtCore.QAbstractListModel" title="PySide2.QtCore.QAbstractListModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractListModel</span></code></a> subclasses) and table models ( <a class="reference internal" href="../PySide2/QtCore/QAbstractTableModel.html#PySide2.QtCore.QAbstractTableModel" title="PySide2.QtCore.QAbstractTableModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractTableModel</span></code></a> subclasses).</p>
<p>Additionally, the following functions <em>must</em> be implemented in direct subclasses of <a class="reference internal" href="../PySide2/QtCore/QAbstractTableModel.html#PySide2.QtCore.QAbstractTableModel" title="PySide2.QtCore.QAbstractTableModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractTableModel</span></code></a> and <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> :</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.columnCount()</span></code></td>
<td>Provides the number of columns of data exposed by the model. List models do not provide this function because it is already implemented in <a class="reference internal" href="../PySide2/QtCore/QAbstractListModel.html#PySide2.QtCore.QAbstractListModel" title="PySide2.QtCore.QAbstractListModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractListModel</span></code></a> .</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="editable-items">
<span id="id79"></span><h2>Editable items<a class="headerlink" href="#editable-items" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Editable models allow items of data to be modified, and may also provide functions to allow rows and columns to be inserted and removed. To enable editing, the following functions must be implemented correctly:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.flags()</span></code></td>
<td>Must return an appropriate combination of flags for each item. In particular, the value returned by this function must include <code class="xref py py-attr docutils literal"><span class="pre">Qt.ItemIsEditable</span></code> in addition to the values applied to items in a read-only model.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.setData()</span></code></td>
<td>Used to modify the item of data associated with a specified model index. To be able to accept user input, provided by user interface elements, this function must handle data associated with <code class="xref py py-attr docutils literal"><span class="pre">Qt.EditRole</span></code> . The implementation may also accept data associated with many different kinds of roles specified by <code class="xref py py-attr docutils literal"><span class="pre">Qt.ItemDataRole</span></code> . After changing the item of data, models must emit the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.dataChanged()</span></code> signal to inform other components of the change.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.setHeaderData()</span></code></td>
<td>Used to modify horizontal and vertical header information. After changing the item of data, models must emit the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.headerDataChanged()</span></code> signal to inform other components of the change.</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="resizable-models">
<span id="id80"></span><h2>Resizable models<a class="headerlink" href="#resizable-models" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>All types of model can support the insertion and removal of rows. Table models and hierarchical models can also support the insertion and removal of columns. It is important to notify other components about changes to the model’s dimensions both <em>before</em> and <em>after</em> they occur. As a result, the following functions can be implemented to allow the model to be resized, but implementations must ensure that the appropriate functions are called to notify attached views and delegates:</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.insertRows()</span></code></td>
<td>Used to add new rows and items of data to all types of model. Implementations must call <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.beginInsertRows()</span></code> <em>before</em> inserting new rows into any underlying data structures, and call <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.endInsertRows()</span></code> <em>immediately afterwards</em> .</td>
</tr>
<tr class="row-even"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.removeRows()</span></code></td>
<td>Used to remove rows and the items of data they contain from all types of model. Implementations must call <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.beginRemoveRows()</span></code> <em>before</em> rows are removed from any underlying data structures, and call <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.endRemoveRows()</span></code> <em>immediately afterwards</em> .</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.insertColumns()</span></code></td>
<td>Used to add new columns and items of data to table models and hierarchical models. Implementations must call <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.beginInsertColumns()</span></code> <em>before</em> inserting new columns into any underlying data structures, and call <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.endInsertColumns()</span></code> <em>immediately afterwards</em> .</td>
</tr>
<tr class="row-even"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.removeColumns()</span></code></td>
<td>Used to remove columns and the items of data they contain from table models and hierarchical models. Implementations must call <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.beginRemoveColumns()</span></code> <em>before</em> columns are removed from any underlying data structures, and call <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.endRemoveColumns()</span></code> <em>immediately afterwards</em> .</td>
</tr>
</tbody>
</table>
<p>Generally, these functions should return true if the operation was successful. However, there may be cases where the operation only partly succeeded; for example, if less than the specified number of rows could be inserted. In such cases, the model should return false to indicate failure to enable any attached components to handle the situation.</p>
<p>The signals emitted by the functions called in implementations of the resizing API give attached components the chance to take action before any data becomes unavailable. The encapsulation of insert and remove operations with begin and end functions also enable the model to manage <a class="reference internal" href="../PySide2/QtCore/QPersistentModelIndex.html#PySide2.QtCore.QPersistentModelIndex" title="PySide2.QtCore.QPersistentModelIndex"><code class="xref py py-class docutils literal"><span class="pre">persistent</span> <span class="pre">model</span> <span class="pre">indexes</span></code></a> correctly.</p>
<p>Normally, the begin and end functions are capable of informing other components about changes to the model’s underlying structure. For more complex changes to the model’s structure, perhaps involving internal reorganization, sorting of data or any other structural change, it is necessary to perform the following sequence:</p>
<ul class="simple">
<li>Emit the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.layoutAboutToBeChanged()</span></code> signal</li>
<li>Update internal data which represents the structure of the model.</li>
<li>Update persistent indexes using <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.changePersistentIndexList()</span></code></li>
<li>Emit the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.layoutChanged()</span></code> signal.</li>
</ul>
<p>This sequence can be used for any structural update in lieu of the more high-level and convenient protected methods. For example, if a model of two million rows needs to have all odd numbered rows removed, that is 1 million discountiguous ranges of 1 element each. It would be possible to use beginRemoveRows and endRemoveRows 1 million times, but that would obviously be inefficient. Instead, this can be signalled as a single layout change which updates all necessary persistent indexes at once.</p>
</div></blockquote>
</div>
<div class="section" id="lazy-population-of-model-data">
<span id="id81"></span><h2>Lazy population of model data<a class="headerlink" href="#lazy-population-of-model-data" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Lazy population of model data effectively allows requests for information about the model to be deferred until it is actually needed by views.</p>
<p>Some models need to obtain data from remote sources, or must perform time-consuming operations to obtain information about the way the data is organized. Since views generally request as much information as possible in order to accurately display model data, it can be useful to restrict the amount of information returned to them to reduce unnecessary follow-up requests for data.</p>
<p>In hierarchical models where finding the number of children of a given item is an expensive operation, it is useful to ensure that the model’s <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.rowCount()</span></code> implementation is only called when necessary. In such cases, the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.hasChildren()</span></code> function can be reimplemented to provide an inexpensive way for views to check for the presence of children and, in the case of <a class="reference internal" href="../PySide2/QtWidgets/QTreeView.html#PySide2.QtWidgets.QTreeView" title="PySide2.QtWidgets.QTreeView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTreeView</span></code></a> , draw the appropriate decoration for their parent item.</p>
<p>Whether the reimplementation of <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.hasChildren()</span></code> returns <code class="docutils literal"><span class="pre">true</span></code> or <code class="docutils literal"><span class="pre">false</span></code> , it may not be necessary for the view to call <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.rowCount()</span></code> to find out how many children are present. For example, <a class="reference internal" href="../PySide2/QtWidgets/QTreeView.html#PySide2.QtWidgets.QTreeView" title="PySide2.QtWidgets.QTreeView"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTreeView</span></code></a> does not need to know how many children there are if the parent item has not been expanded to show them.</p>
<p>If it is known that many items will have children, reimplementing <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.hasChildren()</span></code> to unconditionally return <code class="docutils literal"><span class="pre">true</span></code> is sometimes a useful approach to take. This ensures that each item can be later examined for children while making initial population of model data as fast as possible. The only disadvantage is that items without children may be displayed incorrectly in some views until the user attempts to view the non-existent child items.</p>
</div></blockquote>
</div>
<div class="section" id="navigation-and-model-index-creation">
<span id="id82"></span><h2>Navigation and model index creation<a class="headerlink" href="#navigation-and-model-index-creation" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>Hierarchical models need to provide functions that views can call to navigate the tree-like structures they expose, and obtain model indexes for items.</div></blockquote>
</div>
<div class="section" id="parents-and-children">
<span id="id83"></span><h2>Parents and children<a class="headerlink" href="#parents-and-children" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Since the structure exposed to views is determined by the underlying data structure, it is up to each model subclass to create its own model indexes by providing implementations of the following functions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.index()</span></code></td>
<td>Given a model index for a parent item, this function allows views and delegates to access children of that item. If no valid child item - corresponding to the specified row, column, and parent model index, can be found, the function must return QModelIndex(), which is an invalid model index.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.parent()</span></code></td>
<td>Provides a model index corresponding to the parent of any given child item. If the model index specified corresponds to a top-level item in the model, or if there is no valid parent item in the model, the function must return an invalid model index, created with the empty QModelIndex() constructor.</td>
</tr>
</tbody>
</table>
<p>Both functions above use the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.createIndex()</span></code> factory function to generate indexes for other components to use. It is normal for models to supply some unique identifier to this function to ensure that the model index can be re-associated with its corresponding item later on.</p>
</div></blockquote>
</div>
<div class="section" id="drag-and-drop-support-and-mime-type-handling">
<span id="id84"></span><h2>Drag and drop support and MIME type handling<a class="headerlink" href="#drag-and-drop-support-and-mime-type-handling" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The model/view classes support drag and drop operations, providing default behavior that is sufficient for many applications. However, it is also possible to customize the way items are encoded during drag and drop operations, whether they are copied or moved by default, and how they are inserted into existing models.</p>
<p>Additionally, the convenience view classes implement specialized behavior that should closely follow that expected by existing developers. The <a class="reference internal" href="#model-view-programming"><span class="std std-ref">Convenience Views</span></a> section provides an overview of this behavior.</p>
</div></blockquote>
</div>
<div class="section" id="mime-data">
<span id="id85"></span><h2>MIME data<a class="headerlink" href="#mime-data" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>By default, the built-in models and views use an internal MIME type (<code class="docutils literal"><span class="pre">application/x-qabstractitemmodeldatalist</span></code> ) to pass around information about model indexes. This specifies data for a list of items, containing the row and column numbers of each item, and information about the roles that each item supports.</p>
<p>Data encoded using this MIME type can be obtained by calling <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.mimeData()</span></code> with a <code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QModelIndexList</span></code> containing the items to be serialized.</p>
<p>When implementing drag and drop support in a custom model, it is possible to export items of data in specialized formats by reimplementing the following function:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.mimeData()</span></code></td>
<td><p class="first">This function can be reimplemented to return data in formats other than the default <code class="docutils literal"><span class="pre">application/x-qabstractitemmodeldatalist</span></code> internal MIME type.</p>
<blockquote class="last">
<div>Subclasses can obtain the default <a class="reference internal" href="../PySide2/QtCore/QMimeData.html#PySide2.QtCore.QMimeData" title="PySide2.QtCore.QMimeData"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QMimeData</span></code></a> object from the base class and add data to it in additional formats.</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p>For many models, it is useful to provide the contents of items in common format represented by MIME types such as <code class="docutils literal"><span class="pre">text/plain</span></code> and <code class="docutils literal"><span class="pre">image/png</span></code> . Note that images, colors and HTML documents can easily be added to a <a class="reference internal" href="../PySide2/QtCore/QMimeData.html#PySide2.QtCore.QMimeData" title="PySide2.QtCore.QMimeData"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QMimeData</span></code></a> object with the <code class="xref py py-func docutils literal"><span class="pre">QMimeData.setImageData()</span></code> , <code class="xref py py-func docutils literal"><span class="pre">QMimeData.setColorData()</span></code> , and <code class="xref py py-func docutils literal"><span class="pre">QMimeData.setHtml()</span></code> functions.</p>
</div></blockquote>
</div>
<div class="section" id="accepting-dropped-data">
<span id="id86"></span><h2>Accepting dropped data<a class="headerlink" href="#accepting-dropped-data" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>When a drag and drop operation is performed over a view, the underlying model is queried to determine which types of operation it supports and the MIME types it can accept. This information is provided by the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.supportedDropActions()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.mimeTypes()</span></code> functions. Models that do not override the implementations provided by <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> support copy operations and the default internal MIME type for items.</p>
<p>When serialized item data is dropped onto a view, the data is inserted into the current model using its implementation of <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.dropMimeData()</span></code> . The default implementation of this function will never overwrite any data in the model; instead, it tries to insert the items of data either as siblings of an item, or as children of that item.</p>
<p>To take advantage of <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> ‘s default implementation for the built-in MIME type, new models must provide reimplementations of the following functions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.insertRows()</span></code></td>
<td rowspan="2">These functions enable the model to automatically insert new data using the existing implementation provided by <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.dropMimeData()</span></code> .</td>
</tr>
<tr class="row-even"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.insertColumns()</span></code></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.setData()</span></code></td>
<td>Allows the new rows and columns to be populated with items.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.setItemData()</span></code></td>
<td>This function provides more efficient support for populating new items.</td>
</tr>
</tbody>
</table>
<p>To accept other forms of data, these functions must be reimplemented:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.supportedDropActions()</span></code></td>
<td>Used to return a combination of <code class="xref py py-class docutils literal"><span class="pre">drop</span> <span class="pre">actions</span></code> , indicating the types of drag and drop operations that the model accepts.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.mimeTypes()</span></code></td>
<td>Used to return a list of MIME types that can be decoded and handled by the model. Generally, the MIME types that are supported for input into the model are the same as those that it can use when encoding data for use by external components.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.dropMimeData()</span></code></td>
<td>Performs the actual decoding of the data transferred by drag and drop operations, determines where in the model it will be set, and inserts new rows and columns where necessary. How this function is implemented in subclasses depends on the requirements of the data exposed by each model.</td>
</tr>
</tbody>
</table>
<p>If the implementation of the <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.dropMimeData()</span></code> function changes the dimensions of a model by inserting or removing rows or columns, or if items of data are modified, care must be taken to ensure that all relevant signals are emitted. It can be useful to simply call reimplementations of other functions in the subclass, such as <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.setData()</span></code> , <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.insertRows()</span></code> , and <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.insertColumns()</span></code> , to ensure that the model behaves consistently.</p>
<p>In order to ensure drag operations work properly, it is important to reimplement the following functions that remove data from the model:</p>
<ul class="simple">
<li><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.removeRows()</span></code></li>
<li><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.removeRow()</span></code></li>
<li><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.removeColumns()</span></code></li>
<li><code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.removeColumn()</span></code></li>
</ul>
<p>For more information about drag and drop with item views, refer to <a class="reference internal" href="#model-view-programming"><span class="std std-ref">Using drag and drop with item views</span></a> .</p>
</div></blockquote>
</div>
<div class="section" id="convenience-views">
<span id="id87"></span><h2>Convenience views<a class="headerlink" href="#convenience-views" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The convenience views ( <a class="reference internal" href="../PySide2/QtWidgets/QListWidget.html#PySide2.QtWidgets.QListWidget" title="PySide2.QtWidgets.QListWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QListWidget</span></code></a> , <a class="reference internal" href="../PySide2/QtWidgets/QTableWidget.html#PySide2.QtWidgets.QTableWidget" title="PySide2.QtWidgets.QTableWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTableWidget</span></code></a> , and <a class="reference internal" href="../PySide2/QtWidgets/QTreeWidget.html#PySide2.QtWidgets.QTreeWidget" title="PySide2.QtWidgets.QTreeWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTreeWidget</span></code></a> ) override the default drag and drop functionality to provide less flexible, but more natural behavior that is appropriate for many applications. For example, since it is more common to drop data into cells in a <a class="reference internal" href="../PySide2/QtWidgets/QTableWidget.html#PySide2.QtWidgets.QTableWidget" title="PySide2.QtWidgets.QTableWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QTableWidget</span></code></a> , replacing the existing contents with the data being transferred, the underlying model will set the data of the target items rather than insert new rows and columns into the model. For more information on drag and drop in convenience views, you can see <a class="reference internal" href="#model-view-programming"><span class="std std-ref">Using drag and drop with item views</span></a> .</div></blockquote>
</div>
<div class="section" id="performance-optimization-for-large-amounts-of-data">
<span id="id88"></span><h2>Performance optimization for large amounts of data<a class="headerlink" href="#performance-optimization-for-large-amounts-of-data" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.canFetchMore()</span></code> function checks if the parent has more data available and returns <code class="docutils literal"><span class="pre">true</span></code> or false accordingly. The <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.fetchMore()</span></code> function fetches data based on the parent specified. Both these functions can be combined, for example, in a database query involving incremental data to populate a <a class="reference internal" href="../PySide2/QtCore/QAbstractItemModel.html#PySide2.QtCore.QAbstractItemModel" title="PySide2.QtCore.QAbstractItemModel"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QAbstractItemModel</span></code></a> . We reimplement <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.canFetchMore()</span></code> to indicate if there is more data to be fetched and <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.fetchMore()</span></code> to populate the model as required.</p>
<p>Another example would be dynamically populated tree models, where we reimplement <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.fetchMore()</span></code> when a branch in the tree model is expanded.</p>
<p>If your reimplementation of <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.fetchMore()</span></code> adds rows to the model, you need to call <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.beginInsertRows()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.endInsertRows()</span></code> . Also, both <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.canFetchMore()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">QAbstractItemModel.fetchMore()</span></code> must be reimplemented as their default implementation returns false and does nothing.</p>
</div></blockquote>
</div>
<div class="section" id="the-model-view-classes">
<span id="id89"></span><span id="id90"></span><h2>The Model/View Classes<a class="headerlink" href="#the-model-view-classes" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>These classes use the model/view design pattern in which the underlying data (in the model) is kept separate from the way the data is presented and manipulated by the user (in the view).</div></blockquote>
</div>
<div class="section" id="related-examples">
<span id="id91"></span><h2>Related Examples<a class="headerlink" href="#related-examples" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="qtwidgets-itemviews-dirview-example.html#dir-view-example"><span class="std std-ref">Dir View</span></a></li>
<li><a class="reference internal" href="qtwidgets-itemviews-spinboxdelegate-example.html#spin-box-delegate-example"><span class="std std-ref">Spin Box Delegate</span></a></li>
<li><a class="reference internal" href="qtwidgets-itemviews-pixelator-example.html#pixelator-example"><span class="std std-ref">Pixelator</span></a></li>
<li><a class="reference internal" href="qtwidgets-itemviews-simpletreemodel-example.html#simple-tree-model-example"><span class="std std-ref">Simple Tree Model</span></a></li>
<li><a class="reference internal" href="qtwidgets-itemviews-chart-example.html#chart-example"><span class="std std-ref">Chart</span></a></li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="qtwidgets-itemviews-puzzle-example.html#item-views-puzzle-example"><span class="std std-ref">Item Views Puzzle Example</span></a></p>
</div>
</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <p>© 2018 The Qt Company Ltd. Documentation contributions included herein are the copyrights of their respective owners. The documentation provided herein is licensed under the terms of the <a href="http://www.gnu.org/license/fdl.html">GNU Free Documentation License version 1.3</a> as published by the Free Software Foundation. Qt and respective logos are trademarks of The Qt Company Ltd. in Finland and/or other countries worldwide. All other trademarks are property of their respective owners.</p>
    </div></div>
    <div id="footer" class="footer">
    </div>
</div>
  </body>
</html>