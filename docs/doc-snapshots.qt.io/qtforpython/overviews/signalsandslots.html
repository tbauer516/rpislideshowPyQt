
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Signals &amp; Slots &#8212; Qt for Python (Technology Preview)</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '5.11.0~a1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" title="Search" href="../search.html" />
  <link rel="stylesheet" type="text/css" href="/style/pyside.css" />
  <link rel="icon" type="image/png" href="/style/pyside-32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/style/pyside-16px.png" sizes="16x16" />
  <script type="text/javascript"> wpThemeFolder = 'http://qt.io/wp-content/themes/oneqt'; </script>
  <script type="text/javascript" src="/scripts/main.js"></script>
  <script type="text/javascript" src="/scripts/extras.js"></script>
  <script type="text/javascript">
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-54043535-2', 'qt.io');
    ga('set', 'forceSSL', true);
    ga('send', 'pageview');
  </script>

  </head>
  <body>
<div id="container">
    <div class="header">
        <div class="header_container">
            <header id="navbar">
            </header>
        </div>
    </div>
    <div class="main">
        <div class="main-rounded">
            <div class="navigationbar">
                <ul class="sub-navigation">
                    <li><a href="http://wiki.qt.io/">Wiki</a></li>
                    <li><a href="https://doc.qt.io/">Documentation</a></li>
                    <li><a href="http://forum.qt.io/">Forum</a></li>
                    <li><a href="https://bugreports.qt.io/">Bug Reports</a></li>
                    <li><a href="https://codereview.qt-project.org/">Code Review</a></li>
                </ul>
                <div id="main_title_bar"><h1>Qt Documentation</h1></div>
                <div class="related">
                    <ul>
                        <li><a href="../index.html">Qt for Python (Technology Preview)</a></li> 
                    </ul>
                </div>
            </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Signals &amp; Slots</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#signals-and-slots">Signals and Slots</a></li>
<li><a class="reference internal" href="#signals">Signals</a></li>
<li><a class="reference internal" href="#slots">Slots</a></li>
<li><a class="reference internal" href="#a-small-example">A Small Example</a></li>
<li><a class="reference internal" href="#a-real-example">A Real Example</a></li>
<li><a class="reference internal" href="#signals-and-slots-with-default-arguments">Signals And Slots With Default Arguments</a></li>
<li><a class="reference internal" href="#advanced-signals-and-slots-usage">Advanced Signals and Slots Usage</a></li>
<li><a class="reference internal" href="#using-qt-with-3rd-party-signals-and-slots">Using Qt with 3rd Party Signals and Slots</a></li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="signals-slots">
<span id="id1"></span><h1>Signals &amp; Slots<a class="headerlink" href="#signals-slots" title="Permalink to this headline">¶</a></h1>
<p>An overview of Qt’s signals and slots inter-object communication mechanism</p>
<blockquote>
<div><p id="rd-party-signals-and-slots">An overview of Qt’s signals and slots inter-object communication mechanism.</p>
<p>Signals and slots are used for communication between objects. The signals and slots mechanism is a central feature of Qt and probably the part that differs most from the features provided by other frameworks. Signals and slots are made possible by Qt’s <a class="reference internal" href="metaobjects.html#the-meta-object-system"><span class="std std-ref">meta-object system</span></a> .</p>
</div></blockquote>
<div class="section" id="introduction">
<span id="id2"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>In GUI programming, when we change one widget, we often want another widget to be notified. More generally, we want objects of any kind to be able to communicate with one another. For example, if a user clicks a Close button, we probably want the window’s <code class="xref py py-func docutils literal"><span class="pre">QWidget.close()</span></code> function to be called.</p>
<p>Other toolkits achieve this kind of communication using callbacks. A callback is a pointer to a function, so if you want a processing function to notify you about some event you pass a pointer to another function (the callback) to the processing function. The processing function then calls the callback when appropriate. While successful frameworks using this method do exist, callbacks can be unintuitive and may suffer from problems in ensuring the type-correctness of callback arguments.</p>
</div></blockquote>
</div>
<div class="section" id="signals-and-slots">
<span id="id3"></span><h2>Signals and Slots<a class="headerlink" href="#signals-and-slots" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>In Qt, we have an alternative to the callback technique: We use signals and slots. A signal is emitted when a particular event occurs. Qt’s widgets have many predefined signals, but we can always subclass widgets to add our own signals to them. A slot is a function that is called in response to a particular signal. Qt’s widgets have many pre-defined slots, but it is common practice to subclass widgets and add your own slots so that you can handle the signals that you are interested in.</p>
<p>The signals and slots mechanism is type safe: The signature of a signal must match the signature of the receiving slot. (In fact a slot may have a shorter signature than the signal it receives because it can ignore extra arguments.) Since the signatures are compatible, the compiler can help us detect type mismatches when using the function pointer-based syntax. The string-based SIGNAL and SLOT syntax will detect type mismatches at runtime. Signals and slots are loosely coupled: A class which emits a signal neither knows nor cares which slots receive the signal. Qt’s signals and slots mechanism ensures that if you connect a signal to a slot, the slot will be called with the signal’s parameters at the right time. Signals and slots can take any number of arguments of any type. They are completely type safe.</p>
<p>All classes that inherit from <a class="reference internal" href="../PySide2/QtCore/QObject.html#PySide2.QtCore.QObject" title="PySide2.QtCore.QObject"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QObject</span></code></a> or one of its subclasses (e.g., <a class="reference internal" href="../PySide2/QtWidgets/QWidget.html#PySide2.QtWidgets.QWidget" title="PySide2.QtWidgets.QWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QWidget</span></code></a> ) can contain signals and slots. Signals are emitted by objects when they change their state in a way that may be interesting to other objects. This is all the object does to communicate. It does not know or care whether anything is receiving the signals it emits. This is true information encapsulation, and ensures that the object can be used as a software component.</p>
<p>Slots can be used for receiving signals, but they are also normal member functions. Just as an object does not know if anything receives its signals, a slot does not know if it has any signals connected to it. This ensures that truly independent components can be created with Qt.</p>
<p>You can connect as many signals as you want to a single slot, and a signal can be connected to as many slots as you need. It is even possible to connect a signal directly to another signal. (This will emit the second signal immediately whenever the first is emitted.)</p>
<p>Together, signals and slots make up a powerful component programming mechanism.</p>
</div></blockquote>
</div>
<div class="section" id="signals">
<span id="id4"></span><h2>Signals<a class="headerlink" href="#signals" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Signals are emitted by an object when its internal state has changed in some way that might be interesting to the object’s client or owner. Signals are public access functions and can be emitted from anywhere, but we recommend to only emit them from the class that defines the signal and its subclasses.</p>
<p>When a signal is emitted, the slots connected to it are usually executed immediately, just like a normal function call. When this happens, the signals and slots mechanism is totally independent of any GUI event loop. Execution of the code following the <code class="docutils literal"><span class="pre">emit</span></code> statement will occur once all slots have returned. The situation is slightly different when using <code class="xref py py-attr docutils literal"><span class="pre">queued</span> <span class="pre">connections</span></code> ; in such a case, the code following the <code class="docutils literal"><span class="pre">emit</span></code> keyword will continue immediately, and the slots will be executed later.</p>
<p>If several slots are connected to one signal, the slots will be executed one after the other, in the order they have been connected, when the signal is emitted.</p>
<p>Signals are automatically generated by the moc and must not be implemented in the <code class="docutils literal"><span class="pre">.cpp</span></code> file. They can never have return types (i.e. use <code class="docutils literal"><span class="pre">void</span></code> ).</p>
<p>A note about arguments: Our experience shows that signals and slots are more reusable if they do not use special types. If <code class="xref py py-func docutils literal"><span class="pre">QScrollBar.valueChanged()</span></code> were to use a special type such as the hypothetical QScrollBar::Range, it could only be connected to slots designed specifically for <a class="reference internal" href="../PySide2/QtWidgets/QScrollBar.html#PySide2.QtWidgets.QScrollBar" title="PySide2.QtWidgets.QScrollBar"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QScrollBar</span></code></a> . Connecting different input widgets together would be impossible.</p>
</div></blockquote>
</div>
<div class="section" id="slots">
<span id="id5"></span><h2>Slots<a class="headerlink" href="#slots" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>A slot is called when a signal connected to it is emitted. Slots are normal C++ functions and can be called normally; their only special feature is that signals can be connected to them.</p>
<p>Since slots are normal member functions, they follow the normal C++ rules when called directly. However, as slots, they can be invoked by any component, regardless of its access level, via a signal-slot connection. This means that a signal emitted from an instance of an arbitrary class can cause a private slot to be invoked in an instance of an unrelated class.</p>
<p>You can also define slots to be virtual, which we have found quite useful in practice.</p>
<p>Compared to callbacks, signals and slots are slightly slower because of the increased flexibility they provide, although the difference for real applications is insignificant. In general, emitting a signal that is connected to some slots, is approximately ten times slower than calling the receivers directly, with non-virtual function calls. This is the overhead required to locate the connection object, to safely iterate over all connections (i.e. checking that subsequent receivers have not been destroyed during the emission), and to marshall any parameters in a generic fashion. While ten non-virtual function calls may sound like a lot, it’s much less overhead than any <code class="docutils literal"><span class="pre">new</span></code> or <code class="docutils literal"><span class="pre">delete</span></code> operation, for example. As soon as you perform a string, vector or list operation that behind the scene requires <code class="docutils literal"><span class="pre">new</span></code> or <code class="docutils literal"><span class="pre">delete</span></code> , the signals and slots overhead is only responsible for a very small proportion of the complete function call costs. The same is true whenever you do a system call in a slot; or indirectly call more than ten functions. The simplicity and flexibility of the signals and slots mechanism is well worth the overhead, which your users won’t even notice.</p>
<p>Note that other libraries that define variables called <code class="docutils literal"><span class="pre">signals</span></code> or <code class="docutils literal"><span class="pre">slots</span></code> may cause compiler warnings and errors when compiled alongside a Qt-based application. To solve this problem, <code class="docutils literal"><span class="pre">#undef</span></code> the offending preprocessor symbol.</p>
</div></blockquote>
</div>
<div class="section" id="a-small-example">
<span id="id6"></span><h2>A Small Example<a class="headerlink" href="#a-small-example" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>A minimal C++ class declaration might read:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Counter</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">Counter</span><span class="p">()</span> <span class="p">{</span> <span class="n">m_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

    <span class="nb">int</span> <span class="n">value</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_value</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">void</span> <span class="n">setValue</span><span class="p">(</span><span class="nb">int</span> <span class="n">value</span><span class="p">);</span>

<span class="n">private</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">m_value</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A small <a class="reference internal" href="../PySide2/QtCore/QObject.html#PySide2.QtCore.QObject" title="PySide2.QtCore.QObject"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QObject</span></code></a> -based class might read:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#include &lt;QObject&gt;</span>

<span class="k">class</span> <span class="nc">Counter</span> <span class="p">:</span> <span class="n">public</span> <span class="n">QObject</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>

<span class="n">public</span><span class="p">:</span>
    <span class="n">Counter</span><span class="p">()</span> <span class="p">{</span> <span class="n">m_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

    <span class="nb">int</span> <span class="n">value</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_value</span><span class="p">;</span> <span class="p">}</span>

<span class="n">public</span> <span class="n">slots</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">setValue</span><span class="p">(</span><span class="nb">int</span> <span class="n">value</span><span class="p">);</span>

<span class="n">signals</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">valueChanged</span><span class="p">(</span><span class="nb">int</span> <span class="n">newValue</span><span class="p">);</span>

<span class="n">private</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">m_value</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../PySide2/QtCore/QObject.html#PySide2.QtCore.QObject" title="PySide2.QtCore.QObject"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QObject</span></code></a> -based version has the same internal state, and provides public methods to access the state, but in addition it has support for component programming using signals and slots. This class can tell the outside world that its state has changed by emitting a signal, <code class="docutils literal"><span class="pre">valueChanged()</span></code> , and it has a slot which other objects can send signals to.</p>
<p>All classes that contain signals or slots must mention <code class="xref py py-func docutils literal"><span class="pre">Q_OBJECT()</span></code> at the top of their declaration. They must also derive (directly or indirectly) from <a class="reference internal" href="../PySide2/QtCore/QObject.html#PySide2.QtCore.QObject" title="PySide2.QtCore.QObject"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QObject</span></code></a> .</p>
<p>Slots are implemented by the application programmer. Here is a possible implementation of the <code class="docutils literal"><span class="pre">Counter::setValue()</span></code> slot:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Counter</span><span class="p">::</span><span class="n">setValue</span><span class="p">(</span><span class="nb">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="n">m_value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">emit</span> <span class="n">valueChanged</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">emit</span></code> line emits the signal <code class="docutils literal"><span class="pre">valueChanged()</span></code> from the object, with the new value as argument.</p>
<p>In the following code snippet, we create two <code class="docutils literal"><span class="pre">Counter</span></code> objects and connect the first object’s <code class="docutils literal"><span class="pre">valueChanged()</span></code> signal to the second object’s <code class="docutils literal"><span class="pre">setValue()</span></code> slot using <code class="xref py py-func docutils literal"><span class="pre">QObject.connect()</span></code> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Counter</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
<span class="n">QObject</span><span class="p">::</span><span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">valueChanged</span><span class="p">(</span><span class="nb">int</span><span class="p">)),</span>
                 <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">setValue</span><span class="p">(</span><span class="nb">int</span><span class="p">)));</span>

<span class="n">a</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>     <span class="o">//</span> <span class="n">a</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> <span class="o">==</span> <span class="mi">12</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> <span class="o">==</span> <span class="mi">12</span>
<span class="n">b</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="mi">48</span><span class="p">);</span>     <span class="o">//</span> <span class="n">a</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> <span class="o">==</span> <span class="mi">12</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> <span class="o">==</span> <span class="mi">48</span>
</pre></div>
</div>
<p>Calling <code class="docutils literal"><span class="pre">a.setValue(12)</span></code> makes <code class="docutils literal"><span class="pre">a</span></code> emit a <code class="docutils literal"><span class="pre">valueChanged(12)</span></code> signal, which <code class="docutils literal"><span class="pre">b</span></code> will receive in its <code class="docutils literal"><span class="pre">setValue()</span></code> slot, i.e. <code class="docutils literal"><span class="pre">b.setValue(12)</span></code> is called. Then <code class="docutils literal"><span class="pre">b</span></code> emits the same <code class="docutils literal"><span class="pre">valueChanged()</span></code> signal, but since no slot has been connected to <code class="docutils literal"><span class="pre">b</span></code> ‘s <code class="docutils literal"><span class="pre">valueChanged()</span></code> signal, the signal is ignored.</p>
<p>Note that the <code class="docutils literal"><span class="pre">setValue()</span></code> function sets the value and emits the signal only if <code class="docutils literal"><span class="pre">value</span> <span class="pre">!=</span> <span class="pre">m_value</span></code> . This prevents infinite looping in the case of cyclic connections (e.g., if <code class="docutils literal"><span class="pre">b.valueChanged()</span></code> were connected to <code class="docutils literal"><span class="pre">a.setValue()</span></code> ).</p>
<p>By default, for every connection you make, a signal is emitted; two signals are emitted for duplicate connections. You can break all of these connections with a single <code class="xref py py-func docutils literal"><span class="pre">QObject.disconnect()</span></code> call. If you pass the <code class="xref py py-attr docutils literal"><span class="pre">Qt.UniqueConnection</span></code> <code class="docutils literal"><span class="pre">type</span></code> , the connection will only be made if it is not a duplicate. If there is already a duplicate (exact same signal to the exact same slot on the same objects), the connection will fail and connect will return false</p>
<p>This example illustrates that objects can work together without needing to know any information about each other. To enable this, the objects only need to be connected together, and this can be achieved with some simple <code class="xref py py-func docutils literal"><span class="pre">QObject.connect()</span></code> function calls, or with <code class="docutils literal"><span class="pre">uic</span></code> ‘s automatic connections feature.</p>
</div></blockquote>
</div>
<div class="section" id="a-real-example">
<span id="id7"></span><h2>A Real Example<a class="headerlink" href="#a-real-example" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Here is a simple commented example of a widget.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#ifndef LCDNUMBER_H</span>
<span class="c1">#define LCDNUMBER_H</span>

<span class="c1">#include &lt;QFrame&gt;</span>

<span class="k">class</span> <span class="nc">LcdNumber</span> <span class="p">:</span> <span class="n">public</span> <span class="n">QFrame</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">LcdNumber</span></code> inherits <a class="reference internal" href="../PySide2/QtCore/QObject.html#PySide2.QtCore.QObject" title="PySide2.QtCore.QObject"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QObject</span></code></a> , which has most of the signal-slot knowledge, via <a class="reference internal" href="../PySide2/QtWidgets/QFrame.html#PySide2.QtWidgets.QFrame" title="PySide2.QtWidgets.QFrame"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QFrame</span></code></a> and <a class="reference internal" href="../PySide2/QtWidgets/QWidget.html#PySide2.QtWidgets.QWidget" title="PySide2.QtWidgets.QWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QWidget</span></code></a> . It is somewhat similar to the built-in <a class="reference internal" href="../PySide2/QtWidgets/QLCDNumber.html#PySide2.QtWidgets.QLCDNumber" title="PySide2.QtWidgets.QLCDNumber"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QLCDNumber</span></code></a> widget.</p>
<p>The <code class="xref py py-func docutils literal"><span class="pre">Q_OBJECT()</span></code> macro is expanded by the preprocessor to declare several member functions that are implemented by the <code class="docutils literal"><span class="pre">moc</span></code> ; if you get compiler errors along the lines of “undefined reference to vtable for <code class="docutils literal"><span class="pre">LcdNumber</span></code> “, you have probably forgotten to run the moc or to include the moc output in the link command.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">public</span><span class="p">:</span>
    <span class="n">LcdNumber</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>It’s not obviously relevant to the moc, but if you inherit <a class="reference internal" href="../PySide2/QtWidgets/QWidget.html#PySide2.QtWidgets.QWidget" title="PySide2.QtWidgets.QWidget"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QWidget</span></code></a> you almost certainly want to have the <code class="docutils literal"><span class="pre">parent</span></code> argument in your constructor and pass it to the base class’s constructor.</p>
<p>Some destructors and member functions are omitted here; the <code class="docutils literal"><span class="pre">moc</span></code> ignores member functions.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">signals</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">overflow</span><span class="p">();</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">LcdNumber</span></code> emits a signal when it is asked to show an impossible value.</p>
<p>If you don’t care about overflow, or you know that overflow cannot occur, you can ignore the <code class="docutils literal"><span class="pre">overflow()</span></code> signal, i.e. don’t connect it to any slot.</p>
<p>If on the other hand you want to call two different error functions when the number overflows, simply connect the signal to two different slots. Qt will call both (in the order they were connected).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="n">slots</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">display</span><span class="p">(</span><span class="nb">int</span> <span class="n">num</span><span class="p">);</span>
    <span class="n">void</span> <span class="n">display</span><span class="p">(</span><span class="n">double</span> <span class="n">num</span><span class="p">);</span>
    <span class="n">void</span> <span class="n">display</span><span class="p">(</span><span class="n">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">);</span>
    <span class="n">void</span> <span class="n">setHexMode</span><span class="p">();</span>
    <span class="n">void</span> <span class="n">setDecMode</span><span class="p">();</span>
    <span class="n">void</span> <span class="n">setOctMode</span><span class="p">();</span>
    <span class="n">void</span> <span class="n">setBinMode</span><span class="p">();</span>
    <span class="n">void</span> <span class="n">setSmallDecimalPoint</span><span class="p">(</span><span class="nb">bool</span> <span class="n">point</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">#endif</span>
</pre></div>
</div>
<p>A slot is a receiving function used to get information about state changes in other widgets. <code class="docutils literal"><span class="pre">LcdNumber</span></code> uses it, as the code above indicates, to set the displayed number. Since <code class="docutils literal"><span class="pre">display()</span></code> is part of the class’s interface with the rest of the program, the slot is public.</p>
<p>Several of the example programs connect the <code class="xref py py-func docutils literal"><span class="pre">QScrollBar.valueChanged()</span></code> signal of a <a class="reference internal" href="../PySide2/QtWidgets/QScrollBar.html#PySide2.QtWidgets.QScrollBar" title="PySide2.QtWidgets.QScrollBar"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtWidgets.QScrollBar</span></code></a> to the <code class="docutils literal"><span class="pre">display()</span></code> slot, so the LCD number continuously shows the value of the scroll bar.</p>
<p>Note that <code class="docutils literal"><span class="pre">display()</span></code> is overloaded; Qt will select the appropriate version when you connect a signal to the slot. With callbacks, you’d have to find five different names and keep track of the types yourself.</p>
<p>Some irrelevant member functions have been omitted from this example.</p>
</div></blockquote>
</div>
<div class="section" id="signals-and-slots-with-default-arguments">
<span id="id8"></span><h2>Signals And Slots With Default Arguments<a class="headerlink" href="#signals-and-slots-with-default-arguments" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The signatures of signals and slots may contain arguments, and the arguments can have default values. Consider <code class="xref py py-func docutils literal"><span class="pre">QObject.destroyed()</span></code> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">destroyed</span><span class="p">(</span><span class="n">QObject</span><span class="o">*</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>When a <a class="reference internal" href="../PySide2/QtCore/QObject.html#PySide2.QtCore.QObject" title="PySide2.QtCore.QObject"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QObject</span></code></a> is deleted, it emits this <code class="xref py py-func docutils literal"><span class="pre">QObject.destroyed()</span></code> signal. We want to catch this signal, wherever we might have a dangling reference to the deleted <a class="reference internal" href="../PySide2/QtCore/QObject.html#PySide2.QtCore.QObject" title="PySide2.QtCore.QObject"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QObject</span></code></a> , so we can clean it up. A suitable slot signature might be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">objectDestroyed</span><span class="p">(</span><span class="n">QObject</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>To connect the signal to the slot, we use <code class="xref py py-func docutils literal"><span class="pre">QObject.connect()</span></code> . There are several ways to connect signal and slots. The first is to use function pointers:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">connect</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QObject</span><span class="p">::</span><span class="n">destroyed</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyObject</span><span class="p">::</span><span class="n">objectDestroyed</span><span class="p">);</span>
</pre></div>
</div>
<p>There are several advantages to using <code class="xref py py-func docutils literal"><span class="pre">QObject.connect()</span></code> with function pointers. First, it allows the compiler to check that the signal’s arguments are compatible with the slot’s arguments. Arguments can also be implicitly converted by the compiler, if needed.</p>
<p>You can also connect to functors or C++11 lambdas:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">connect</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QObject</span><span class="p">::</span><span class="n">destroyed</span><span class="p">,</span> <span class="p">[</span><span class="o">=</span><span class="p">](){</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">m_objects</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sender</span><span class="p">);</span> <span class="p">});</span>
</pre></div>
</div>
<p>The other way to connect a signal to a slot is to use <code class="xref py py-func docutils literal"><span class="pre">QObject.connect()</span></code> and the <code class="docutils literal"><span class="pre">SIGNAL</span></code> and <code class="docutils literal"><span class="pre">SLOT</span></code> macros. The rule about whether to include arguments or not in the <code class="docutils literal"><span class="pre">SIGNAL()</span></code> and <code class="docutils literal"><span class="pre">SLOT()</span></code> macros, if the arguments have default values, is that the signature passed to the <code class="docutils literal"><span class="pre">SIGNAL()</span></code> macro must <em>not</em> have fewer arguments than the signature passed to the <code class="docutils literal"><span class="pre">SLOT()</span></code> macro.</p>
<p>All of these would work:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">connect</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">destroyed</span><span class="p">(</span><span class="n">QObject</span><span class="o">*</span><span class="p">)),</span> <span class="n">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">objectDestroyed</span><span class="p">(</span><span class="n">Qbject</span><span class="o">*</span><span class="p">)));</span>
<span class="n">connect</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">destroyed</span><span class="p">(</span><span class="n">QObject</span><span class="o">*</span><span class="p">)),</span> <span class="n">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">objectDestroyed</span><span class="p">()));</span>
<span class="n">connect</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">destroyed</span><span class="p">()),</span> <span class="n">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">objectDestroyed</span><span class="p">()));</span>
</pre></div>
</div>
<p>But this one won’t work:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">connect</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">destroyed</span><span class="p">()),</span> <span class="n">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">objectDestroyed</span><span class="p">(</span><span class="n">QObject</span><span class="o">*</span><span class="p">)));</span>
</pre></div>
</div>
<p>…because the slot will be expecting a <a class="reference internal" href="../PySide2/QtCore/QObject.html#PySide2.QtCore.QObject" title="PySide2.QtCore.QObject"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtCore.QObject</span></code></a> that the signal will not send. This connection will report a runtime error.</p>
<p>Note that signal and slot arguments are not checked by the compiler when using this <code class="xref py py-func docutils literal"><span class="pre">QObject.connect()</span></code> overload.</p>
</div></blockquote>
</div>
<div class="section" id="advanced-signals-and-slots-usage">
<span id="id9"></span><h2>Advanced Signals and Slots Usage<a class="headerlink" href="#advanced-signals-and-slots-usage" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>For cases where you may require information on the sender of the signal, Qt provides the <code class="xref py py-func docutils literal"><span class="pre">QObject.sender()</span></code> function, which returns a pointer to the object that sent the signal.</p>
<p>Lambda expressions are a convenient way to pass custom arguments to a slot:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">connect</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QAction</span><span class="p">::</span><span class="n">triggered</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span>
        <span class="p">[</span><span class="o">=</span><span class="p">]()</span> <span class="p">{</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">processAction</span><span class="p">(</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">());</span> <span class="p">});</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="using-qt-with-3rd-party-signals-and-slots">
<span id="id10"></span><span id="id11"></span><h2>Using Qt with 3rd Party Signals and Slots<a class="headerlink" href="#using-qt-with-3rd-party-signals-and-slots" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>It is possible to use Qt with a 3rd party signal/slot mechanism. You can even use both mechanisms in the same project. Just add the following line to your qmake project (.pro) file.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">CONFIG</span> <span class="o">+=</span> <span class="n">no_keywords</span>
</pre></div>
</div>
<p>It tells Qt not to define the moc keywords <code class="docutils literal"><span class="pre">signals</span></code> , <code class="docutils literal"><span class="pre">slots</span></code> , and <code class="docutils literal"><span class="pre">emit</span></code> , because these names will be used by a 3rd party library, e.g. Boost. Then to continue using Qt signals and slots with the <code class="docutils literal"><span class="pre">no_keywords</span></code> flag, simply replace all uses of the Qt moc keywords in your sources with the corresponding Qt macros <code class="xref py py-func docutils literal"><span class="pre">Q_SIGNALS()</span></code> (or <code class="xref py py-func docutils literal"><span class="pre">Q_SIGNAL()</span></code> ), <code class="xref py py-func docutils literal"><span class="pre">Q_SLOTS()</span></code> (or <code class="xref py py-func docutils literal"><span class="pre">Q_SLOT()</span></code> ), and <code class="xref py py-func docutils literal"><span class="pre">Q_EMIT()</span></code> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="metaobjects.html#the-meta-object-system"><span class="std std-ref">Meta-Object System</span></a>  <a class="reference internal" href="properties.html#the-property-system"><span class="std std-ref">Qt’s Property System</span></a></p>
</div>
</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <p>© 2018 The Qt Company Ltd. Documentation contributions included herein are the copyrights of their respective owners. The documentation provided herein is licensed under the terms of the <a href="http://www.gnu.org/license/fdl.html">GNU Free Documentation License version 1.3</a> as published by the Free Software Foundation. Qt and respective logos are trademarks of The Qt Company Ltd. in Finland and/or other countries worldwide. All other trademarks are property of their respective owners.</p>
    </div></div>
    <div id="footer" class="footer">
    </div>
</div>
  </body>
</html>