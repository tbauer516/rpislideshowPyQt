
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Qt Quick Scene Graph OpenGL Renderer &#8212; Qt for Python (Technology Preview)</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '5.11.0~a1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" title="Search" href="../search.html" />
  <link rel="stylesheet" type="text/css" href="/style/pyside.css" />
  <link rel="icon" type="image/png" href="/style/pyside-32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/style/pyside-16px.png" sizes="16x16" />
  <script type="text/javascript"> wpThemeFolder = 'http://qt.io/wp-content/themes/oneqt'; </script>
  <script type="text/javascript" src="/scripts/main.js"></script>
  <script type="text/javascript" src="/scripts/extras.js"></script>
  <script type="text/javascript">
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-54043535-2', 'qt.io');
    ga('set', 'forceSSL', true);
    ga('send', 'pageview');
  </script>

  </head>
  <body>
<div id="container">
    <div class="header">
        <div class="header_container">
            <header id="navbar">
            </header>
        </div>
    </div>
    <div class="main">
        <div class="main-rounded">
            <div class="navigationbar">
                <ul class="sub-navigation">
                    <li><a href="http://wiki.qt.io/">Wiki</a></li>
                    <li><a href="https://doc.qt.io/">Documentation</a></li>
                    <li><a href="http://forum.qt.io/">Forum</a></li>
                    <li><a href="https://bugreports.qt.io/">Bug Reports</a></li>
                    <li><a href="https://codereview.qt-project.org/">Code Review</a></li>
                </ul>
                <div id="main_title_bar"><h1>Qt Documentation</h1></div>
                <div class="related">
                    <ul>
                        <li><a href="../index.html">Qt for Python (Technology Preview)</a></li> 
                    </ul>
                </div>
            </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Qt Quick Scene Graph OpenGL Renderer</a><ul>
<li><a class="reference internal" href="#batching">Batching</a></li>
<li><a class="reference internal" href="#opaque-primitives">Opaque Primitives</a></li>
<li><a class="reference internal" href="#alpha-blended-primitives">Alpha Blended Primitives</a></li>
<li><a class="reference internal" href="#mixing-with-3d-primitives">Mixing with 3D Primitives</a></li>
<li><a class="reference internal" href="#texture-atlas">Texture Atlas</a></li>
<li><a class="reference internal" href="#batch-roots">Batch Roots</a></li>
<li><a class="reference internal" href="#transform-nodes">Transform Nodes</a></li>
<li><a class="reference internal" href="#clipping">Clipping</a></li>
<li><a class="reference internal" href="#vertex-buffers">Vertex Buffers</a></li>
<li><a class="reference internal" href="#antialiasing">Antialiasing</a></li>
<li><a class="reference internal" href="#vertex-antialiasing">Vertex Antialiasing</a></li>
<li><a class="reference internal" href="#multisample-antialiasing">Multisample Antialiasing</a></li>
<li><a class="reference internal" href="#performance">Performance</a></li>
<li><a class="reference internal" href="#visualizing">Visualizing</a></li>
<li><a class="reference internal" href="#visualizing-batches">Visualizing Batches</a></li>
<li><a class="reference internal" href="#visualizing-clipping">Visualizing Clipping</a></li>
<li><a class="reference internal" href="#visualizing-changes">Visualizing Changes</a></li>
<li><a class="reference internal" href="#visualizing-overdraw">Visualizing Overdraw</a></li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="qt-quick-scene-graph-opengl-renderer">
<span id="id1"></span><h1>Qt Quick Scene Graph OpenGL Renderer<a class="headerlink" href="#qt-quick-scene-graph-opengl-renderer" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>This document explains how the scene graph renderer for OpenGL works internally so that one can write code that uses it in an optimal fashion, both performance-wise and feature-wise.</p>
<p>One does not need to understand the internals of the renderer to get good performance. However, it might help when integrating with the scene graph or to figure out why it is not possible to squeeze the maximum efficiency out of the graphics chip.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Even in the case where every frame is unique and everything is uploaded from scratch, the default renderer will perform well.</p>
</div>
<p>The Qt Quick items in a QML scene populate a tree of <a class="reference internal" href="../PySide2/QtQuick/QSGNode.html#PySide2.QtQuick.QSGNode" title="PySide2.QtQuick.QSGNode"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtQuick.QSGNode</span></code></a> instances. Once created, this tree is a complete description of how a certain frame should be rendered. It does not contain any references back to the Qt Quick items at all and will on most platforms be processed and rendered in a separate thread. The renderer is a self contained part of the scene graph which traverses the <a class="reference internal" href="../PySide2/QtQuick/QSGNode.html#PySide2.QtQuick.QSGNode" title="PySide2.QtQuick.QSGNode"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtQuick.QSGNode</span></code></a> tree and uses geometry defined in <a class="reference internal" href="../PySide2/QtQuick/QSGGeometryNode.html#PySide2.QtQuick.QSGGeometryNode" title="PySide2.QtQuick.QSGGeometryNode"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtQuick.QSGGeometryNode</span></code></a> and shader state defined in <code class="xref py py-class docutils literal"><span class="pre">QSGMaterial</span></code> to schedule OpenGL state change and draw calls.</p>
<p>If needed, the renderer can be completely replaced using the internal scene graph back-end API. This is mostly interesting for platform vendors who wish to take advantage of non-standard hardware features. For the majority of use cases, the default renderer will be sufficient.</p>
<p>The default renderer focuses on two primary strategies to optimize the rendering: Batching of draw calls, and retention of geometry on the GPU.</p>
</div></blockquote>
<div class="section" id="batching">
<span id="id2"></span><h2>Batching<a class="headerlink" href="#batching" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Where a traditional 2D API, such as <a class="reference internal" href="../PySide2/QtGui/QPainter.html#PySide2.QtGui.QPainter" title="PySide2.QtGui.QPainter"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtGui.QPainter</span></code></a> , Cairo or <span class="xref std std-ref">Context2D</span> , is written to handle thousands of individual draw calls per frame, OpenGL is a pure hardware API and performs best when the number of draw calls is very low and state changes are kept to a minimum. Consider the following use case:</p>
<p>The simplest way of drawing this list is on a cell-by-cell basis. First, the background is drawn. This is a rectangle of a specific color. In OpenGL terms this means selecting a shader program to do solid color fills, setting up the fill color, setting the transformation matrix containing the x and y offsets and then using for instance <code class="docutils literal"><span class="pre">glDrawArrays</span></code> to draw two triangles making up the rectangle. The icon is drawn next. In OpenGL terms this means selecting a shader program to draw textures, selecting the active texture to use, setting the transformation matrix, enabling alpha-blending and then using for instance <code class="docutils literal"><span class="pre">glDrawArrays</span></code> to draw the two triangles making up the bounding rectangle of the icon. The text and separator line between cells follow a similar pattern. And this process is repeated for every cell in the list, so for a longer list, the overhead imposed by OpenGL state changes and draw calls completely outweighs the benefit that using a hardware accelerated API could provide.</p>
<p>When each primitive is large, this overhead is negligible, but in the case of a typical UI, there are many small items which add up to a considerable overhead.</p>
<p>The default scene graph renderer works within these limitations and will try to merge individual primitives together into batches while preserving the exact same visual result. The result is fewer OpenGL state changes and a minimal amount of draw calls, resulting in optimal performance.</p>
</div></blockquote>
</div>
<div class="section" id="opaque-primitives">
<span id="id3"></span><h2>Opaque Primitives<a class="headerlink" href="#opaque-primitives" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The renderer separates between opaque primitives and primitives which require alpha blending. By using OpenGL’s Z-buffer and giving each primitive a unique z position, the renderer can freely reorder opaque primitives without any regard for their location on screen and which other elements they overlap with. By looking at each primitive’s material state, the renderer will create opaque batches. From Qt Quick core item set, this includes Rectangle items with opaque colors and fully opaque images, such as JPEGs or BMPs.</p>
<p>Another benefit of using opaque primitives is that opaque primitives do not require <code class="docutils literal"><span class="pre">GL_BLEND</span></code> to be enabled, which can be quite costly, especially on mobile and embedded GPUs.</p>
<p>Opaque primitives are rendered in a front-to-back manner with <code class="docutils literal"><span class="pre">glDepthMask</span></code> and <code class="docutils literal"><span class="pre">GL_DEPTH_TEST</span></code> enabled. On GPUs that internally do early-z checks, this means that the fragment shader does not need to run for pixels or blocks of pixels that are obscured. Beware that the renderer still needs to take these nodes into account and the vertex shader is still run for every vertex in these primitives, so if the application knows that something is fully obscured, the best thing to do is to explicitly hide it using <span class="xref std std-ref">Item::visible</span> or <span class="xref std std-ref">Item::opacity</span> .</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <span class="xref std std-ref">Item::z</span> is used to control an Item’s stacking order relative to its siblings. It has no direct relation to the renderer and OpenGL’s Z-buffer.</p>
</div>
</div></blockquote>
</div>
<div class="section" id="alpha-blended-primitives">
<span id="id4"></span><h2>Alpha Blended Primitives<a class="headerlink" href="#alpha-blended-primitives" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Once opaque primitives have been drawn, the renderer will disable <code class="docutils literal"><span class="pre">glDepthMask</span></code> , enable <code class="docutils literal"><span class="pre">GL_BLEND</span></code> and render all alpha blended primitives in a back-to-front manner.</p>
<p>Batching of alpha blended primitives requires a bit more effort in the renderer as elements that are overlapping need to be rendered in the correct order for alpha blending to look correct. Relying on the Z-buffer alone is not enough. The renderer does a pass over all alpha blended primitives and will look at their bounding rect in addition to their material state to figure out which elements can be batched and which can not.</p>
<p>In the left-most case, the blue backgrounds can be drawn in one call and the two text elements in another call, as the texts only overlap a background which they are stacked in front of. In the right-most case, the background of “Item 4” overlaps the text of “Item 3” so in this case, each of backgrounds and texts needs to be drawn using separate calls.</p>
<p>Z-wise, the alpha primitives are interleaved with the opaque nodes and may trigger early-z when available, but again, setting <span class="xref std std-ref">Item::visible</span> to false is always faster.</p>
</div></blockquote>
</div>
<div class="section" id="mixing-with-3d-primitives">
<span id="id5"></span><h2>Mixing with 3D Primitives<a class="headerlink" href="#mixing-with-3d-primitives" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The scene graph can support pseudo 3D and proper 3D primitives. For instance, one can implement a “page curl” effect using a <span class="xref std std-ref">ShaderEffect</span> or implement a bumpmapped torus using <a class="reference internal" href="../PySide2/QtQuick/QSGGeometry.html#PySide2.QtQuick.QSGGeometry" title="PySide2.QtQuick.QSGGeometry"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtQuick.QSGGeometry</span></code></a> and a custom material. While doing so, one needs to take into account that the default renderer already makes use of the depth buffer.</p>
<p>The renderer modifies the vertex shader returned from <code class="xref py py-func docutils literal"><span class="pre">QSGMaterialShader.vertexShader()</span></code> and compresses the z values of the vertex after the model-view and projection matrices have been applied and then adds a small translation on the z to position it the correct z position.</p>
<p>The compression assumes that the z values are in the range of 0 to 1.</p>
</div></blockquote>
</div>
<div class="section" id="texture-atlas">
<span id="id6"></span><h2>Texture Atlas<a class="headerlink" href="#texture-atlas" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The active texture is a unique OpenGL state, which means that multiple primitives using different OpenGL textures cannot be batched. The Qt Quick scene graph, for this reason, allows multiple <a class="reference internal" href="../PySide2/QtQuick/QSGTexture.html#PySide2.QtQuick.QSGTexture" title="PySide2.QtQuick.QSGTexture"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtQuick.QSGTexture</span></code></a> instances to be allocated as smaller sub-regions of a larger texture; a texture atlas.</p>
<p>The biggest benefit of texture atlases is that multiple <a class="reference internal" href="../PySide2/QtQuick/QSGTexture.html#PySide2.QtQuick.QSGTexture" title="PySide2.QtQuick.QSGTexture"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtQuick.QSGTexture</span></code></a> instances now refer to the same OpenGL texture instance. This makes it possible to batch textured draw calls as well, such as Image items, <a class="reference internal" href="qtquick-imageelements-example.html#qt-quick-examples-image-elements"><span class="std std-ref">BorderImage</span></a> items, <span class="xref std std-ref">ShaderEffect</span> items and also C++ types such as <a class="reference internal" href="../PySide2/QtQuick/QSGSimpleTextureNode.html#PySide2.QtQuick.QSGSimpleTextureNode" title="PySide2.QtQuick.QSGSimpleTextureNode"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtQuick.QSGSimpleTextureNode</span></code></a> and custom QSGGeometryNodes using textures.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Large textures do not go into the texture atlas.</p>
</div>
<p>Atlas based textures are created by passing <code class="xref py py-attr docutils literal"><span class="pre">QQuickWindow.TextureCanUseAtlas</span></code> to the <code class="xref py py-func docutils literal"><span class="pre">QQuickWindow.createTextureFromImage()</span></code> .</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Atlas based textures do not have texture coordinates ranging from 0 to 1. Use <code class="xref py py-func docutils literal"><span class="pre">QSGTexture.normalizedTextureSubRect()</span></code> to get the atlas texture coordinates.</p>
</div>
<p>The scene graph uses heuristics to figure out how large the atlas should be and what the size threshold for being entered into the atlas is. If different values are needed, it is possible to override them using the environment variables <code class="docutils literal"><span class="pre">QSG_ATLAS_WIDTH=[width]</span></code> , <code class="docutils literal"><span class="pre">QSG_ATLAS_HEIGHT=[height]</span></code> and <code class="docutils literal"><span class="pre">QSG_ATLAS_SIZE_LIMIT=[size]</span></code> . Changing these values will mostly be interesting for platform vendors.</p>
</div></blockquote>
</div>
<div class="section" id="batch-roots">
<span id="id7"></span><h2>Batch Roots<a class="headerlink" href="#batch-roots" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>In addition to merging compatible primitives into batches, the default renderer also tries to minimize the amount of data that needs to be sent to the GPU for every frame. The default renderer identifies subtrees which belong together and tries to put these into separate batches. Once batches are identified, they are merged, uploaded and stored in GPU memory, using Vertex Buffer Objects.</div></blockquote>
</div>
<div class="section" id="transform-nodes">
<span id="id8"></span><h2>Transform Nodes<a class="headerlink" href="#transform-nodes" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Each Qt Quick Item inserts a <a class="reference internal" href="../PySide2/QtQuick/QSGTransformNode.html#PySide2.QtQuick.QSGTransformNode" title="PySide2.QtQuick.QSGTransformNode"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtQuick.QSGTransformNode</span></code></a> into the scene graph tree to manage its x, y, scale or rotation. Child items will be populated under this transform node. The default renderer tracks the state of transform nodes between frames and will look at subtrees to decide if a transform node is a good candidate to become a root for a set of batches. A transform node which changes between frames and which has a fairly complex subtree can become a batch root.</p>
<p>QSGGeometryNodes in the subtree of a batch root are pre-transformed relative to the root on the CPU. They are then uploaded and retained on the GPU. When the transform changes, the renderer only needs to update the matrix of the root, not each individual item, making list and grid scrolling very fast. For successive frames, as long as nodes are not being added or removed, rendering the list is effectively for free. When new content enters the subtree, the batch that gets it is rebuilt, but this is still relatively fast. There are usually several unchanging frames for every frame with added or removed nodes when panning through a grid or list.</p>
<p>Another benefit of identifying transform nodes as batch roots is that it allows the renderer to retain the parts of the tree that have not changed. For instance, say a UI consists of a list and a button row. When the list is being scrolled and delegates are being added and removed, the rest of the UI, the button row, is unchanged and can be drawn using the geometry already stored on the GPU.</p>
<p>The node and vertex threshold for a transform node to become a batch root can be overridden using the environment variables <code class="docutils literal"><span class="pre">QSG_RENDERER_BATCH_NODE_THRESHOLD=[count]</span></code> and <code class="docutils literal"><span class="pre">QSG_RENDERER_BATCH_VERTEX_THRESHOLD=[count]</span></code> . Overriding these flags will be mostly useful for platform vendors.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Beneath a batch root, one batch is created for each unique set of material state and geometry type.</p>
</div>
</div></blockquote>
</div>
<div class="section" id="clipping">
<span id="id9"></span><h2>Clipping<a class="headerlink" href="#clipping" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>When setting <span class="xref std std-ref">Item::clip</span> to true, it will create a <a class="reference internal" href="../PySide2/QtQuick/QSGClipNode.html#PySide2.QtQuick.QSGClipNode" title="PySide2.QtQuick.QSGClipNode"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtQuick.QSGClipNode</span></code></a> with a rectangle in its geometry. The default renderer will apply this clip by using scissoring in OpenGL. If the item is rotated by a non-90-degree angle, the OpenGL’s stencil buffer is used. Qt Quick Item only supports setting a rectangle as clip through QML, but the scene graph API and the default renderer can use any shape for clipping.</p>
<p>When applying a clip to a subtree, that subtree needs to be rendered with a unique OpenGL state. This means that when <span class="xref std std-ref">Item::clip</span> is true, batching of that item is limited to its children. When there are many children, like a <span class="xref std std-ref">ListView</span> or <span class="xref std std-ref">GridView</span> , or complex children, like a TextArea, this is fine. One should, however, use clip on smaller items with caution as it prevents batching. This includes button label, text field or list delegate and table cells.</p>
</div></blockquote>
</div>
<div class="section" id="vertex-buffers">
<span id="id10"></span><h2>Vertex Buffers<a class="headerlink" href="#vertex-buffers" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Each batch uses a vertex buffer object (VBO) to store its data on the GPU. This vertex buffer is retained between frames and updated when the part of the scene graph that it represents changes.</p>
<p>By default, the renderer will upload data into the VBO using <code class="docutils literal"><span class="pre">GL_STATIC_DRAW</span></code> . It is possible to select different upload strategy by setting the environment variable <code class="docutils literal"><span class="pre">QSG_RENDERER_BUFFER_STRATEGY=[strategy]</span></code> . Valid values are <code class="docutils literal"><span class="pre">stream</span></code> and <code class="docutils literal"><span class="pre">dynamic</span></code> . Changing this value is mostly useful for platform vendors.</p>
</div></blockquote>
</div>
<div class="section" id="antialiasing">
<span id="id11"></span><h2>Antialiasing<a class="headerlink" href="#antialiasing" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The scene graph supports two types of antialiasing. By default, primitives such as rectangles and images will be antialiased by adding more vertices along the edge of the primitives so that the edges fade to transparent. We call this method <em>vertex antialiasing</em> . If the user requests a multisampled OpenGL context, by setting a <a class="reference internal" href="../PySide2/QtGui/QSurfaceFormat.html#PySide2.QtGui.QSurfaceFormat" title="PySide2.QtGui.QSurfaceFormat"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtGui.QSurfaceFormat</span></code></a> with samples greater than <code class="docutils literal"><span class="pre">0</span></code> using <code class="xref py py-func docutils literal"><span class="pre">QQuickWindow.setFormat()</span></code> , the scene graph will prefer multisample based antialiasing (MSAA). The two techniques will affect how the rendering happens internally and have different limitations.</p>
<p>It is also possible to override the antialiasing method used by setting the environment variable <code class="docutils literal"><span class="pre">QSG_ANTIALIASING_METHOD</span></code> to either <code class="docutils literal"><span class="pre">vertex</span></code> or <code class="docutils literal"><span class="pre">msaa</span></code> .</p>
<p>Vertex antialiasing can produce seams between edges of adjacent primitives, even when the two edges are mathematically the same. Multisample antialiasing does not.</p>
</div></blockquote>
</div>
<div class="section" id="vertex-antialiasing">
<span id="id12"></span><h2>Vertex Antialiasing<a class="headerlink" href="#vertex-antialiasing" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Vertex antialiasing can be enabled and disabled on a per-item basis using the <span class="xref std std-ref">Item::antialiasing</span> property. It will work regardless of what the underlying hardware supports and produces higher quality antialiasing, both for normally rendered primitives and also for primitives captured into framebuffer objects, for instance using the <span class="xref std std-ref">ShaderEffectSource</span> type.</p>
<p>The downside to using vertex antialiasing is that each primitive with antialiasing enabled will have to be blended. In terms of batching, this means that the renderer needs to do more work to figure out if the primitive can be batched or not and due to overlaps with other elements in the scene, it may also result in less batching, which could impact performance.</p>
<p>On low-end hardware blending can also be quite expensive so for an image or rounded rectangle that covers most of the screen, the amount of blending needed for the interior of these primitives can result in significant performance loss as the entire primitive must be blended.</p>
</div></blockquote>
</div>
<div class="section" id="multisample-antialiasing">
<span id="id13"></span><h2>Multisample Antialiasing<a class="headerlink" href="#multisample-antialiasing" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Multisample antialiasing is a hardware feature where the hardware calculates a coverage value per pixel in the primitive. Some hardware can multisample at a very low cost, while other hardware may need both more memory and more GPU cycles to render a frame.</p>
<p>Using multisample antialiasing, many primitives, such as rounded rectangles and image elements can be antialiased and still be <em>opaque</em> in the scene graph. This means the renderer has an easier job when creating batches and can rely on early-z to avoid overdraw.</p>
<p>When multisample antialiasing is used, content rendered into framebuffer objects need additional extensions to support multisampling of framebuffers. Typically <code class="docutils literal"><span class="pre">GL_EXT_framebuffer_multisample</span></code> and <code class="docutils literal"><span class="pre">GL_EXT_framebuffer_blit</span></code> . Most desktop chips have these extensions present, but they are less common in embedded chips. When framebuffer multisampling is not available in the hardware, content rendered into framebuffer objects will not be antialiased, including the content of a <span class="xref std std-ref">ShaderEffectSource</span> .</p>
</div></blockquote>
</div>
<div class="section" id="performance">
<span id="id14"></span><h2>Performance<a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>As stated in the beginning, understanding the finer details of the renderer is not required to get good performance. It is written to optimize for common use cases and will perform quite well under almost any circumstances.</p>
<ul class="simple">
<li>Good performance comes from effective batching, with as little as possible of the geometry being uploaded again and again. By setting the environment variable <code class="docutils literal"><span class="pre">QSG_RENDERER_DEBUG=render</span></code>, the renderer will output statistics on how well the batching goes, how many batches are used, which batches are retained and which are opaque and not. When striving for optimal performance, uploads should happen only when really needed, batches should be fewer than 10 and at least 3-4 of them should be opaque.</li>
<li>The default renderer does not do any CPU-side viewport clipping nor occlusion detection. If something is not supposed to be visible, it should not be shown. Use <code class="docutils literal"><span class="pre">Item::visible:</span> <span class="pre">false</span></code> for items that should not be drawn. The primary reason for not adding such logic is that it adds additional cost which would also hurt applications that took care in behaving well.</li>
<li>Make sure the texture atlas is used. The Image and <a class="reference internal" href="qtquick-imageelements-example.html#qt-quick-examples-image-elements"><span class="std std-ref">BorderImage</span></a> items will use it unless the image is too large. For textures created in C++, pass <code class="xref py py-attr docutils literal"><span class="pre">QQuickWindow.TextureCanUseAtlas</span></code> when calling QQuickWindow::createTexture(). By setting the environment variable <code class="docutils literal"><span class="pre">QSG_ATLAS_OVERLAY</span></code> all atlas textures will be colorized so they are easily identifiable in the application.</li>
<li>Use opaque primitives where possible. Opaque primitives are faster to process in the renderer and faster to draw on the GPU. For instance, PNG files will often have an alpha channel, even though each pixel is fully opaque. JPG files are always opaque. When providing images to a <a class="reference internal" href="../PySide2/QtQuick/QQuickImageProvider.html#PySide2.QtQuick.QQuickImageProvider" title="PySide2.QtQuick.QQuickImageProvider"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtQuick.QQuickImageProvider</span></code></a> or creating images with <code class="xref py py-func docutils literal"><span class="pre">QQuickWindow.createTextureFromImage()</span></code> , let the image have <code class="xref py py-attr docutils literal"><span class="pre">QImage.Format_RGB32</span></code> , when possible.</li>
<li>Be aware of that overlapping compound items, like in the illustration above, cannot be batched.</li>
<li>Clipping breaks batching. Never use on a per-item basis, inside table cells, item delegates or similar. Instead of clipping text, use eliding. Instead of clipping an image, create a <a class="reference internal" href="../PySide2/QtQuick/QQuickImageProvider.html#PySide2.QtQuick.QQuickImageProvider" title="PySide2.QtQuick.QQuickImageProvider"><code class="xref py py-class docutils literal"><span class="pre">PySide2.QtQuick.QQuickImageProvider</span></code></a> that returns a cropped image.</li>
<li>Batching only works for 16-bit indices. All built-in items use 16-bit indices, but a custom geometry is free to also use 32-bit indices.</li>
<li>Some material flags prevent batching, the most limiting one being <code class="xref py py-attr docutils literal"><span class="pre">QSGMaterial.RequiresFullMatrix</span></code> which prevents all batching.</li>
<li>Applications with a monochrome background should set it using <code class="xref py py-func docutils literal"><span class="pre">QQuickWindow.setColor()</span></code> rather than using a top-level Rectangle item. <code class="xref py py-func docutils literal"><span class="pre">QQuickWindow.setColor()</span></code> will be used in a call to <code class="docutils literal"><span class="pre">glClear()</span></code>, which is potentially faster.</li>
<li>Mipmapped Image items are not placed in the global atlas and will not be batched.</li>
</ul>
<p>If an application performs poorly, make sure that rendering is actually the bottleneck. Use a profiler! The environment variable <code class="docutils literal"><span class="pre">QSG_RENDER_TIMING=1</span></code> will output a number of useful timing parameters which can be useful in pinpointing where a problem lies.</p>
</div></blockquote>
</div>
<div class="section" id="visualizing">
<span id="id15"></span><h2>Visualizing<a class="headerlink" href="#visualizing" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>To visualize the various aspects of the scene graph’s default renderer, the <code class="docutils literal"><span class="pre">QSG_VISUALIZE</span></code> environment variable can be set to one of the values detailed in each section below. We provide examples of the output of some of the variables using the following QML code:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">QtQuick</span> <span class="mf">2.2</span>

<span class="n">Rectangle</span> <span class="p">{</span>
    <span class="n">width</span><span class="p">:</span> <span class="mi">200</span>
    <span class="n">height</span><span class="p">:</span> <span class="mi">140</span>

    <span class="n">ListView</span> <span class="p">{</span>
        <span class="nb">id</span><span class="p">:</span> <span class="n">clippedList</span>
        <span class="n">x</span><span class="p">:</span> <span class="mi">20</span>
        <span class="n">y</span><span class="p">:</span> <span class="mi">20</span>
        <span class="n">width</span><span class="p">:</span> <span class="mi">70</span>
        <span class="n">height</span><span class="p">:</span> <span class="mi">100</span>
        <span class="n">clip</span><span class="p">:</span> <span class="n">true</span>
        <span class="n">model</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Item A&quot;</span><span class="p">,</span> <span class="s2">&quot;Item B&quot;</span><span class="p">,</span> <span class="s2">&quot;Item C&quot;</span><span class="p">,</span> <span class="s2">&quot;Item D&quot;</span><span class="p">]</span>

        <span class="n">delegate</span><span class="p">:</span> <span class="n">Rectangle</span> <span class="p">{</span>
            <span class="n">color</span><span class="p">:</span> <span class="s2">&quot;lightblue&quot;</span>
            <span class="n">width</span><span class="p">:</span> <span class="n">parent</span><span class="o">.</span><span class="n">width</span>
            <span class="n">height</span><span class="p">:</span> <span class="mi">25</span>

            <span class="n">Text</span> <span class="p">{</span>
                <span class="n">text</span><span class="p">:</span> <span class="n">modelData</span>
                <span class="n">anchors</span><span class="o">.</span><span class="n">fill</span><span class="p">:</span> <span class="n">parent</span>
                <span class="n">horizontalAlignment</span><span class="p">:</span> <span class="n">Text</span><span class="o">.</span><span class="n">AlignHCenter</span>
                <span class="n">verticalAlignment</span><span class="p">:</span> <span class="n">Text</span><span class="o">.</span><span class="n">AlignVCenter</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ListView</span> <span class="p">{</span>
        <span class="nb">id</span><span class="p">:</span> <span class="n">clippedDelegateList</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">clippedList</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">clippedList</span><span class="o">.</span><span class="n">width</span> <span class="o">+</span> <span class="mi">20</span>
        <span class="n">y</span><span class="p">:</span> <span class="mi">20</span>
        <span class="n">width</span><span class="p">:</span> <span class="mi">70</span>
        <span class="n">height</span><span class="p">:</span> <span class="mi">100</span>
        <span class="n">clip</span><span class="p">:</span> <span class="n">true</span>
        <span class="n">model</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Item A&quot;</span><span class="p">,</span> <span class="s2">&quot;Item B&quot;</span><span class="p">,</span> <span class="s2">&quot;Item C&quot;</span><span class="p">,</span> <span class="s2">&quot;Item D&quot;</span><span class="p">]</span>

        <span class="n">delegate</span><span class="p">:</span> <span class="n">Rectangle</span> <span class="p">{</span>
            <span class="n">color</span><span class="p">:</span> <span class="s2">&quot;lightblue&quot;</span>
            <span class="n">width</span><span class="p">:</span> <span class="n">parent</span><span class="o">.</span><span class="n">width</span>
            <span class="n">height</span><span class="p">:</span> <span class="mi">25</span>
            <span class="n">clip</span><span class="p">:</span> <span class="n">true</span>

            <span class="n">Text</span> <span class="p">{</span>
                <span class="n">text</span><span class="p">:</span> <span class="n">modelData</span>
                <span class="n">anchors</span><span class="o">.</span><span class="n">fill</span><span class="p">:</span> <span class="n">parent</span>
                <span class="n">horizontalAlignment</span><span class="p">:</span> <span class="n">Text</span><span class="o">.</span><span class="n">AlignHCenter</span>
                <span class="n">verticalAlignment</span><span class="p">:</span> <span class="n">Text</span><span class="o">.</span><span class="n">AlignVCenter</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For the <span class="xref std std-ref">ListView</span> on the left, we set its <span class="xref std std-ref">clip</span> property to <code class="docutils literal"><span class="pre">true</span></code> . For the <span class="xref std std-ref">ListView</span> on right, we also set each delegate’s <span class="xref std std-ref">clip</span> property to <code class="docutils literal"><span class="pre">true</span></code> to illustrate the effects of clipping on batching.</p>
<p>Original</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The visualized elements do not respect clipping, and rendering order is arbitrary.</p>
</div>
</div></blockquote>
</div>
<div class="section" id="visualizing-batches">
<span id="id16"></span><h2>Visualizing Batches<a class="headerlink" href="#visualizing-batches" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Setting <code class="docutils literal"><span class="pre">QSG_VISUALIZE</span></code> to <code class="docutils literal"><span class="pre">batches</span></code> visualizes batches in the renderer. Merged batches are drawn with a solid color and unmerged batches are drawn with a diagonal line pattern. Few unique colors means good batching. Unmerged batches are bad if they contain many individual nodes.</p>
<p><code class="docutils literal"><span class="pre">QSG_VISUALIZE=batches</span></code></p>
</div></blockquote>
</div>
<div class="section" id="visualizing-clipping">
<span id="id17"></span><h2>Visualizing Clipping<a class="headerlink" href="#visualizing-clipping" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Setting <code class="docutils literal"><span class="pre">QSG_VISUALIZE</span></code> to <code class="docutils literal"><span class="pre">clip</span></code> draws red areas on top of the scene to indicate clipping. As Qt Quick Items do not clip by default, no clipping is usually visualized.</p>
<p><code class="docutils literal"><span class="pre">QSG_VISUALIZE=clip</span></code></p>
</div></blockquote>
</div>
<div class="section" id="visualizing-changes">
<span id="id18"></span><h2>Visualizing Changes<a class="headerlink" href="#visualizing-changes" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>Setting <code class="docutils literal"><span class="pre">QSG_VISUALIZE</span></code> to <code class="docutils literal"><span class="pre">changes</span></code> visualizes changes in the renderer. Changes in the scenegraph are visualized with a flashing overlay of a random color. Changes on a primitive are visualized with a solid color, while changes in an ancestor, such as matrix or opacity changes, are visualized with a pattern.</div></blockquote>
</div>
<div class="section" id="visualizing-overdraw">
<span id="id19"></span><h2>Visualizing Overdraw<a class="headerlink" href="#visualizing-overdraw" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Setting <code class="docutils literal"><span class="pre">QSG_VISUALIZE</span></code> to <code class="docutils literal"><span class="pre">overdraw</span></code> visualizes overdraw in the renderer. Visualize all items in 3D to highlight overdraws. This mode can also be used to detect geometry outside the viewport to some extent. Opaque items are rendered with a green tint, while translucent items are rendered with a red tint. The bounding box for the viewport is rendered in blue. Opaque content is easier for the scenegraph to process and is usually faster to render.</p>
<p>Note that the root rectangle in the code above is superfluous as the window is also white, so drawing the rectangle is a waste of resources in this case. Changing it to an Item can give a slight performance boost.</p>
<p><code class="docutils literal"><span class="pre">QSG_VISUALIZE=overdraw</span></code></p>
</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <p>© 2018 The Qt Company Ltd. Documentation contributions included herein are the copyrights of their respective owners. The documentation provided herein is licensed under the terms of the <a href="http://www.gnu.org/license/fdl.html">GNU Free Documentation License version 1.3</a> as published by the Free Software Foundation. Qt and respective logos are trademarks of The Qt Company Ltd. in Finland and/or other countries worldwide. All other trademarks are property of their respective owners.</p>
    </div></div>
    <div id="footer" class="footer">
    </div>
</div>
  </body>
</html>